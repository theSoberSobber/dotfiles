{"ref":"d8e0626c-ae9f-4da8-984b-6650cd683ad4","syncData":{"version":1,"machineId":"acbf0b4d-dfb3-4a70-97e5-0b62ecf007f0","content":"{\"cpp.json\":\"{\\n\\t\\\"bp\\\": {\\n\\t\\t\\\"prefix\\\": \\\"bp\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"#include <bits/stdc++.h>\\\",\\n\\t\\t  \\\"#ifndef ONLINE_JUDGE\\\",\\n\\t\\t  \\\"#include \\\\\\\"debug.h\\\\\\\"\\\",\\n\\t\\t  \\\"#pragma GCC optimize(\\\\\\\"O3,unroll-loops\\\\\\\")\\\",\\n\\t\\t  \\\"#pragma GCC target(\\\\\\\"avx2,bmi,bmi2,lzcnt,popcnt\\\\\\\")\\\",\\n\\t\\t  \\\"#else\\\",\\n\\t\\t  \\\"#define dbg(x...) \\\\\\\"11-111\\\\\\\"\\\",\\n\\t\\t  \\\"#endif\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"using namespace std;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"#define ll long long\\\",\\n\\t\\t  \\\"#define int long long // because mai bevakoof hu\\\",\\n\\t\\t  \\\"#define logCont(arr,f,l)   { auto start=arr.begin(), end=arr.begin(); advance(start,(f)); advance(end,(l)); for(auto it=start; it!=end; it++) cout<<*it<<\\\\\\\" \\\\\\\"; cout<<\\\\\\\"\\\\\\\\n\\\\\\\"; }\\\",\\n\\t\\t  \\\"#define uniq(x) x.erase(unique(all(x)),x.end());\\\",\\n\\t\\t  \\\"#define tr(s, args...) transform(s.begin(), s.end(), args)\\\",\\n\\t\\t  \\\"#define sz(x) (ll)x.size()\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"// variadic lambda\\\",\\n\\t\\t  \\\"#define f(u, args...)     [&](auto &&u) { return args; }\\\",\\n\\t\\t  \\\"#define g(u, v, args...)  [&](auto &&u, auto &&v) { return args; }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"// precesion\\\",\\n\\t\\t  \\\"#define precise(n)        cout<<fixed<<setprecision((n))\\\",\\n\\t\\t  \\\"// bits\\\",\\n\\t\\t  \\\"#define bpc(n)            std::popcount((unsigned long long)(n))\\\",\\n\\t\\t  \\\"#define hsb(n)            std::has_single_bit((unsigned long long)(n))\\\",\\n\\t\\t  \\\"#define MSB(n)            std::bit_floor((unsigned long long)(n))\\\",\\n\\t\\t  \\\"#define ctz(n)            ((n) ? __builtin_ctzll((unsigned long long)(n)) : 0)\\\",\\n\\t\\t  \\\"#define clz(n)            ((n) ? __builtin_clzll((unsigned long long)(n)) : 64)\\\",\\n\\t\\t  \\\"#define LSB(n)            ((n)&(-(n)))\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"// general amax, amin for any ds, to be able to use swap in graphs and stuff\\\",\\n\\t\\t  \\\"template<typename T,typename T1> inline bool amax(T &a,T1 b){ if(b>a) { a=b; return true; } return false; }\\\",\\n\\t\\t  \\\"template<typename T,typename T1> inline bool amin(T &a,T1 b){ if(b<a) { a=b; return true; } return false; }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"// comparison struct for maps (or use decltype)\\\",\\n\\t\\t  \\\"template<typename T> struct Comp { bool operator()(const T& l, const T& r) const { return l < r; } };\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"constexpr ll Inf = 4e18;\\\",\\n\\t\\t  \\\"constexpr int mod = 1e9+7;\\\",\\n\\t\\t  \\\"// constexpr int mod = 998244353;\\\",\\n\\t\\t  \\\"constexpr int maxn = 1e6+5;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"// sasta mint\\\",\\n\\t\\t  \\\"ll inv(ll i) {if (i == 1) return 1; return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;}\\\",\\n\\t\\t  \\\"ll mod_mul(ll a, ll b) {a = a % mod; b = b % mod; return (((a * b) % mod) + mod) % mod;}\\\",\\n\\t\\t  \\\"ll mod_add(ll a, ll b) {a = a % mod; b = b % mod; return (((a + b) % mod) + mod) % mod;}\\\",\\n\\t\\t  \\\"ll gcd(ll a, ll b) { if (b == 0) return a; return gcd(b, a % b);}\\\",\\n\\t\\t  \\\"ll ceil_div(ll a, ll b) {return a % b == 0 ? a / b : a / b + 1;}\\\",\\n\\t\\t  \\\"ll pwr(ll a, ll b) {a %= mod; ll res = 1; while (b > 0) {if (b & 1) res = res * a % mod; a = a * a % mod; b >>= 1;} return res;}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"// pows\\\",\\n\\t\\t  \\\"inline ll po(ll a, ll b) { ll res = 1; for (; b; b >>= 1) { if (b & 1)res = res * a; a = a * a; }return res; }\\\",\\n\\t\\t  \\\"inline ll modpow(ll a, ll b, ll mod) { ll res = 1; for (; b; b >>= 1) { if (b & 1)res = (res * a)%mod; a = (a * a)%mod; }return res; }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void pre_process(){\\\",\\n\\t\\t  \\\"    \\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"int solve(){\\\",\\n\\t\\t  \\\"    int n; cin>>n;\\\",\\n\\t\\t  \\\"    dbg(n);\\\",\\n\\t\\t  \\\"    return 2*n; \\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"int32_t main(){\\\",\\n\\t\\t  \\\"    ios_base::sync_with_stdio(0);\\\",\\n\\t\\t  \\\"    cin.tie(0); cout.tie(0);\\\",\\n\\t\\t  \\\"    pre_process();\\\",\\n\\t\\t  \\\"    int t; cin>>t;\\\",\\n\\t\\t  \\\"    while(t--) cout<<solve()<<'\\\\\\\\n';\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"bp\\\"\\n\\t},\\n\\t\\\"gr-inp-wt\\\": {\\n\\t\\t\\\"prefix\\\": \\\"gr-inp-Fwt\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"int e=f(n);\\\",\\n\\t\\t  \\\"vector<vector<pair<int,int>>> g(n+1);\\\",\\n\\t\\t  \\\"for(int i=1;i<=e;i++){\\\",\\n\\t\\t  \\\"  int u,v,wt; cin>>u>>v>>wt;\\\",\\n\\t\\t  \\\"  g[u].push_back({v,wt});\\\",\\n\\t\\t  \\\"  g[v].push_back({u,wt});\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"graph input weight\\\"\\n\\t},\\n\\t\\\"gr-inp\\\": {\\n\\t\\t\\\"prefix\\\": \\\"gr-inp\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"int e=f(n);\\\",\\n\\t\\t  \\\"vector<vector<int>> g(n+1);\\\",\\n\\t\\t  \\\"for(int i=1;i<=e;i++){\\\",\\n\\t\\t  \\\"  int u,v; cin>>u>>v;\\\",\\n\\t\\t  \\\"  g[u].push_back(v);\\\",\\n\\t\\t  \\\"  g[v].push_back(u);\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"graph input\\\"\\n\\t},\\n\\t\\\"ip-overloads\\\": {\\n\\t\\t\\\"prefix\\\": \\\"ip-overloads\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"template<typename T1, typename T2> inline istream& operator >> (istream& in, pair<T1,T2>& a) { in>>a.first>>a.second; return in; }\\\",\\n\\t\\t  \\\"template<typename T1, typename T2> inline ostream& operator << (ostream& out, pair<T1,T2> a) { out<<a.first<<\\\\\\\" \\\\\\\"<<a.second; return out; }\\\",\\n\\t\\t  \\\"template<typename T> istream& operator >> (istream& in, vector<T>& v) { rep(i,1,sz(v)) cin>>v[i]; return in; }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void read(auto&... args) { ((cin>>args), ...); }\\\",\\n\\t\\t  \\\"void put(auto&&... args) { ((cout<<args<<\\\\\\\" \\\\\\\"), ...);}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"#define get(T,args...)    T args; read(args);\\\",\\n\\t\\t  \\\"#define putn(args...)     { put(args); cout<<\\\\\\\"\\\\\\\\n\\\\\\\"; }\\\",\\n\\t\\t  \\\"#define pute(args...)     { put(args); cout<<endl; }\\\",\\n\\t\\t  \\\"#define putr(args...)     { putn(args) return ;}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"I/O Overloads that I don't use\\\"\\n\\t},\\n\\t\\\"file_io\\\": {\\n\\t\\t\\\"prefix\\\": \\\"file_io\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"void file_i_o(){\\\",\\n\\t\\t  \\\"    freopen(\\\\\\\"./tests/test01.txt\\\\\\\", \\\\\\\"r\\\\\\\", stdin);\\\",\\n\\t\\t  \\\"    freopen(\\\\\\\"./tests/output01.txt\\\\\\\", \\\\\\\"w\\\\\\\", stdout);\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"for coding competetions\\\"\\n\\t},\\n\\t\\\"tokenizer\\\": {\\n\\t\\t\\\"prefix\\\": \\\"tokenizer\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"vec(string) tokenizer(string str,char ch) {std::istringstream var((str)); vec(string) v; string t; while(getline((var), t, (ch))) {v.pb(t);} return v;}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"tokenizer that has no use\\\"\\n\\t},\\n\\t\\\"clock\\\": {\\n\\t\\t\\\"prefix\\\": \\\"clock for TL\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"auto start = chrono::high_resolution_clock::now();\\\",\\n\\t\\t  \\\"// code goes here\\\",\\n\\t\\t  \\\"auto stop = chrono::high_resolution_clock::now();\\\",\\n\\t\\t  \\\"auto duration = chrono::duration_cast<chrono::milliseconds>(stop - start);\\\",\\n\\t\\t  \\\"cout << duration.count() << \\\\\\\" ms\\\\\\\\n\\\\\\\";\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"clock\\\"\\n\\t},\\n\\t\\\"sextree\\\": {\\n\\t\\t\\\"prefix\\\": \\\"segtree\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"template<class T, class U>\\\",\\n\\t\\t  \\\"// T -> node, U->update.\\\",\\n\\t\\t  \\\"struct Lsegtree{\\\",\\n\\t\\t  \\\"    vector<T>st;\\\",\\n\\t\\t  \\\"    vector<U>lazy;\\\",\\n\\t\\t  \\\"    ll n;\\\",\\n\\t\\t  \\\"    T identity_element;\\\",\\n\\t\\t  \\\"    U identity_update;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    /*\\\",\\n\\t\\t  \\\"        Definition of identity_element: the element I such that combine(x,I) = x\\\",\\n\\t\\t  \\\"        for all x\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"        Definition of identity_update: the element I such that apply(x,I) = x\\\",\\n\\t\\t  \\\"        for all x        \\\",\\n\\t\\t  \\\"    */\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    Lsegtree(ll n, T identity_element, U identity_update){\\\",\\n\\t\\t  \\\"        this->n = n;\\\",\\n\\t\\t  \\\"        this->identity_element = identity_element;\\\",\\n\\t\\t  \\\"        this->identity_update = identity_update;\\\",\\n\\t\\t  \\\"        st.assign(4*n,identity_element);\\\",\\n\\t\\t  \\\"        lazy.assign(4*n, identity_update);\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    T combine(T l, T r){\\\",\\n\\t\\t  \\\"        // change this function as required.\\\",\\n\\t\\t  \\\"        T ans = (l + r);\\\",\\n\\t\\t  \\\"        return ans;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    void buildUtil(ll v, ll tl, ll tr, vector<T>&a){\\\",\\n\\t\\t  \\\"        if(tl == tr){\\\",\\n\\t\\t  \\\"            st[v] = a[tl];\\\",\\n\\t\\t  \\\"            return;\\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"        ll tm = (tl + tr)>>1;\\\",\\n\\t\\t  \\\"        buildUtil(2*v + 1, tl, tm,a);\\\",\\n\\t\\t  \\\"        buildUtil(2*v + 2,tm+1,tr,a);\\\",\\n\\t\\t  \\\"        st[v] = combine(st[2*v + 1], st[2*v + 2]);\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    // change the following 2 functions, and you're more or less done.\\\",\\n\\t\\t  \\\"    T apply(T curr, U upd, ll tl, ll tr){\\\",\\n\\t\\t  \\\"        T ans = (tr-tl+1)*upd;\\\",\\n\\t\\t  \\\"        // increment range by upd:\\\",\\n\\t\\t  \\\"        // T ans = curr + (tr - tl + 1)*upd\\\",\\n\\t\\t  \\\"        return ans;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    U combineUpdate(U old_upd, U new_upd, ll tl, ll tr){\\\",\\n\\t\\t  \\\"        U ans = old_upd;\\\",\\n\\t\\t  \\\"        ans=new_upd;\\\",\\n\\t\\t  \\\"        return ans;\\\",\\n\\t\\t  \\\"    }  \\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    void push_down(ll v, ll tl, ll tr){\\\",\\n\\t\\t  \\\"        //for the below line to work, make sure the \\\\\\\"==\\\\\\\" operator is defined for U.\\\",\\n\\t\\t  \\\"        if(lazy[v] == identity_update)return;\\\",\\n\\t\\t  \\\"        st[v] = apply(st[v], lazy[v], tl, tr);\\\",\\n\\t\\t  \\\"        if(2*v + 1 <= 4*n){\\\",\\n\\t\\t  \\\"            ll tm = (tl + tr)>>1;\\\",\\n\\t\\t  \\\"            lazy[2*v + 1] = combineUpdate(lazy[2*v+1], lazy[v], tl, tm);\\\",\\n\\t\\t  \\\"            lazy[2*v + 2] = combineUpdate(lazy[2*v+2], lazy[v], tm+1,tr);            \\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"        lazy[v] = identity_update;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    T queryUtil(ll v, ll tl, ll tr, ll l, ll r){\\\",\\n\\t\\t  \\\"        push_down(v,tl,tr);\\\",\\n\\t\\t  \\\"        if(l > r)return identity_element;\\\",\\n\\t\\t  \\\"        if(tr < l or tl > r){\\\",\\n\\t\\t  \\\"            return identity_element;\\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"        if(l <= tl and r >= tr){\\\",\\n\\t\\t  \\\"            return st[v];\\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"        ll tm = (tl + tr)>>1;\\\",\\n\\t\\t  \\\"        return combine(queryUtil(2*v+1,tl,tm,l,r), queryUtil(2*v+2,tm+1,tr,l,r));\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\" \\\",\\n\\t\\t  \\\"    void updateUtil(ll v, ll tl, ll tr, ll l, ll r, U upd){\\\",\\n\\t\\t  \\\"        push_down(v,tl,tr); \\\",\\n\\t\\t  \\\"        if(tr < l or tl > r)return;\\\",\\n\\t\\t  \\\"        if(tl >=l and tr <=r){\\\",\\n\\t\\t  \\\"            lazy[v] = combineUpdate(lazy[v],upd,tl,tr);\\\",\\n\\t\\t  \\\"            push_down(v,tl,tr);\\\",\\n\\t\\t  \\\"        } else{\\\",\\n\\t\\t  \\\"            ll tm = (tl + tr)>>1;\\\",\\n\\t\\t  \\\"            updateUtil(2*v+1,tl,tm,l,r,upd);\\\",\\n\\t\\t  \\\"            updateUtil(2*v+2,tm+1,tr,l,r,upd);\\\",\\n\\t\\t  \\\"            st[v] = combine(st[2*v + 1], st[2*v+2]);\\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    void build(vector<T>a){\\\",\\n\\t\\t  \\\"        assert( (ll)a.size() == n);\\\",\\n\\t\\t  \\\"        buildUtil(0,0,n-1,a);\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    T query(ll l, ll r){\\\",\\n\\t\\t  \\\"        return queryUtil(0,0,n-1,l,r);\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    void update(ll l,ll r, U upd){\\\",\\n\\t\\t  \\\"        updateUtil(0,0,n-1,l,r,upd);\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"};\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"sextree\\\"\\n\\t},\\n\\t\\\"binary indexed tree\\\": {\\n\\t\\t\\\"prefix\\\": \\\"fenwick\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"// 0-indexed BIT (binary indexed tree / Fenwick tree) (i : [0, len))\\\",\\n\\t\\t  \\\"template <class T>\\\",\\n\\t\\t  \\\"struct BIT{\\\",\\n\\t\\t  \\\"    int n;\\\",\\n\\t\\t  \\\"    vector<T> data;\\\",\\n\\t\\t  \\\"    BIT(int len = 0) : n(len), data(len) {}\\\",\\n\\t\\t  \\\"    void reset() { fill(data.begin(), data.end(), T(0)); }\\\",\\n\\t\\t  \\\"    void add(int pos, T v){ \\\",\\n\\t\\t  \\\"        // a[pos] += v\\\",\\n\\t\\t  \\\"        pos++;\\\",\\n\\t\\t  \\\"        while (pos > 0 and pos <= n)\\\",\\n\\t\\t  \\\"            data[pos - 1] += v, pos += pos & -pos;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    T sum(int k) const{ \\\",\\n\\t\\t  \\\"        // a[0] + ... + a[k - 1]\\\",\\n\\t\\t  \\\"        T res = 0;\\\",\\n\\t\\t  \\\"        while (k > 0)\\\",\\n\\t\\t  \\\"            res += data[k - 1], k -= k & -k;\\\",\\n\\t\\t  \\\"        return res;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    T sum(int l, int r) const { return sum(r) - sum(l); } // a[l] + ... + a[r - 1]\\\",\\n\\t\\t  \\\"    // dbg functions\\\",\\n\\t\\t  \\\"    template <class OStream>\\\",\\n\\t\\t  \\\"    friend OStream &operator<<(OStream &os, const BIT &bit){\\\",\\n\\t\\t  \\\"        T prv = 0;\\\",\\n\\t\\t  \\\"        os << '[';\\\",\\n\\t\\t  \\\"        for (int i = 1; i <= bit.n; i++){\\\",\\n\\t\\t  \\\"            T now = bit.sum(i);\\\",\\n\\t\\t  \\\"            os << now - prv << ',', prv = now;\\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"        return os << ']';\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"};\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"binary indexed tree\\\"\\n\\t},\\n\\t\\\"trie\\\": {\\n\\t\\t\\\"prefix\\\": \\\"trie\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"struct Trie{\\\",\\n\\t\\t  \\\"    struct node{\\\",\\n\\t\\t  \\\"        node* next[10];\\\",\\n\\t\\t  \\\"        node(){\\\",\\n\\t\\t  \\\"            for(int i=0;i<10;i++) next[i]=NULL;\\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"    };\\\",\\n\\t\\t  \\\" \\\",\\n\\t\\t  \\\"    node root;\\\",\\n\\t\\t  \\\" \\\",\\n\\t\\t  \\\"    void add(vector<int>&val){\\\",\\n\\t\\t  \\\"        node* temp=&root;\\\",\\n\\t\\t  \\\"        for(auto ele : val){\\\",\\n\\t\\t  \\\"            if(temp->next[ele]==NULL) temp->next[ele]=new node();\\\",\\n\\t\\t  \\\"            temp=temp->next[ele];\\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\" \\\",\\n\\t\\t  \\\"    int query(vector<int>&val){\\\",\\n\\t\\t  \\\"        node* temp=&root;\\\",\\n\\t\\t  \\\"        int ans=0;\\\",\\n\\t\\t  \\\"        for(auto ele : val){\\\",\\n\\t\\t  \\\"            if(temp->next[ele]==NULL) break;\\\",\\n\\t\\t  \\\"            ans++;\\\",\\n\\t\\t  \\\"            temp=temp->next[ele];\\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"        return ans;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"};\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"trie\\\"\\n\\t},\\n\\t\\\"pbds\\\": {\\n\\t\\t\\\"prefix\\\": \\\"pbds\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"#include <ext/pb_ds/assoc_container.hpp>\\\",\\n\\t\\t  \\\"#include <ext/pb_ds/tree_policy.hpp>\\\",\\n\\t\\t  \\\"using namespace __gnu_pbds;\\\",\\n\\t\\t  \\\"// pbds = find_by_value(), order_of_key()\\\",\\n\\t\\t  \\\"// find_by_order(k)  returns iterator to kth element starting from 0;\\\",\\n\\t\\t  \\\"// order_of_key(k) returns count of elements strictly smaller than k;\\\",\\n\\t\\t  \\\"template<class T> using minheap = priority_queue<T,vector<T>,greater<T> >; \\\",\\n\\t\\t  \\\"template<class T> using ordered_set = tree<T, null_type,less<T>, rb_tree_tag, tree_order_statistics_node_update> ;\\\",\\n\\t\\t  \\\"template<class key, class value, class cmp = std::less<key>> using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"pbds\\\"\\n\\t},\\n\\t\\\"xor-basis\\\": {\\n\\t\\t\\\"prefix\\\": \\\"xor-basis\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"struct XorBasis{\\\",\\n\\t\\t  \\\"    private:\\\",\\n\\t\\t  \\\"    vector<ll> basis;\\\",\\n\\t\\t  \\\"    int lg;\\\",\\n\\t\\t  \\\"    int sz = 0;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    public:\\\",\\n\\t\\t  \\\"    XorBasis(int lg) : lg(lg){\\\",\\n\\t\\t  \\\"        basis.resize(lg);\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    void add(ll x){\\\",\\n\\t\\t  \\\"        if(x >= (1ll<<lg)) return;\\\",\\n\\t\\t  \\\"        for(int i=0;i<lg;i++){\\\",\\n\\t\\t  \\\"            if(~x&(1ll<<i)) continue;\\\",\\n\\t\\t  \\\"            if(!basis[i]){\\\",\\n\\t\\t  \\\"                basis[i] = x;\\\",\\n\\t\\t  \\\"                ++sz;\\\",\\n\\t\\t  \\\"            }\\\",\\n\\t\\t  \\\"            x^=basis[i];\\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    bool contains(ll x){\\\",\\n\\t\\t  \\\"        for(int i=0;i<lg;i++){\\\",\\n\\t\\t  \\\"            if(~x&(1ll<<i)) continue;\\\",\\n\\t\\t  \\\"            if(!basis[i]){\\\",\\n\\t\\t  \\\"                return false;\\\",\\n\\t\\t  \\\"            }\\\",\\n\\t\\t  \\\"            x^=basis[i];\\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"        return true;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    int size(){\\\",\\n\\t\\t  \\\"        return sz;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    const vector<ll>::iterator begin(){\\\",\\n\\t\\t  \\\"        return basis.begin();\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    const vector<ll>::iterator end(){\\\",\\n\\t\\t  \\\"        return basis.end();\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"};\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"xor-basis\\\"\\n\\t},\\n\\t\\\"linear diophantine\\\": {\\n\\t\\t\\\"prefix\\\": \\\"diophantine\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"long long gcd(long long a, long long b, long long &x, long long &y) {\\\",\\n\\t\\t  \\\"  if (a == 0) {\\\",\\n\\t\\t  \\\"    x = 0;\\\",\\n\\t\\t  \\\"    y = 1;\\\",\\n\\t\\t  \\\"    return b;\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"  long long x1, y1;\\\",\\n\\t\\t  \\\"  long long d = gcd(b % a, a, x1, y1);\\\",\\n\\t\\t  \\\"  x = y1 - (b / a) * x1;\\\",\\n\\t\\t  \\\"  y = x1;\\\",\\n\\t\\t  \\\"  return d;\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"bool find_any_solution(long long a, long long b, long long c, long long &x0,\\\",\\n\\t\\t  \\\"    long long &y0, long long &g) {\\\",\\n\\t\\t  \\\"  g = gcd(abs(a), abs(b), x0, y0);\\\",\\n\\t\\t  \\\"  if (c % g) {\\\",\\n\\t\\t  \\\"    return false;\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  x0 *= c / g;\\\",\\n\\t\\t  \\\"  y0 *= c / g;\\\",\\n\\t\\t  \\\"  if (a < 0) x0 = -x0;\\\",\\n\\t\\t  \\\"  if (b < 0) y0 = -y0;\\\",\\n\\t\\t  \\\"  return true;\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void shift_solution(long long &x, long long &y, long long a, long long b,\\\",\\n\\t\\t  \\\"    long long cnt) {\\\",\\n\\t\\t  \\\"  x += cnt * b;\\\",\\n\\t\\t  \\\"  y -= cnt * a;\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"long long find_all_solutions(long long a, long long b, long long c,\\\",\\n\\t\\t  \\\"    long long minx, long long maxx, long long miny,\\\",\\n\\t\\t  \\\"    long long maxy) {\\\",\\n\\t\\t  \\\"  long long x, y, g;\\\",\\n\\t\\t  \\\"  if (!find_any_solution(a, b, c, x, y, g)) return 0;\\\",\\n\\t\\t  \\\"  a /= g;\\\",\\n\\t\\t  \\\"  b /= g;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  long long sign_a = a > 0 ? +1 : -1;\\\",\\n\\t\\t  \\\"  long long sign_b = b > 0 ? +1 : -1;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  shift_solution(x, y, a, b, (minx - x) / b);\\\",\\n\\t\\t  \\\"  if (x < minx) shift_solution(x, y, a, b, sign_b);\\\",\\n\\t\\t  \\\"  if (x > maxx) return 0;\\\",\\n\\t\\t  \\\"  long long lx1 = x;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  shift_solution(x, y, a, b, (maxx - x) / b);\\\",\\n\\t\\t  \\\"  if (x > maxx) shift_solution(x, y, a, b, -sign_b);\\\",\\n\\t\\t  \\\"  long long rx1 = x;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  shift_solution(x, y, a, b, -(miny - y) / a);\\\",\\n\\t\\t  \\\"  if (y < miny) shift_solution(x, y, a, b, -sign_a);\\\",\\n\\t\\t  \\\"  if (y > maxy) return 0;\\\",\\n\\t\\t  \\\"  long long lx2 = x;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  shift_solution(x, y, a, b, -(maxy - y) / a);\\\",\\n\\t\\t  \\\"  if (y > maxy) shift_solution(x, y, a, b, sign_a);\\\",\\n\\t\\t  \\\"  long long rx2 = x;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  if (lx2 > rx2) swap(lx2, rx2);\\\",\\n\\t\\t  \\\"  long long lx = max(lx1, lx2);\\\",\\n\\t\\t  \\\"  long long rx = min(rx1, rx2);\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  if (lx > rx) return 0;\\\",\\n\\t\\t  \\\"  return (rx - lx) / abs(b) + 1;\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"linear diophantine\\\"\\n\\t},\\n\\t\\\"crt\\\": {\\n\\t\\t\\\"prefix\\\": \\\"crt\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"/**\\\",\\n\\t\\t  \\\" * Chinese remainder theorem.\\\",\\n\\t\\t  \\\" * Find z such that  z % x[i] = a[i] for all i.\\\",\\n\\t\\t  \\\" * */\\\",\\n\\t\\t  \\\"long long crt(vector<long long> &a, vector<long long> &x) {\\\",\\n\\t\\t  \\\"  long long z = 0;\\\",\\n\\t\\t  \\\"  long long n = 1;\\\",\\n\\t\\t  \\\"  for (int i = 0; i < x.size(); ++i)\\\",\\n\\t\\t  \\\"    n *= x[i];\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  for (int i = 0; i < a.size(); ++i) {\\\",\\n\\t\\t  \\\"    long long tmp = (a[i] * (n / x[i])) % n;\\\",\\n\\t\\t  \\\"    tmp = (tmp * mod_inv(n / x[i], x[i])) % n;\\\",\\n\\t\\t  \\\"    z = (z + tmp) % n;\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  return (z + n) % n;\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"crt\\\"\\n\\t},\\n\\t\\\"totient-seive\\\": {\\n\\t\\t\\\"prefix\\\": \\\"totient-seive\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"  for (int i = 1; i < MN; i++)\\\",\\n\\t\\t  \\\"    phi[i] = i;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  for (int i = 1; i < MN; i++)\\\",\\n\\t\\t  \\\"    if (!sieve[i]) // is prime\\\",\\n\\t\\t  \\\"      for (int j = i; j < MN; j += i)\\\",\\n\\t\\t  \\\"        phi[j] -= phi[j] / i;\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"totient-seive\\\"\\n\\t},\\n\\t\\\"totient\\\": {\\n\\t\\t\\\"prefix\\\": \\\"totient\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"long long totient(long long n) {\\\",\\n\\t\\t  \\\"  if (n == 1) return 0;\\\",\\n\\t\\t  \\\"  long long ans = n;\\\",\\n\\t\\t  \\\"  for (int i = 0; primes[i] * primes[i] <= n; ++i) {\\\",\\n\\t\\t  \\\"    if ((n % primes[i]) == 0) {\\\",\\n\\t\\t  \\\"      while ((n % primes[i]) == 0) n /= primes[i];\\\",\\n\\t\\t  \\\"      ans -= ans / primes[i];\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"  if (n > 1) {\\\",\\n\\t\\t  \\\"    ans -= ans / n;\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"  return ans;\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"totient\\\"\\n\\t},\\n\\t\\\"log\\\": {\\n\\t\\t\\\"prefix\\\": \\\"log\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"// Computes x which a ^ x = b mod n.\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"long long d_log(long long a, long long b, long long n) {\\\",\\n\\t\\t  \\\"  long long m = ceil(sqrt(n));\\\",\\n\\t\\t  \\\"  long long aj = 1;\\\",\\n\\t\\t  \\\"  map<long long, long long> M;\\\",\\n\\t\\t  \\\"  for (int i = 0; i < m; ++i) {\\\",\\n\\t\\t  \\\"    if (!M.count(aj))\\\",\\n\\t\\t  \\\"      M[aj] = i;\\\",\\n\\t\\t  \\\"    aj = (aj * a) % n;\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  long long coef = mod_pow(a, n - 2, n);\\\",\\n\\t\\t  \\\"  coef = mod_pow(coef, m, n);\\\",\\n\\t\\t  \\\"  // coef =  a ^ (-m)\\\",\\n\\t\\t  \\\"  long long gamma = b;\\\",\\n\\t\\t  \\\"  for (int i = 0; i < m; ++i) {\\\",\\n\\t\\t  \\\"    if (M.count(gamma)) {\\\",\\n\\t\\t  \\\"      return i * m + M[gamma];\\\",\\n\\t\\t  \\\"    } else {\\\",\\n\\t\\t  \\\"      gamma = (gamma * coef) % n;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"  return -1;\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"log\\\"\\n\\t},\\n\\t\\\"matrix\\\": {\\n\\t\\t\\\"prefix\\\": \\\"matrix\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"const int MN  = 111;\\\",\\n\\t\\t  \\\"const int mod = 10000;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"struct matrix {\\\",\\n\\t\\t  \\\"  int r, c;\\\",\\n\\t\\t  \\\"  int m[MN][MN];\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  matrix (int _r, int _c) : r (_r), c (_c) {\\\",\\n\\t\\t  \\\"    memset(m, 0, sizeof m);\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  void print() {\\\",\\n\\t\\t  \\\"    for (int i = 0; i < r; ++i) {\\\",\\n\\t\\t  \\\"      for (int j = 0; j < c; ++j)\\\",\\n\\t\\t  \\\"        cout << m[i][j] << \\\\\\\" \\\\\\\";\\\",\\n\\t\\t  \\\"      cout << endl;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  int x[MN][MN];\\\",\\n\\t\\t  \\\"  matrix & operator *= (const matrix &o) {\\\",\\n\\t\\t  \\\"    memset(x, 0, sizeof x);\\\",\\n\\t\\t  \\\"    for (int i = 0; i < r; ++i)\\\",\\n\\t\\t  \\\"      for (int k = 0; k < c; ++k)\\\",\\n\\t\\t  \\\"        if (m[i][k] != 0)\\\",\\n\\t\\t  \\\"          for (int j = 0; j < c; ++j) {\\\",\\n\\t\\t  \\\"            x[i][j] = (x[i][j] +  ((m[i][k] * o.m[k][j]) % mod) ) % mod;\\\",\\n\\t\\t  \\\"          }\\\",\\n\\t\\t  \\\"    memcpy(m, x, sizeof(m));\\\",\\n\\t\\t  \\\"    return *this;\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"};\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void matrix_pow(matrix b, long long e, matrix &res) {\\\",\\n\\t\\t  \\\"  memset(res.m, 0, sizeof res.m);\\\",\\n\\t\\t  \\\"  for (int i = 0; i < b.r; ++i)\\\",\\n\\t\\t  \\\"    res.m[i][i] = 1;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  if (e == 0) return;\\\",\\n\\t\\t  \\\"  while (true) {\\\",\\n\\t\\t  \\\"    if (e & 1) res *= b;\\\",\\n\\t\\t  \\\"    if ((e >>= 1) == 0) break;\\\",\\n\\t\\t  \\\"    b *= b;\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"matrix\\\"\\n\\t},\\n\\t\\n\\t\\\"power_in_fac\\\": {\\n\\t\\t\\\"prefix\\\": \\\"highest_exponent\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"int highest_exponent(int p, const int &n){\\\",\\n\\t\\t  \\\"  int ans = 0;\\\",\\n\\t\\t  \\\"  int t = p;\\\",\\n\\t\\t  \\\"  while(t <= n){\\\",\\n\\t\\t  \\\"    ans += n/t;\\\",\\n\\t\\t  \\\"    t*=p;\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"  return ans;\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"power_in_fac\\\"\\n\\t},\\n\\t\\\"freq-map\\\": {\\n\\t\\t\\\"prefix\\\": \\\"freq-map\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"map<int, int> m;\\\",\\n\\t\\t  \\\"for(int i=0; i<n;i++){\\\",\\n\\t\\t  \\\"  if(m.find(a[i])==m.end()) m[a[i]]=1;\\\",\\n\\t\\t  \\\"  else m[a[i]]++;\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"freq-map\\\"\\n\\t},\\n\\t\\\"rng\\\": {\\n\\t\\t\\\"prefix\\\": \\\"rng\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"//random generator\\\",\\n\\t\\t  \\\"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\\\",\\n\\t\\t  \\\"ll rnd(ll a,ll b){if(a > b){return -1;}return a + (ll)rng() % (b - a + 1);}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"rng\\\"\\n\\t},\\n\\t\\\"two-sat (kosaraju)\\\": {\\n\\t\\t\\\"prefix\\\": \\\"two-sat (kosaraju)\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"/**\\\",\\n\\t\\t  \\\" *  Given a set of clauses (a1 v a2)^(a2 v ¬a3)....\\\",\\n\\t\\t  \\\" *  this algorithm find a solution to it set of clauses.\\\",\\n\\t\\t  \\\" *  test: http://lightoj.com/volume_showproblem.php?problem=1251\\\",\\n\\t\\t  \\\" **/\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"#include<bits/stdc++.h>\\\",\\n\\t\\t  \\\"using namespace std;\\\",\\n\\t\\t  \\\"#define MAX 100000\\\",\\n\\t\\t  \\\"#define endl '\\\\\\\\n'\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"vector<int> G[MAX];\\\",\\n\\t\\t  \\\"vector<int> GT[MAX];\\\",\\n\\t\\t  \\\"vector<int> Ftime;\\\",\\n\\t\\t  \\\"vector<vector<int> > SCC;\\\",\\n\\t\\t  \\\"bool visited[MAX];\\\",\\n\\t\\t  \\\"int n;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void dfs1(int n){\\\",\\n\\t\\t  \\\"  visited[n] = 1;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  for (int i = 0; i < G[n].size(); ++i) {\\\",\\n\\t\\t  \\\"    int curr = G[n][i];\\\",\\n\\t\\t  \\\"    if (visited[curr]) continue;\\\",\\n\\t\\t  \\\"    dfs1(curr);\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  Ftime.push_back(n);\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void dfs2(int n, vector<int> &scc) {\\\",\\n\\t\\t  \\\"  visited[n] = 1;\\\",\\n\\t\\t  \\\"  scc.push_back(n);\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  for (int i = 0;i < GT[n].size(); ++i) {\\\",\\n\\t\\t  \\\"    int curr = GT[n][i];\\\",\\n\\t\\t  \\\"    if (visited[curr]) continue;\\\",\\n\\t\\t  \\\"    dfs2(curr, scc);\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void kosaraju() {\\\",\\n\\t\\t  \\\"  memset(visited, 0, sizeof visited);\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  for (int i = 0; i < 2 * n ; ++i) {\\\",\\n\\t\\t  \\\"    if (!visited[i]) dfs1(i);\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  memset(visited, 0, sizeof visited);\\\",\\n\\t\\t  \\\"  for (int i = Ftime.size() - 1; i >= 0; i--) {\\\",\\n\\t\\t  \\\"    if (visited[Ftime[i]]) continue;\\\",\\n\\t\\t  \\\"    vector<int> _scc;\\\",\\n\\t\\t  \\\"    dfs2(Ftime[i],_scc);\\\",\\n\\t\\t  \\\"    SCC.push_back(_scc);\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"/**\\\",\\n\\t\\t  \\\" * After having the SCC, we must  traverse each scc, if in one SCC are -b y b, there is not a solution.\\\",\\n\\t\\t  \\\" * Otherwise we  build a solution, making the first \\\\\\\"node\\\\\\\" that we find truth and its complement false.\\\",\\n\\t\\t  \\\" **/\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"bool two_sat(vector<int> &val) {\\\",\\n\\t\\t  \\\"  kosaraju();\\\",\\n\\t\\t  \\\"  for (int i = 0; i < SCC.size(); ++i) {\\\",\\n\\t\\t  \\\"    vector<bool> tmpvisited(2 * n, false);\\\",\\n\\t\\t  \\\"    for (int j = 0; j < SCC[i].size(); ++j) {\\\",\\n\\t\\t  \\\"      if (tmpvisited[SCC[i][j] ^ 1]) return 0;\\\",\\n\\t\\t  \\\"      if (val[SCC[i][j]] != -1) continue;\\\",\\n\\t\\t  \\\"      else {\\\",\\n\\t\\t  \\\"        val[SCC[i][j]] = 0;\\\",\\n\\t\\t  \\\"        val[SCC[i][j] ^ 1] = 1;\\\",\\n\\t\\t  \\\"      }\\\",\\n\\t\\t  \\\"      tmpvisited[SCC[i][j]] = 1;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"  return 1;\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"// Example of use\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"int main() {\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  int m, u, v, nc = 0, t; cin >> t;\\\",\\n\\t\\t  \\\"  // n = \\\\\\\"nodes\\\\\\\" number, m = clauses number\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"  while (t--) {\\\",\\n\\t\\t  \\\"    cin >> m >> n;\\\",\\n\\t\\t  \\\"    Ftime.clear();\\\",\\n\\t\\t  \\\"    SCC.clear();\\\",\\n\\t\\t  \\\"    for (int i = 0; i < 2 * n; ++i) {\\\",\\n\\t\\t  \\\"      G[i].clear();\\\",\\n\\t\\t  \\\"      GT[i].clear();\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    // (a1 v a2) = (¬a1 -> a2) = (¬a2 -> a1)\\\",\\n\\t\\t  \\\"    for (int i = 0; i < m ; ++i) {\\\",\\n\\t\\t  \\\"      cin >> u >> v;\\\",\\n\\t\\t  \\\"      int t1 = abs(u) - 1;\\\",\\n\\t\\t  \\\"      int t2 = abs(v) - 1;\\\",\\n\\t\\t  \\\"      int p = t1 * 2 + ((u < 0)? 1 : 0);\\\",\\n\\t\\t  \\\"      int q = t2 * 2 + ((v < 0)? 1 : 0);\\\",\\n\\t\\t  \\\"      G[p ^ 1].push_back(q);\\\",\\n\\t\\t  \\\"      G[q ^ 1].push_back(p);\\\",\\n\\t\\t  \\\"      GT[p].push_back(q ^ 1);\\\",\\n\\t\\t  \\\"      GT[q].push_back(p ^ 1);\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    vector<int> val(2 * n, -1);\\\",\\n\\t\\t  \\\"    cout << \\\\\\\"Case \\\\\\\" << ++nc <<\\\\\\\": \\\\\\\";\\\",\\n\\t\\t  \\\"    if (two_sat(val)) {\\\",\\n\\t\\t  \\\"      cout << \\\\\\\"Yes\\\\\\\" << endl;\\\",\\n\\t\\t  \\\"      vector<int> sol;\\\",\\n\\t\\t  \\\"      for (int i = 0; i < 2 * n; ++i)\\\",\\n\\t\\t  \\\"        if (i % 2 == 0 and val[i] == 1)\\\",\\n\\t\\t  \\\"          sol.push_back(i / 2 + 1);\\\",\\n\\t\\t  \\\"      cout << sol.size() ;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"      for (int i = 0; i < sol.size(); ++i) {\\\",\\n\\t\\t  \\\"        cout << \\\\\\\" \\\\\\\" << sol[i];\\\",\\n\\t\\t  \\\"      }\\\",\\n\\t\\t  \\\"      cout << endl;\\\",\\n\\t\\t  \\\"    } else {\\\",\\n\\t\\t  \\\"      cout << \\\\\\\"No\\\\\\\" << endl;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"  }\\\",\\n\\t\\t  \\\"  return 0;\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"two-sat (kosaraju)\\\"\\n\\t},\\n\\t\\\"pq\\\": {\\n\\t\\t\\\"prefix\\\": \\\"pq\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"priority_queue<int> pq;\\\",\\n\\t\\t  \\\"priority_queue<int, vector<int>, greater<>> pq;\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"pq\\\"\\n\\t},\\n\\t\\\"explanation_binsearch\\\": {\\n\\t\\t\\\"prefix\\\": \\\"explanation_binsearch\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"int lo = 0, hi = n-1; // see constraints for lo and hi, nahi mil rahe toh just take 0 and 1e18\\\",\\n\\t\\t  \\\"while(hi-lo>1) {\\\",\\n\\t\\t  \\\"    int mid = lo + ((hi-lo) >> 1); // to avoid overflows\\\",\\n\\t\\t  \\\"    // lo will become the last index that satisfies X condition\\\",\\n\\t\\t  \\\"    // hi is the first element that doesn't satisfy X condition\\\",\\n\\t\\t  \\\"    // lower_bound = < \\\",\\n\\t\\t  \\\"    // upper_bound = <=\\\",\\n\\t\\t  \\\"    // upper using lower = lo, < + ek for loop to traverse the same till upper is obtained\\\",\\n\\t\\t  \\\"        \\\",\\n\\t\\t  \\\"    // essence -> \\\",\\n\\t\\t  \\\"    // remember, lo ke left mai condition always true, lo last one jispe true\\\",\\n\\t\\t  \\\"    // hi ke right mai condition always false, hi first one jispe false\\\",\\n\\t\\t  \\\"    // hi will probably be the answer in most cases\\\",\\n\\t\\t  \\\"    // hi+1, lo, lo-1 are also potential answers (maybe, mujhe toh bas lo and hi mile aaj tak)\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    // always make condition such that when it's true, left segment is eliminated as potential answer container\\\",\\n\\t\\t  \\\"    // if condition true toh bas right segment mai search hoga, left eliminated\\\",\\n\\t\\t  \\\"    auto check = [&](ll mid) {\\\",\\n\\t\\t  \\\"        // this is where majority is what you wanna write happens\\\",\\n\\t\\t  \\\"      return (/*condition here*/);\\\",\\n\\t\\t  \\\"    };\\\",\\n\\t\\t  \\\"    if(check(mid)){\\\",\\n\\t\\t  \\\"        // do stuff here\\\",\\n\\t\\t  \\\"        lo = mid;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    else {\\\",\\n\\t\\t  \\\"        hi = mid;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"explanation_binsearch\\\"\\n\\t},\\n\\t\\\"binsearch\\\": {\\n\\t\\t\\\"prefix\\\": \\\"binsearch\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"int lo = 0, hi = n-1;\\\",\\n\\t\\t  \\\"while(hi-lo>1) {\\\",\\n\\t\\t  \\\"    int mid = lo + ((hi-lo) >> 1);\\\",\\n\\t\\t  \\\"    // if condition true toh bas right segment mai search hoga, left eliminated\\\",\\n\\t\\t  \\\"    auto check = [&](ll mid) {\\\",\\n\\t\\t  \\\"      return (/*condition here*/);\\\",\\n\\t\\t  \\\"    };\\\",\\n\\t\\t  \\\"    if(check(mid)){\\\",\\n\\t\\t  \\\"        // do stuff here\\\",\\n\\t\\t  \\\"        lo = mid;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    else {\\\",\\n\\t\\t  \\\"        hi = mid;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"binsearch\\\"\\n\\t},\\n\\t\\\"lambda_function\\\": {\\n\\t\\t\\\"prefix\\\": \\\"lambda_function\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"auto check = [&](ll mid) {\\\",\\n\\t\\t  \\\"  return mid - (mid / n) >= k;\\\",\\n\\t\\t  \\\"};\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"lambda_function\\\"\\n\\t},\\n\\t\\\"fac\\\": {\\n\\t\\t\\\"prefix\\\": \\\"fac\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"int fac[maxn];\\\",\\n\\t\\t  \\\"int inv[maxn];\\\",\\n\\t\\t  \\\"fac[1] = inv[1] = 1;\\\",\\n\\t\\t  \\\"for (int i=2; i<maxn; i++){\\\",\\n\\t\\t  \\\"  fac[i] = (fac[i-1] * i)%mod;\\\",\\n\\t\\t  \\\"  inv[i] = power(fac[i], mod - 2);\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"fac\\\"\\n\\t},\\n\\t\\\"combination\\\": {\\n\\t\\t\\\"prefix\\\": \\\"combination\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"int C(int n, int r){\\\",\\n\\t\\t  \\\"    int v = (fac[n] * inv[r])%mod;\\\",\\n\\t\\t  \\\"    v = (v * inv[n-r])%mod;\\\",\\n\\t\\t  \\\"    \\\",\\n\\t\\t  \\\"    return v;\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"combination\\\"\\n\\t},\\n\\t\\\"combination-non-mod\\\": {\\n\\t\\t\\\"prefix\\\": \\\"combination-non-mod\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"vector<vector<int>> dp(n+1, vector<int> (k+1));\\\",\\n\\t\\t  \\\"int binomalCoeff(int n, int k){\\\",\\n\\t\\t  \\\"    for (int i=0; i<=n; i++){\\\",\\n\\t\\t  \\\"        for (int j=0; j<=k; j++){\\\",\\n\\t\\t  \\\"             if (!j || j == i) dp[i][j] = 1;\\\",\\n\\t\\t  \\\"             // binomial coefficient approach\\\",\\n\\t\\t  \\\"             else dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\\\",\\n\\t\\t  \\\"         }\\\",\\n\\t\\t  \\\"     }\\\",\\n\\t\\t  \\\"     return dp[n][k];\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"combination-non-mod\\\"\\n\\t},\\n\\t\\\"factorization\\\": {\\n\\t\\t\\\"prefix\\\": \\\"factorization\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"void printFactors(int n) { \\\",\\n\\t\\t  \\\"    for (int i=1; i * i<=n; i++){} \\\",\\n\\t\\t  \\\"        if (n%i == 0) { \\\",\\n\\t\\t  \\\"            if (n/i == i) cout << i << \\\\\\\" \\\\\\\"; \\\",\\n\\t\\t  \\\"            else cout << i << \\\\\\\" \\\\\\\" << n/i << \\\\\\\" \\\\\\\"; \\\",\\n\\t\\t  \\\"        } \\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    cout << \\\\\\\"\\\\\\\\n\\\\\\\";\\\",\\n\\t\\t  \\\"} \\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void printPrimeFactors(int n){\\\",\\n\\t\\t  \\\" set<int> f;\\\",\\n\\t\\t  \\\" for (int i = 2; i*i <= n; i++){\\\",\\n\\t\\t  \\\"     while (n % i == 0){\\\",\\n\\t\\t  \\\"         f.insert(i);\\\",\\n\\t\\t  \\\"         n /= i;\\\",\\n\\t\\t  \\\"      }\\\",\\n\\t\\t  \\\" }\\\",\\n\\t\\t  \\\" for (auto &i : f){\\\",\\n\\t\\t  \\\"     cout << i << \\\\\\\" \\\\\\\";\\\",\\n\\t\\t  \\\" }\\\",\\n\\t\\t  \\\" cout << \\\\\\\"\\\\\\\\n\\\\\\\";\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"factorization\\\"\\n\\t},\\n\\t\\\"DSU\\\": {\\n\\t\\t\\\"prefix\\\": \\\"DSU\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"class DSU {\\\",\\n\\t\\t  \\\"private:\\\",\\n\\t\\t  \\\"    vector<int> parent, size;\\\",\\n\\t\\t  \\\"public:\\\",\\n\\t\\t  \\\"    DSU(int n) {\\\",\\n\\t\\t  \\\"        parent = vector<int>(n);\\\",\\n\\t\\t  \\\"        size = vector<int>(n, 1);\\\",\\n\\t\\t  \\\"        iota(begin(parent), end(parent), 0);\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    \\\",\\n\\t\\t  \\\"    int getParent(int x) {\\\",\\n\\t\\t  \\\"        if (parent[x] == x) return x;\\\",\\n\\t\\t  \\\"        return parent[x] = getParent(parent[x]);\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    void join(int x, int y) {\\\",\\n\\t\\t  \\\"        x = getParent(x);\\\",\\n\\t\\t  \\\"        y = getParent(y);\\\",\\n\\t\\t  \\\"        if (size[x] > size[y])\\\",\\n\\t\\t  \\\"            swap(x, y);\\\",\\n\\t\\t  \\\"        if (x == y) return;\\\",\\n\\t\\t  \\\"        parent[x] = y;\\\",\\n\\t\\t  \\\"        size[y] += size[x];\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    int getSize(int x) {\\\",\\n\\t\\t  \\\"        return size[x] = size[getParent(x)];\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"};\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"DSU\\\"\\n\\t},\\n\\t\\\"kruskal\\\": {\\n\\t\\t\\\"prefix\\\": \\\"kruskal\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"auto kruskalMST(vector<Edge> &edges, int V){\\\",\\n\\t\\t  \\\"    int cost = 0;\\\",\\n\\t\\t  \\\"    DSU dsu(V);\\\",\\n\\t\\t  \\\"    sort(begin(edges), end(edges));\\\",\\n\\t\\t  \\\"    vector<Edge> tree;\\\",\\n\\t\\t  \\\"    for (const auto &[u, v, w] : edges){\\\",\\n\\t\\t  \\\"        if (dsu.getParent(u) != dsu.getParent(v)) {\\\",\\n\\t\\t  \\\"            cost += w;\\\",\\n\\t\\t  \\\"            tree.emplace_back(u, v, w);\\\",\\n\\t\\t  \\\"            dsu.join(u, v);\\\",\\n\\t\\t  \\\"        }\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    return make_pair(tree, cost);\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"kruskal\\\"\\n\\t},\\n\\t\\\"kosaraju\\\": {\\n\\t\\t\\\"prefix\\\": \\\"kosaraju\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"class Graph {\\\",\\n\\t\\t  \\\" int V;\\\",\\n\\t\\t  \\\" vector<int> *adj;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\" void fillOrder(int v, bool visited[], stack<int> &s);\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\" void dfsUtil(int v, bool visited[]);\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"public:\\\",\\n\\t\\t  \\\" Graph(int V) : V(V)\\\",\\n\\t\\t  \\\" {\\\",\\n\\t\\t  \\\"   adj = new vector<int>[V];\\\",\\n\\t\\t  \\\" }\\\",\\n\\t\\t  \\\" ~Graph()\\\",\\n\\t\\t  \\\" {\\\",\\n\\t\\t  \\\"    delete[] adj;\\\",\\n\\t\\t  \\\" }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\" void addEdge(int v, int w);\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\" void printSCCs();\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\" Graph getTranspose();\\\",\\n\\t\\t  \\\"};\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void Graph::dfsUtil(int v, bool visited[]) {\\\",\\n\\t\\t  \\\" visited[v] = true;\\\",\\n\\t\\t  \\\" cout << v <<  \\\\\\\" \\\\\\\";\\\",\\n\\t\\t  \\\" for (auto &it : adj[v])\\\",\\n\\t\\t  \\\"     if (!visited[it])\\\",\\n\\t\\t  \\\"        dfsUtil(it, visited);\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"Graph Graph::getTranspose() {\\\",\\n\\t\\t  \\\" Graph g(V);\\\",\\n\\t\\t  \\\" for (int i = 0; i < V; i++) {\\\",\\n\\t\\t  \\\"     for (auto &it : adj[i])\\\",\\n\\t\\t  \\\"         g.adj[it].push_back(i);\\\",\\n\\t\\t  \\\" }\\\",\\n\\t\\t  \\\" return g;\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void Graph::addEdge(int v, int w) {\\\",\\n\\t\\t  \\\" adj[v].push_back(w);\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void Graph::fillOrder(int v, bool visited[], stack<int> &s) {\\\",\\n\\t\\t  \\\" visited[v] = true;\\\",\\n\\t\\t  \\\" for (auto &it : adj[v])\\\",\\n\\t\\t  \\\"     if (!visited[it])\\\",\\n\\t\\t  \\\"         fillOrder(it, visited, s);\\\",\\n\\t\\t  \\\" s.push(v);\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void Graph::printSCCs() {\\\",\\n\\t\\t  \\\" stack<int> s;\\\",\\n\\t\\t  \\\" bool visited[V] = {0};\\\",\\n\\t\\t  \\\" for (int i = 0; i < V; i++)\\\",\\n\\t\\t  \\\"      if (!visited[i])\\\",\\n\\t\\t  \\\"        fillOrder(i, visited, s);\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\" Graph gr = getTranspose();\\\",\\n\\t\\t  \\\" for (int i = 0; i < V; i++)\\\",\\n\\t\\t  \\\"     visited[i] = false;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\" while (!s.empty()) {\\\",\\n\\t\\t  \\\"     int v = s.top();\\\",\\n\\t\\t  \\\"     s.pop();\\\",\\n\\t\\t  \\\"     if (!visited[v]){\\\",\\n\\t\\t  \\\"        gr.dfsUtil(v, visited);\\\",\\n\\t\\t  \\\"        cout << \\\\\\\"\\\\\\\\n\\\\\\\";\\\",\\n\\t\\t  \\\"     }\\\",\\n\\t\\t  \\\" }\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"kosaraju\\\"\\n\\t},\\n\\t\\\"LCA path satisfying some condition\\\": {\\n\\t\\t\\\"prefix\\\": \\\"lca\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"constexpr int N = 5; // No. of vertices\\\",\\n\\t\\t  \\\"constexpr int L = 4; // ceil(logN / log2) + 1\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"// Vertices from 1 to N.\\\",\\n\\t\\t  \\\"vector<int> adj[N + 1];\\\",\\n\\t\\t  \\\"int up[N + 1][L];\\\",\\n\\t\\t  \\\"int level[N + 1];\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void dfs(int u, int prev = 0){\\\",\\n\\t\\t  \\\" up[u][0] = prev;\\\",\\n\\t\\t  \\\" for (auto &v : adj[u]){\\\",\\n\\t\\t  \\\"     if (v == prev) continue;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"     level[v] = level[u] + 1;\\\",\\n\\t\\t  \\\"     dfs(v, u);\\\",\\n\\t\\t  \\\" }\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void binaryLift(){\\\",\\n\\t\\t  \\\" dfs(1);\\\",\\n\\t\\t  \\\" for (int i = 1; i < L; i++)\\\",\\n\\t\\t  \\\"     for (int j = 1; j <= N; j++)\\\",\\n\\t\\t  \\\"          up[j][i] = up[up[j][i - 1]][i - 1];\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"int LCA(int a, int b){\\\",\\n\\t\\t  \\\" if (level[a] > level[b])\\\",\\n\\t\\t  \\\"     swap(a, b);\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\" int diff = level[b] - level[a];\\\",\\n\\t\\t  \\\" for (int i = 0; i < L; i++){\\\",\\n\\t\\t  \\\"     if ((diff & (1 << i)))\\\",\\n\\t\\t  \\\"         b = up[b][i];\\\",\\n\\t\\t  \\\" }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\" if (a == b) return a;\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\" for (int i = L - 1; i >= 0; i--){\\\",\\n\\t\\t  \\\"     if (up[a][i] != up[b][i]){\\\",\\n\\t\\t  \\\"         a = up[a][i];\\\",\\n\\t\\t  \\\"         b = up[b][i];\\\",\\n\\t\\t  \\\"     }\\\",\\n\\t\\t  \\\" }\\\",\\n\\t\\t  \\\" return up[a][0];\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"void addEdge(int u, int v){\\\",\\n\\t\\t  \\\" adj[u].push_back(v);\\\",\\n\\t\\t  \\\" adj[v].push_back(u);\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"int dist(int a, int b){\\\",\\n\\t\\t  \\\" return level[a] + level[b] - 2 * level[LCA(a, b)];\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"LCA path satisfying some condition\\\"\\n\\t},\\n\\t\\\"combination-small\\\": {\\n\\t\\t\\\"prefix\\\": \\\"combination-small\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"int C(int n,int r){\\\",\\n\\t\\t  \\\"    r = min(r,n-r);\\\",\\n\\t\\t  \\\"    int ans = 1;\\\",\\n\\t\\t  \\\"    for(int i=1;i<=r;i++,n--){\\\",\\n\\t\\t  \\\"        ans *=n;\\\",\\n\\t\\t  \\\"        ans/=i;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    return ans;\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"combination-small\\\"\\n\\t},\\n\\t\\\"arr-inp\\\": {\\n\\t\\t\\\"prefix\\\": \\\"arr-inp\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"vector<int> a(n, 0);\\\",\\n\\t\\t  \\\"for(int i=0;i<n;i++) cin>>a[i];\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"arr-inp\\\"\\n\\t},\\n\\t\\\"arr-pref\\\": {\\n\\t\\t\\\"prefix\\\": \\\"arr-pref\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"vector<int> pre(n, 0);\\\",\\n\\t\\t  \\\"for(int i=1;i<n;i++) pre[i]=a[i]+pref[i-1]; \\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"arr-pref\\\"\\n\\t},\\n\\t\\\"recur-modpow\\\": {\\n\\t\\t\\\"prefix\\\": \\\"recur-modpow\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"int power(int x, int y){\\\",\\n\\t\\t  \\\"    if (y==0) return 1;\\\",\\n\\t\\t  \\\"    \\\",\\n\\t\\t  \\\"    int v = power(x, y/2);\\\",\\n\\t\\t  \\\"    v *= v;\\\",\\n\\t\\t  \\\"    v %= mod;\\\",\\n\\t\\t  \\\"    if (y&1) return (v*x)%mod;\\\",\\n\\t\\t  \\\"    else return v;\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"recur-modpow\\\"\\n\\t},\\n\\t\\\"binpow\\\": {\\n\\t\\t\\\"prefix\\\": \\\"binpow\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"ll binpow(ll x, ll y){\\\",\\n\\t\\t  \\\"    ll res = 1;\\\",\\n\\t\\t  \\\"    while (y>0){\\\",\\n\\t\\t  \\\"        if (y&1) res = (ll)(res*x);\\\",\\n\\t\\t  \\\"        y = y>>1;\\\",\\n\\t\\t  \\\"        x = (ll)(x*x);\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    return res;\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"binpow\\\"\\n\\t},\\n\\t\\\"modpow\\\": {\\n\\t\\t\\\"prefix\\\": \\\"modpow\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"ll modpow(ll a, ll b){\\\",\\n\\t\\t  \\\"    a %= m;\\\",\\n\\t\\t  \\\"    ll res = 1;\\\",\\n\\t\\t  \\\"    while (b > 0) {\\\",\\n\\t\\t  \\\"        if (b & 1) res = res * a % m;\\\",\\n\\t\\t  \\\"        a=a*a%m;\\\",\\n\\t\\t  \\\"        b>>=1;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    return res;\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"modpow\\\"\\n\\t},\\n\\t\\\"mint\\\": {\\n\\t\\t\\\"prefix\\\": \\\"mint\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"struct mi {\\\",\\n\\t\\t  \\\"    int64_t v; explicit operator int64_t() const { return v % mod; }\\\",\\n\\t\\t  \\\"    mi() { v = 0; }\\\",\\n\\t\\t  \\\"    mi(int64_t _v) {\\\",\\n\\t\\t  \\\"        v = (-mod < _v && _v < mod) ? _v : _v % mod;\\\",\\n\\t\\t  \\\"        if (v < 0) v += mod;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    friend bool operator==(const mi& a, const mi& b) {\\\",\\n\\t\\t  \\\"        return a.v == b.v; }\\\",\\n\\t\\t  \\\"    friend bool operator!=(const mi& a, const mi& b) {\\\",\\n\\t\\t  \\\"        return !(a == b); }\\\",\\n\\t\\t  \\\"    friend bool operator<(const mi& a, const mi& b) {\\\",\\n\\t\\t  \\\"        return a.v < b.v; }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    mi& operator+=(const mi& m) {\\\",\\n\\t\\t  \\\"        if ((v += m.v) >= mod) v -= mod;\\\",\\n\\t\\t  \\\"        return *this; }\\\",\\n\\t\\t  \\\"    mi& operator-=(const mi& m) {\\\",\\n\\t\\t  \\\"        if ((v -= m.v) < 0) v += mod;\\\",\\n\\t\\t  \\\"        return *this; }\\\",\\n\\t\\t  \\\"    mi& operator*=(const mi& m) {\\\",\\n\\t\\t  \\\"        v = v*m.v%mod; return *this; }\\\",\\n\\t\\t  \\\"    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\\\",\\n\\t\\t  \\\"    friend mi pow(mi a, int64_t p) {\\\",\\n\\t\\t  \\\"        mi ans = 1; assert(p >= 0);\\\",\\n\\t\\t  \\\"        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\\\",\\n\\t\\t  \\\"        return ans;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    friend mi inv(const mi& a) { assert(a.v != 0);\\\",\\n\\t\\t  \\\"        return pow(a,mod-2); }\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"    mi operator-() const { return mi(-v); }\\\",\\n\\t\\t  \\\"    mi& operator++() { return *this += 1; }\\\",\\n\\t\\t  \\\"    mi& operator--() { return *this -= 1; }\\\",\\n\\t\\t  \\\"    mi operator++(int32_t) { mi temp; temp.v = v++; return temp; }\\\",\\n\\t\\t  \\\"    mi operator--(int32_t) { mi temp; temp.v = v--; return temp; }\\\",\\n\\t\\t  \\\"    friend mi operator+(mi a, const mi& b) { return a += b; }\\\",\\n\\t\\t  \\\"    friend mi operator-(mi a, const mi& b) { return a -= b; }\\\",\\n\\t\\t  \\\"    friend mi operator*(mi a, const mi& b) { return a *= b; }\\\",\\n\\t\\t  \\\"    friend mi operator/(mi a, const mi& b) { return a /= b; }\\\",\\n\\t\\t  \\\"    friend ostream& operator<<(ostream& os, const mi& m) {\\\",\\n\\t\\t  \\\"        os << m.v; return os;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    friend istream& operator>>(istream& is, mi& m) {\\\",\\n\\t\\t  \\\"        int64_t x; is >> x;\\\",\\n\\t\\t  \\\"        m.v = x;\\\",\\n\\t\\t  \\\"        return is;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    friend void __print(const mi &x) {\\\",\\n\\t\\t  \\\"        cerr << x.v;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"};\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"modular integer\\\"\\n\\t  },\\n\\t  \\\"seive\\\": {\\n\\t\\t\\\"prefix\\\": \\\"seive\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"vector<bool> Prime;\\\",\\n\\t\\t  \\\"vector<int> spf;\\\",\\n\\t\\t  \\\"void sieve(int s = maxn) {\\\",\\n\\t\\t  \\\"    Prime.resize(s + 1, 1);\\\",\\n\\t\\t  \\\"    spf.resize(s + 1, s + 1);\\\",\\n\\t\\t  \\\"    for(int i = 2 ; i <= s ; i++)   if(Prime[i]) {\\\",\\n\\t\\t  \\\"        spf[i] = min(spf[i], i);\\\",\\n\\t\\t  \\\"        for(int j = i ; (ll)j * i <= s ; j++)\\\",\\n\\t\\t  \\\"            Prime[j * i] = 0, spf[j * i] = min(i, spf[j * i]);\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"seive\\\"\\n\\t},\\n\\t\\\"derangments\\\": {\\n\\t\\t\\\"prefix\\\": \\\"derangments\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"int countDerangements(int n){\\\",\\n\\t\\t  \\\"    int dp[n + 1];\\\",\\n\\t\\t  \\\"    if (n < 3) return (dp[n]=(n % 2)?1:0);\\\",\\n\\t\\t  \\\"    dp[0] = 1, dp[1] = 0, dp[2] = 1;\\\",\\n\\t\\t  \\\"    for (int i=3; i< n; i++) dp[i] = (i-1)*(dp[i-1]+dp[i-2]);\\\",\\n\\t\\t  \\\"    return dp[n];\\\",\\n\\t\\t  \\\"}\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"derangments\\\"\\n\\t},\\n\\t\\\"euclid\\\": {\\n\\t\\t\\\"prefix\\\": \\\"euclid\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"int euclid_gcd(int a, int b){\\\",\\n\\t\\t  \\\"    if (b==0) return a;\\\",\\n\\t\\t  \\\"    return gcd(b, a % b);\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"int euclid_gcdExtended(int a, int b, int *x, int *y){\\\",\\n\\t\\t  \\\"    if (a == 0){\\\",\\n\\t\\t  \\\"        *x = 0;\\\",\\n\\t\\t  \\\"        *y = 1;\\\",\\n\\t\\t  \\\"        return b;\\\",\\n\\t\\t  \\\"    }\\\",\\n\\t\\t  \\\"    int x1, y1;\\\",\\n\\t\\t  \\\"    int gcd = gcdExtended(b % a, a, &x1, &y1);\\\",\\n\\t\\t  \\\"    *x = y1 - (b / a) * x1;\\\",\\n\\t\\t  \\\"    *y = x1;\\\",\\n\\t\\t  \\\"    return gcd;\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"euclid\\\"\\n\\t},\\n\\t\\\"easy_seive\\\": {\\n\\t\\t\\\"prefix\\\": \\\"easy_seive\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"void ez_seive(int n){\\\",\\n\\t\\t  \\\"     vector<bool> prime(n,1);\\\",\\n\\t\\t  \\\"     for (int p = 2; p*p <= n; p++){\\\",\\n\\t\\t  \\\"         if (prime[p]){\\\",\\n\\t\\t  \\\"            for (int i = p * p; i <= n; i += p) prime[i] = false;\\\",\\n\\t\\t  \\\"         }\\\",\\n\\t\\t  \\\"     }\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"for (int p = 2; p <= n; p++){\\\",\\n\\t\\t  \\\"      // do whatever you want with those primes${1}\\\",\\n\\t\\t  \\\"      if (prime[p]) cout << p << \\\\\\\" \\\\\\\";\\\",\\n\\t\\t  \\\"}\\\",\\n\\t\\t  \\\"\\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"easy_seive\\\"\\n\\t},\\n\\t\\\"troll\\\": {\\n\\t\\t\\\"prefix\\\": \\\"troll\\\",\\n\\t\\t\\\"body\\\": [\\n\\t\\t  \\\"// Assembly Generator: gcc -S -o temp.s fileName.cpp\\\",\\n\\t\\t  \\\"// Executable: gcc -o temp.exe fileName.cpp\\\",\\n\\t\\t  \\\"#define assembler(x) __asm__(R\\\\\\\"(x)\\\\\\\");\\\",\\n\\t\\t  \\\"// real source - \\\"\\n\\t\\t],\\n\\t\\t\\\"description\\\": \\\"troll\\\"\\n\\t}\\n}\"}"}}