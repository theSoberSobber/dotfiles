"use strict";(self.webpackChunkipfs_companion=self.webpackChunkipfs_companion||[]).push([[384],{13939:(e,t,r)=>{r.d(t,{Ue:()=>fl});var n={};r.r(n),r.d(n,{identity:()=>G});var a={};r.r(a),r.d(a,{identity:()=>ae});var s={};r.r(s),r.d(s,{base2:()=>se});var i={};r.r(i),r.d(i,{base8:()=>ie});var o={};r.r(o),r.d(o,{base10:()=>oe});var c={};r.r(c),r.d(c,{base16:()=>ce,base16upper:()=>de});var d={};r.r(d),r.d(d,{base32:()=>le,base32hex:()=>fe,base32hexpad:()=>ge,base32hexpadupper:()=>ye,base32hexupper:()=>we,base32pad:()=>ue,base32padupper:()=>pe,base32upper:()=>he,base32z:()=>me});var l={};r.r(l),r.d(l,{base36:()=>be,base36upper:()=>_e});var h={};r.r(h),r.d(h,{base58btc:()=>ve,base58flickr:()=>Ee});var u={};r.r(u),r.d(u,{base64:()=>ke,base64pad:()=>Re,base64url:()=>Ae,base64urlpad:()=>Ie});var p={};r.r(p),r.d(p,{base256emoji:()=>Pe});var f={};r.r(f),r.d(f,{sha256:()=>Ce,sha512:()=>ze});var w={};r.r(w),r.d(w,{code:()=>Ue,decode:()=>je,encode:()=>$e,name:()=>Oe});var g={};r.r(g),r.d(g,{code:()=>Ve,decode:()=>Fe,encode:()=>He,name:()=>Ze});var y=r(40726),m=r(106),b=r(38461),_=r(32114),v=r(92754),E=r(10539),k=r(34219),R=r(66258),A=r(46392);new Uint8Array(0);const I=e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")};var x=function e(t,r,n){r=r||[];var a=n=n||0;for(;t>=S;)r[n++]=255&t|128,t/=128;for(;-128&t;)r[n++]=255&t|128,t>>>=7;return r[n]=0|t,e.bytes=n-a+1,r},S=Math.pow(2,31);var N=function e(t,r){var n,a=0,s=0,i=r=r||0,o=t.length;do{if(i>=o)throw e.bytes=0,new RangeError("Could not decode varint");n=t[i++],a+=s<28?(127&n)<<s:(127&n)*Math.pow(2,s),s+=7}while(n>=128);return e.bytes=i-r,a};var P=Math.pow(2,7),D=Math.pow(2,14),T=Math.pow(2,21),L=Math.pow(2,28),C=Math.pow(2,35),z=Math.pow(2,42),O=Math.pow(2,49),U=Math.pow(2,56),$=Math.pow(2,63);const j={encode:x,decode:N,encodingLength:function(e){return e<P?1:e<D?2:e<T?3:e<L?4:e<C?5:e<z?6:e<O?7:e<U?8:e<$?9:10}},M=(e,t=0)=>[j.decode(e,t),j.decode.bytes],B=(e,t,r=0)=>(j.encode(e,t,r),t),Z=e=>j.encodingLength(e),V=(e,t)=>{const r=t.byteLength,n=Z(e),a=n+Z(r),s=new Uint8Array(a+r);return B(e,s,0),B(r,s,n),s.set(t,a),new F(e,r,t,s)},H=e=>{const t=I(e),[r,n]=M(t),[a,s]=M(t.subarray(n)),i=t.subarray(n+s);if(i.byteLength!==a)throw new Error("Incorrect length");return new F(r,a,i,t)};class F{constructor(e,t,r,n){this.code=e,this.size=t,this.digest=r,this.bytes=n}}const K=I,G={code:0,name:"identity",encode:K,digest:e=>V(0,K(e))};var W=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var a=0;a<e.length;a++){var s=e.charAt(a),i=s.charCodeAt(0);if(255!==r[i])throw new TypeError(s+" is ambiguous");r[i]=a}var o=e.length,c=e.charAt(0),d=Math.log(o)/Math.log(256),l=Math.log(256)/Math.log(o);function h(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var n=0,a=0;e[t]===c;)n++,t++;for(var s=(e.length-t)*d+1>>>0,i=new Uint8Array(s);e[t];){var l=r[e.charCodeAt(t)];if(255===l)return;for(var h=0,u=s-1;(0!==l||h<a)&&-1!==u;u--,h++)l+=o*i[u]>>>0,i[u]=l%256>>>0,l=l/256>>>0;if(0!==l)throw new Error("Non-zero carry");a=h,t++}if(" "!==e[t]){for(var p=s-a;p!==s&&0===i[p];)p++;for(var f=new Uint8Array(n+(s-p)),w=n;p!==s;)f[w++]=i[p++];return f}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,a=0,s=t.length;a!==s&&0===t[a];)a++,r++;for(var i=(s-a)*l+1>>>0,d=new Uint8Array(i);a!==s;){for(var h=t[a],u=0,p=i-1;(0!==h||u<n)&&-1!==p;p--,u++)h+=256*d[p]>>>0,d[p]=h%o>>>0,h=h/o>>>0;if(0!==h)throw new Error("Non-zero carry");n=u,a++}for(var f=i-n;f!==i&&0===d[f];)f++;for(var w=c.repeat(r);f<i;++f)w+=e.charAt(d[f]);return w},decodeUnsafe:h,decode:function(e){var r=h(e);if(r)return r;throw new Error(`Non-${t} character`)}}};const q=W;class Y{constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class X{constructor(e,t,r){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=r}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return Q(this,e)}}class J{constructor(e){this.decoders=e}or(e){return Q(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Q=(e,t)=>new J({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class ee{constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new Y(e,t,r),this.decoder=new X(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const te=({name:e,prefix:t,encode:r,decode:n})=>new ee(e,t,r,n),re=({prefix:e,name:t,alphabet:r})=>{const{encode:n,decode:a}=q(r,t);return te({prefix:e,name:t,encode:n,decode:e=>I(a(e))})},ne=({name:e,prefix:t,bitsPerChar:r,alphabet:n})=>te({prefix:t,name:e,encode:e=>((e,t,r)=>{const n="="===t[t.length-1],a=(1<<r)-1;let s="",i=0,o=0;for(let n=0;n<e.length;++n)for(o=o<<8|e[n],i+=8;i>r;)i-=r,s+=t[a&o>>i];if(i&&(s+=t[a&o<<r-i]),n)for(;s.length*r&7;)s+="=";return s})(e,n,r),decode:t=>((e,t,r,n)=>{const a={};for(let e=0;e<t.length;++e)a[t[e]]=e;let s=e.length;for(;"="===e[s-1];)--s;const i=new Uint8Array(s*r/8|0);let o=0,c=0,d=0;for(let t=0;t<s;++t){const s=a[e[t]];if(void 0===s)throw new SyntaxError(`Non-${n} character`);c=c<<r|s,o+=r,o>=8&&(o-=8,i[d++]=255&c>>o)}if(o>=r||255&c<<8-o)throw new SyntaxError("Unexpected end of data");return i})(t,n,r,e)}),ae=te({prefix:"\0",name:"identity",encode:e=>{return t=e,(new TextDecoder).decode(t);var t},decode:e=>(e=>(new TextEncoder).encode(e))(e)}),se=ne({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),ie=ne({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),oe=re({prefix:"9",name:"base10",alphabet:"0123456789"}),ce=ne({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),de=ne({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),le=ne({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),he=ne({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ue=ne({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),pe=ne({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),fe=ne({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),we=ne({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ge=ne({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ye=ne({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),me=ne({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),be=re({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),_e=re({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),ve=re({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Ee=re({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),ke=ne({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Re=ne({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Ae=ne({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Ie=ne({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),xe=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Se=xe.reduce(((e,t,r)=>(e[r]=t,e)),[]),Ne=xe.reduce(((e,t,r)=>(e[t.codePointAt(0)]=r,e)),[]);const Pe=te({prefix:"ðŸš€",name:"base256emoji",encode:function(e){return e.reduce(((e,t)=>e+=Se[t]),"")},decode:function(e){const t=[];for(const r of e){const e=Ne[r.codePointAt(0)];if(void 0===e)throw new Error(`Non-base256emoji character: ${r}`);t.push(e)}return new Uint8Array(t)}}),De=({name:e,code:t,encode:r})=>new Te(e,t,r);class Te{constructor(e,t,r){this.name=e,this.code=t,this.encode=r}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?V(this.code,t):t.then((e=>V(this.code,e)))}throw Error("Unknown type, must be binary type")}}const Le=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),Ce=De({name:"sha2-256",code:18,encode:Le("SHA-256")}),ze=De({name:"sha2-512",code:19,encode:Le("SHA-512")}),Oe="raw",Ue=85,$e=e=>I(e),je=e=>I(e),Me=new TextEncoder,Be=new TextDecoder,Ze="json",Ve=512,He=e=>Me.encode(JSON.stringify(e)),Fe=e=>JSON.parse(Be.decode(e)),Ke=new WeakMap,Ge=e=>{const t=Ke.get(e);if(null==t){const t=new Map;return Ke.set(e,t),t}return t};class We{constructor(e,t,r,n){this.code=t,this.version=e,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Je)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Qe)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return We.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=V(e,t);return We.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return We.equals(this,e)}static equals(e,t){const r=t;return r&&e.code===r.code&&e.version===r.version&&((e,t)=>{if(e===t)return!0;{const r=t;return e.code===r.code&&e.size===r.size&&r.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0})(e.bytes,r.bytes)}})(e.multihash,r.multihash)}toString(e){return((e,t)=>{const{bytes:r,version:n}=e;return 0===n?Ye(r,Ge(e),t||ve.encoder):Xe(r,Ge(e),t||le.encoder)})(this,e)}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof We)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:r,multihash:n,bytes:a}=t;return new We(e,r,n,a||et(e,r,n.bytes))}if(!0===t[tt]){const{version:e,multihash:r,code:n}=t,a=H(r);return We.create(e,n,a)}return null}static create(e,t,r){if("number"!=typeof t)throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==Je)throw new Error(`Version 0 CID must use dag-pb (code: ${Je}) block encoding`);return new We(e,t,r,r.bytes);case 1:{const n=et(e,t,r.bytes);return new We(e,t,r,n)}default:throw new Error("Invalid version")}}static createV0(e){return We.create(0,Je,e)}static createV1(e,t){return We.create(1,e,t)}static decode(e){const[t,r]=We.decodeFirst(e);if(r.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=We.inspectBytes(e),r=t.size-t.multihashSize,n=I(e.subarray(r,r+t.multihashSize));if(n.byteLength!==t.multihashSize)throw new Error("Incorrect length");const a=n.subarray(t.multihashSize-t.digestSize),s=new F(t.multihashCode,t.digestSize,a,n);return[0===t.version?We.createV0(s):We.createV1(t.codec,s),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[r,n]=M(e.subarray(t));return t+=n,r};let n=r(),a=Je;if(18===n?(n=0,t=0):a=r(),0!==n&&1!==n)throw new RangeError(`Invalid CID version ${n}`);const s=t,i=r(),o=r(),c=t+o;return{version:n,codec:a,multihashCode:i,digestSize:o,multihashSize:c-s,size:c}}static parse(e,t){const[r,n]=qe(e,t),a=We.decode(n);return Ge(a).set(r,e),a}}const qe=(e,t)=>{switch(e[0]){case"Q":{const r=t||ve;return[ve.prefix,r.decode(`${ve.prefix}${e}`)]}case ve.prefix:{const r=t||ve;return[ve.prefix,r.decode(e)]}case le.prefix:{const r=t||le;return[le.prefix,r.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},Ye=(e,t,r)=>{const{prefix:n}=r;if(n!==ve.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const a=t.get(n);if(null==a){const a=r.encode(e).slice(1);return t.set(n,a),a}return a},Xe=(e,t,r)=>{const{prefix:n}=r,a=t.get(n);if(null==a){const a=r.encode(e);return t.set(n,a),a}return a},Je=112,Qe=18,et=(e,t,r)=>{const n=Z(e),a=n+Z(t),s=new Uint8Array(a+r.byteLength);return B(e,s,0),B(t,s,n),s.set(r,a),s},tt=Symbol.for("@ipld/js-cid/CID"),rt={...a,...s,...i,...o,...c,...d,...l,...h,...u,...p},nt={...f,...n},at={raw:w,json:g};var st=r(49260);class it extends Error{constructor(e="not initialized"){super(e),this.name="NotInitializedError",this.code=it.code}}it.code="ERR_NOT_INITIALIZED";class ot extends Error{constructor(e="cannot initialize an initializing node"){super(e),this.name="AlreadyInitializingError",this.code=ct.code}}ot.code="ERR_ALREADY_INITIALIZING";class ct extends Error{constructor(e="cannot re-initialize an initialized node"){super(e),this.name="AlreadyInitializedError",this.code=ct.code}}ct.code="ERR_ALREADY_INITIALIZED";class dt extends Error{constructor(e="not started"){super(e),this.name="NotStartedError",this.code=dt.code}}dt.code="ERR_NOT_STARTED";class lt extends Error{constructor(e="cannot start, already startin"){super(e),this.name="AlreadyStartingError",this.code=lt.code}}lt.code="ERR_ALREADY_STARTING";class ht extends Error{constructor(e="cannot start, already started"){super(e),this.name="AlreadyStartedError",this.code=ht.code}}ht.code="ERR_ALREADY_STARTED";class ut extends Error{constructor(e="not enabled"){super(e),this.name="NotEnabledError",this.code=ut.code}}function pt(e){return null!=globalThis.Buffer?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e}function ft(e=0){return null!=globalThis.Buffer?.allocUnsafe?pt(globalThis.Buffer.allocUnsafe(e)):new Uint8Array(e)}function wt(e,t,r,n){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:r},decoder:{decode:n}}}ut.code="ERR_NOT_ENABLED";const gt=wt("utf8","u",(e=>"u"+new TextDecoder("utf8").decode(e)),(e=>(new TextEncoder).encode(e.substring(1)))),yt=wt("ascii","a",(e=>{let t="a";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t}),(e=>{const t=ft((e=e.substring(1)).length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t})),mt={utf8:gt,"utf-8":gt,hex:rt.base16,latin1:yt,ascii:yt,binary:yt,...rt};function bt(e,t="utf8"){const r=mt[t];if(null==r)throw new Error(`Unsupported encoding "${t}"`);return"utf8"!==t&&"utf-8"!==t||null==globalThis.Buffer||null==globalThis.Buffer.from?r.decoder.decode(`${r.prefix}${e}`):pt(globalThis.Buffer.from(e,"utf-8"))}var _t=r(10715),vt=r(94306),Et=r(76237),kt=r(17745);function Rt(e,t="utf8"){const r=mt[t];if(null==r)throw new Error(`Unsupported encoding "${t}"`);return"utf8"!==t&&"utf-8"!==t||null==globalThis.Buffer||null==globalThis.Buffer.from?r.encoder.encode(e).substring(1):globalThis.Buffer.from(e.buffer,e.byteOffset,e.byteLength).toString("utf8")}const At=/^\/(ip[fn]s)\/([^/?#]+)/,It=/^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/,xt=/^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;function St(e){try{return Dt(e)?Boolean(We.parse(e)):e instanceof Uint8Array?Boolean(We.decode(e)):Boolean(We.asCID(e))}catch{return!1}}function Nt(e,t,r=1,n=2){const a=Tt(e);if(!1===a)return!1;const s=a.match(t);if(null==s)return!1;if("ipfs"!==s[r])return!1;let i=s[n];return null!=i&&t===It&&(i=i.toLowerCase()),St(i)}function Pt(e,t,r=1,n=2){const a=Tt(e);if(!1===a)return!1;const s=a.match(t);if(null==s)return!1;if("ipns"!==s[r])return!1;let i=s[n];if(null!=i&&t===It){if(i=i.toLowerCase(),St(i))return!0;try{!i.includes(".")&&i.includes("-")&&(i=i.replace(/--/g,"@").replace(/-/g,".").replace(/@/g,"-"));const{hostname:e}=new kt.URL(`http://${i}`);return xt.test(e)}catch(e){return!1}}return!0}function Dt(e){return"string"==typeof e}function Tt(e){return e instanceof Uint8Array?Rt(e,"base58btc"):!!Dt(e)&&e}const Lt=e=>Nt(e,At)||Pt(e,At),Ct=e=>Pt(e,At);var zt=r(42837),Ot=r(45847),Ut=r(41966);const $t="This command must be run in online mode. Try running 'ipfs daemon' first.",jt=new zt.s("/local/filesroot"),Mt=262144,Bt=e=>e instanceof Uint8Array?We.decode(e).toString():(0===(e=e.toString()).indexOf("/ipfs/")&&(e=e.substring("/ipfs/".length)),"/"===e.charAt(e.length-1)&&(e=e.substring(0,e.length-1)),e),Zt=async function(e,t,r,n={}){const{cid:a,path:s}=(0,Ut.B)(r);s&&(n.path=s);let i=a,o=n.path||"";if(o.startsWith("/")&&(o=o.substring(1)),n.path)try{for await(const{value:r,remainderPath:s}of Ft(a,n.path,t,e,{signal:n.signal})){if(!We.asCID(r))break;o=s,i=r}}catch(e){throw e.message.startsWith("Object has no property")&&(e.message=`no link named "${o.split("/")[0]}" under ${i}`,e.code="ERR_NO_LINK"),e}return{cid:i,remainderPath:o||""}},Vt=e=>{if("file"!==e.type&&"directory"!==e.type&&"raw"!==e.type)throw new Error(`Unknown node type '${e.type}'`);const t={cid:e.cid,path:e.path,name:e.name,size:e.size,type:"file"};return"directory"===e.type&&(t.type="dir"),"file"===e.type&&(t.size=e.unixfs.fileSize()),"file"!==e.type&&"directory"!==e.type||(t.mode=e.unixfs.mode,void 0!==e.unixfs.mtime&&(t.mtime=e.unixfs.mtime)),t},Ht=(0,Ot.a)((async(e,t)=>await e)),Ft=async function*(e,t,r,n,a){const s=async e=>{const t=await r.getCodec(e.code),s=await n.blocks.get(e,a);return t.decode(s)},i=t.split("/").filter(Boolean);let o=await s(e),c=e;for(;i.length;){const r=i.shift();if(!r)throw _(new Error(`Could not resolve path "${t}"`),"ERR_INVALID_PATH");if(e.code===E.code&&Array.isArray(o.Links)){const e=o.Links.find((e=>e.Name===r));if(e){yield{value:e.Hash,remainderPath:i.join("/")},o=await s(e.Hash),c=e.Hash;continue}}if(!Object.prototype.hasOwnProperty.call(o,r))throw _(new Error(`no link named "${r}" under ${c}`),"ERR_NO_LINK");o=o[r],yield{value:o,remainderPath:i.join("/")},We.asCID(o)&&(c=o,o=await s(o))}yield{value:o,remainderPath:""}};class Kt{static create({start:e,stop:t}){return new Kt(e,t)}static async start(e,t){const{state:r,activate:n}=e;switch(r.status){case"stopped":try{const r=n(t);e.state={status:"starting",ready:r};const a=await r;return e.state={status:"started",value:a},a}catch(t){throw e.state={status:"stopped"},t}case"starting":throw new lt;case"started":throw new ht;case"stopping":return await r.ready,await Kt.start(e,t);default:return Kt.panic(e)}}static async stop(e){const{state:t,deactivate:r}=e;switch(t.status){case"stopped":break;case"starting":try{await t.ready}catch(e){}return await Kt.stop(e);case"stopping":return await t.ready;case"started":r&&await r(t.value),e.state={status:"stopped"};break;default:Kt.panic(t)}}static try({state:e}){return"started"===e.status?e.value:null}static async use({state:e},t){switch(e.status){case"started":return e.value;case"starting":return await Ht(e.ready,t);default:throw new dt}}static panic({state:e}){const t=JSON.stringify({status:e.status});throw RangeError(`Service in invalid state ${t}, should never happen if you see this please report a bug`)}constructor(e,t){this.activate=e,this.deactivate=t,this.state={status:"stopped"}}async use(e){return await Kt.use(this,e)}try(){return Kt.try(this)}}var Gt=r(1325);var Wt=r(93203);function qt({repo:e,codecs:t,bases:r,name:n}){return(0,Ot.a)((async function(a,s={}){if(!Lt(a))throw new Error("invalid argument "+a);if(Ct(a))for await(const e of n.resolve(a,s))a=e;const[,i,o,...c]=a.split("/"),d=s.cidBase?await r.getBase(s.cidBase):void 0,l=function(e){try{return(0,Wt.jE)(e).toBytes()}catch{return We.parse(e).bytes}}(o);if(0===c.length){return`/${i}/${d?d.encoder.encode(l):o}`}const h=We.decode(l);a=c.join("/");const u=Ft(h,a,t,e,s);let p=h,f=a;for await(const e of u)We.asCID(e.value)&&(p=e.value,f=e.remainderPath);return`/ipfs/${p.toString(d&&d.encoder)}${f?"/"+f:""}`}))}var Yt=r(68883);var Xt=r(73297),Jt=r(69044);function Qt(e,t,r){const n={type:e,cid:t};return r&&(n.metadata=r),n}class er{constructor({codecs:e,repo:t}){const r=function({repo:e,codecs:t}){return(0,Ot.a)((async function*(r,n={}){const a=async function*(){for await(const{path:n,recursive:a,metadata:s}of(0,Xt.f)(r)){const{cid:r}=await Zt(e,t,n),{reason:i}=await e.pins.isPinnedWithType(r,[Jt.R.recursive,Jt.R.direct]);if("recursive"===i&&!a)throw new Error(`${r} already pinned recursively`);a?await e.pins.pinRecursively(r,{metadata:s}):await e.pins.pinDirectly(r,{metadata:s}),yield r}};if(!Boolean(n.lock))return void(yield*a());const s=await e.gcLock.readLock();try{yield*a()}finally{s()}}))}({codecs:e,repo:t});this.addAll=r,this.add=function({addAll:e}){return(t,r={})=>{let n;const a=We.asCID(t);return n=e(a?[{cid:a,...r}]:[{path:t.toString(),...r}],r),(0,Yt.Z)(n)}}({addAll:r});const n=function({repo:e,codecs:t}){return(0,Ot.a)((async function*(r,n={}){const a=await e.gcLock.readLock();try{for await(const{path:n,recursive:a}of(0,Xt.f)(r)){const{cid:r}=await Zt(e,t,n),{pinned:s,reason:i}=await e.pins.isPinnedWithType(r,Jt.R.all);if(!s)throw new Error(`${r} is not pinned`);switch(i){case Jt.R.recursive:if(!a)throw new Error(`${r} is pinned recursively`);await e.pins.unpin(r),yield r;break;case Jt.R.direct:await e.pins.unpin(r),yield r;break;default:throw new Error(`${r} is pinned indirectly under ${i}`)}}}finally{a()}}))}({codecs:e,repo:t});this.rmAll=n,this.rm=function({rmAll:e}){return async function(t,r={}){const n=await(0,Yt.Z)(e([{path:t,...r}],r));if(!n)throw new Error("CID expected");return n}}({rmAll:n}),this.ls=function({repo:e,codecs:t}){return(0,Ot.a)((async function*(r={}){let n=Jt.R.all;if(r.type&&(n=r.type,!Object.keys(Jt.R).includes(n)))throw _(new Error("Invalid pin type"),"ERR_INVALID_PIN_TYPE");if(r.paths){let a=!1;for await(const{path:s}of(0,Xt.f)(r.paths)){const{cid:r}=await Zt(e,t,s),{reason:i,pinned:o,parent:c,metadata:d}=await e.pins.isPinnedWithType(r,n);if(!o)throw _(new Error(`path '${s}' is not pinned`),"ERR_NOT_PINNED");switch(i){case Jt.R.direct:case Jt.R.recursive:a=!0,yield Qt(i,r,d);break;default:a=!0,yield Qt(`${Jt.R.indirect} through ${c}`,r,d)}}if(!a)throw new Error("No match found")}else{if(n===Jt.R.recursive||n===Jt.R.all)for await(const{cid:t,metadata:r}of e.pins.recursiveKeys())yield Qt(Jt.R.recursive,t,r);if(n===Jt.R.indirect||n===Jt.R.all)for await(const t of e.pins.indirectKeys(r))yield Qt(Jt.R.indirect,t);if(n===Jt.R.direct||n===Jt.R.all)for await(const{cid:t,metadata:r}of e.pins.directKeys())yield Qt(Jt.R.direct,t,r)}}))}({codecs:e,repo:t}),this.remote={add:(e,t={})=>Promise.reject(new Error("Not implemented")),ls:async function*(e,t={}){return Promise.reject(new Error("Not implemented"))},rm:(e,t={})=>Promise.reject(new Error("Not implemented")),rmAll:(e,t={})=>Promise.reject(new Error("Not implemented")),service:{add:(e,t)=>Promise.reject(new Error("Not implemented")),rm:(e,t={})=>Promise.reject(new Error("Not implemented")),ls:(e={})=>Promise.reject(new Error("Not implemented"))}}}}var tr=r(682),rr=r(40668);var nr=r(39233);const ar=(0,b.kg)("ipfs:ipns:publisher"),sr=(0,rr.notFoundError)().code,ir=36e5;class or{constructor(e,t){this._routing=e,this._datastore=t}async publishWithEOL(e,t,r,n){const a=await this._updateOrCreateRecord(e,t,r,n);return this._putRecordToRouting(a,e,n)}publish(e,t,r){return this.publishWithEOL(e,t,ir,r)}async _putRecordToRouting(e,t,r){if(!(0,tr.I)(t)){const e="peerId received is not valid";throw ar.error(e),_(new Error(e),"ERR_INVALID_PEER_ID")}if(null==t.publicKey)throw _(new Error("Public key was missing"),"ERR_MISSING_PUBLIC_KEY");const n=nr.fy(t);return await this._publishEntry(n,e,r),e}async _publishEntry(e,t,r){try{const n=await this._routing.put(e,t,r);return ar(`ipns record for ${Rt(e,"base32")} was stored in the routing`),n}catch(t){const r=`ipns record for ${Rt(e,"base32")} could not be stored in the routing - ${t.stack}`;throw ar.error(r),ar.error(t),_(new Error(r),"ERR_PUTTING_TO_ROUTING")}}async _getPublished(e,t={}){if(!(0,tr.I)(e)){const e="peerId received is not valid";throw ar.error(e),_(new Error(e),"ERR_INVALID_PEER_ID")}const r=!1!==t.checkRouting;try{const t=await this._datastore.get(nr._M(e.toBytes()));return this._unmarshalData(t)}catch(t){if(t.code!==sr){const t=`unexpected error getting the ipns record ${e.toString()} from datastore`;throw ar.error(t),_(new Error(t),"ERR_UNEXPECTED_DATASTORE_RESPONSE")}if(!r)throw _(t,"ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");try{const t=nr.fy(e),r=await this._routing.get(t);return this._unmarshalData(r)}catch(e){throw ar.error(e),e}}}_unmarshalData(e){try{return nr.md(e)}catch(e){throw _(e,"ERR_INVALID_RECORD_DATA")}}async _updateOrCreateRecord(e,t,r,n){if(!(0,tr.I)(e)){const e="peerId received is not valid";throw ar.error(e),_(new Error(e),"ERR_INVALID_PEER_ID")}const a={checkRouting:!0};let s;try{s=await this._getPublished(e,a)}catch(t){if(t.code!==sr){const r=`unexpected error when determining the last published IPNS record for ${e.toString()} ${t.stack}`;throw ar.error(r),_(new Error(r),"ERR_DETERMINING_PUBLISHED_RECORD")}}let i,o=0n;s&&void 0!==s.sequence&&(o=function(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0}(s.value,t)?s.sequence:s.sequence+BigInt(1));try{i=await nr.Ue(e,t,o,r)}catch(e){const r=`ipns record for ${t} could not be created`;throw ar.error(e),_(new Error(r),"ERR_CREATING_IPNS_RECORD")}try{const r=nr.ef(i);return await this._datastore.put(nr._M(e.toBytes()),r,n),ar(`ipns record for ${Rt(t,"base32")} was stored in the datastore`),r}catch(e){const r=`ipns record for ${t} could not be stored in the datastore`;throw ar.error(r),_(new Error(r),"ERR_STORING_IN_DATASTORE")}}}or.defaultRecordLifetime=ir;var cr=r(51988);const dr=(0,b.kg)("ipfs:ipns:republisher");class lr{constructor(e,t,r,n,a={pass:""}){this._publisher=e,this._datastore=t,this._peerId=r,this._keychain=n,this._options=a,this._republishHandle=null}async start(){if(this._republishHandle)throw _(new Error("republisher is already running"),"ERR_REPUBLISH_ALREADY_RUNNING");const e={_task:null,_inflightTask:null,_timeoutId:null,runPeriodically:t=>{e._timeoutId=setTimeout((async()=>{e._timeoutId=null;try{e._inflightTask=e._task(),await e._inflightTask,e._task&&e.runPeriodically(t)}catch(e){dr.error(e)}}),t())},cancel:async()=>{null!=e._timeoutId&&clearTimeout(e._timeoutId),e._task=null,await e._inflightTask}},{pass:t}=this._options;let r=!0;e._task=async()=>{const e=new _t.TimeoutController(3e4);try{await this._republishEntries(this._peerId,t,{signal:e.signal})}finally{e.clear()}},e.runPeriodically((()=>r?(r=!1,this._options.initialBroadcastInterval||6e4):this._options.broadcastInterval||144e5)),this._republishHandle=e}async stop(){const e=this._republishHandle;if(!e)throw _(new Error("republisher is not running"),"ERR_REPUBLISH_NOT_RUNNING");this._republishHandle=null,await e.cancel()}async _republishEntries(e,t,r){try{await this._republishEntry(e,r)}catch(e){const t="cannot republish entry for the node's private key";return void dr.error(t)}if(t)try{const e=await this._keychain.listKeys();for(const n of e){if("self"===n.name)continue;const e=await this._keychain.exportKey(n.name,t),a=await(0,cr.importKey)(e,t),s=await(0,Wt.y5)(a.public.bytes,a.bytes);await this._republishEntry(s,r)}}catch(e){dr.error(e)}}async _republishEntry(e,t){try{const r=await this._getPreviousValue(e);await this._publisher.publishWithEOL(e,r,864e5,t)}catch(e){if("ERR_NO_ENTRY_FOUND"===e.code)return;throw e}}async _getPreviousValue(e){if(!(0,tr.I)(e))throw _(new Error("invalid peer ID"),"ERR_INVALID_PEER_ID");try{const t=await this._datastore.get(nr._M(e.toBytes()));if(!(t instanceof Uint8Array))throw _(new Error("found ipns record that we couldn't process"),"ERR_INVALID_IPNS_RECORD");try{return nr.md(t).value}catch(e){throw dr.error(e),_(new Error("found ipns record that we couldn't convert to a value"),"ERR_INVALID_IPNS_RECORD")}}catch(t){if(t&&t.notFound)throw _(new Error(`no previous entry for record with id: ${e.toString()}`),"ERR_NO_ENTRY_FOUND");throw t}}}function hr(e,t){null==t&&(t=e.reduce(((e,t)=>e+t.length),0));const r=ft(t);let n=0;for(const t of e)r.set(t,n),n+=t.length;return pt(r)}var ur=r(60);const pr=(0,b.kg)("ipfs:ipns:resolver"),fr=rr.notFoundError().code;class wr{constructor(e){this._routing=e}async resolve(e,t={}){if("string"!=typeof e)throw _(new Error("invalid name"),"ERR_INVALID_NAME");const r=t.recursive&&"true"===t.recursive.toString(),n=e.split("/");if(3!==n.length||""!==n[0])throw _(new Error("invalid name"),"ERR_INVALID_NAME");const a=n[2];let s=1/0;r&&(s=32);const i=await this.resolver(a,s,t);return pr(`${e} was locally resolved correctly`),i}async resolver(e,t,r){if(0===t){const e="could not resolve name (recursion limit of 32 exceeded)";throw pr.error(e),_(new Error(e),"ERR_RESOLVE_RECURSION_LIMIT")}const n=await this._resolveName(e,r),a=n.split("/");return"ipfs"!==a[1]&&t?this.resolver(a[2],t-1,r):n}async _resolveName(e,t){const r=(0,Wt.jE)(e),n=nr.fy(r);let a;try{a=await this._routing.get(n,t)}catch(t){if(pr.error("could not get record from routing",t),t.code===fr)throw _(new Error(`record requested for ${e} was not found in the network`),"ERR_NO_RECORD_FOUND");throw _(new Error(`unexpected error getting the ipns record ${r.toString()}`),"ERR_UNEXPECTED_ERROR_GETTING_RECORD")}return this._validateRecord(r,a)}async _validateRecord(e,t){await(0,ur.A)(hr([bt("/ipns/"),e.toBytes()]),t);return Rt(nr.md(t).value)}}var gr=r(70248);class yr{constructor(e){this.lru=gr(e)}get(e){const t=this.lru.get(e);if(t)return t.expire&&t.expire<Date.now()?void this.lru.remove(e):t.value}set(e,t,r){this.lru.set(e,{value:t,expire:Date.now()+r})}has(e){return!!this.get(e)}remove(e){this.lru.remove(e)}clear(){this.lru.clear()}}const mr=(0,b.kg)("ipfs:ipns");class br{constructor(e,t,r,n,a){this.publisher=new or(e,t),this.republisher=new lr(this.publisher,t,r,n,a),this.resolver=new wr(e),this.cache=new yr(1e3),this.routing=e}async publish(e,t,r=or.defaultRecordLifetime,n){try{await this.publisher.publishWithEOL(e,t,r,n),mr(`IPNS value ${Rt(t,"base32")} was published correctly`);const a=e.toString(),s=parseFloat(r),i=s<6e4?s:6e4;return this.cache.set(a,t,i),mr(`IPNS value ${Rt(t,"base32")} was cached correctly`),{name:a,value:t}}catch(e){throw mr.error(e),e}}async resolve(e,t={}){if("string"!=typeof e)throw _(new Error("name received is not valid"),"ERR_INVALID_NAME");if(!t.nocache&&!t.recursive){const t=e.split("/")[2],r=this.cache.get(t);if(r)return r}try{const r=await this.resolver.resolve(e,t);return mr(`IPNS record from ${e} was resolved correctly`),r}catch(e){throw mr.error(e),e}}async initializeKeyspace(e,t,r){return this.publish(e,t,or.defaultRecordLifetime,r)}}var _r=r(97947),vr=r(26905),Er=r(95738),kr=r(26091);const Rr=(0,b.kg)("ipfs:ipns:pubsub");class Ar{constructor(e,t,r){this._subscriptions={},this._handleSubscriptionKey=this._handleSubscriptionKey.bind(this),this._pubsubDs=new kr.R(e,t,r,ur.A,Er.e,this._handleSubscriptionKey)}async put(e,t,r){try{await this._pubsubDs.put(e,t,r)}catch(e){throw Rr.error(e),e}}async get(e,t){let r,n;try{r=await this._pubsubDs.get(e,t)}catch(e){n=e}if(Rt(e.slice(0,nr.iR))===nr.uD){const t=ve.encode(e).substring(1),r=ve.encode(e.slice(nr.iR)).substring(1);this._subscriptions[t]=r,Rr(`subscribed to pubsub topic ${t}, id ${r}`)}if(n)throw n;return r}_handleSubscriptionKey(e){e instanceof Uint8Array&&(e=Rt(e,"base58btc"));const t=this._subscriptions[e];if(!t)throw _(new Error(`key ${e} does not correspond to a subscription`),"ERR_INVALID_KEY");try{return(0,nr.fy)((0,Wt.jE)(t))}catch(e){throw Rr.error(e),e}}getSubscriptions(){return Object.values(this._subscriptions).filter(Boolean).map((e=>`${nr.uD}${e}`))}async cancel(e){if("string"!=typeof e)throw _(new Error("invalid subscription name"),"ERR_INVALID_SUBSCRIPTION_NAME");e.startsWith(nr.uD)&&(e=e.substring(nr.iR));const t=Object.keys(this._subscriptions).find((t=>this._subscriptions[t]===e));if(!t)return{canceled:!1};const r=bt(t);return this._pubsubDs.unsubscribe(r),delete this._subscriptions[t],Rr(`unsubscribed pubsub ${t}: ${e}`),{canceled:!0}}}var Ir=r(21177);const xr=(0,b.kg)("ipfs:ipns:offline-datastore");class Sr{constructor(e){this._datastore=e,this.stores=[]}async put(e,t,r){if(!(e instanceof Uint8Array))throw _(new Error("Offline datastore key must be a Uint8Array"),"ERR_INVALID_KEY");if(!(t instanceof Uint8Array))throw _(new Error("Offline datastore value must be a Uint8Array"),"ERR_INVALID_VALUE");let n;try{n=this._routingKey(e)}catch(e){throw xr.error(e),_(new Error("Not possible to generate the routing key"),"ERR_GENERATING_ROUTING_KEY")}const a=new Ir.Y(e,t,new Date);await this._datastore.put(n,a.serialize(),r)}async get(e,t){if(!(e instanceof Uint8Array))throw _(new Error("Offline datastore key must be a Uint8Array"),"ERR_INVALID_KEY");let r;try{r=this._routingKey(e)}catch(e){throw xr.error(e),_(new Error("Not possible to generate the routing key"),"ERR_GENERATING_ROUTING_KEY")}const n=await this._datastore.get(r,t);let a;try{a=Ir.Y.deserialize(n)}catch(e){throw xr.error(e),e}return a.value}_routingKey(e){return new zt.s("/dht/record/"+Rt(e,"base32"),!1)}}var Nr=r(93361);const Pr=(0,b.kg)("ipfs:ipns:dht-datastore");class Dr{constructor(e){this._dht=e}async put(e,t,r){try{await(0,Nr.Z)(this._dht.put(e,t,r))}catch(e){throw Pr.error(e),e}}async get(e,t){for await(const r of this._dht.get(e,t))if("VALUE"===r.name)return r.value;throw(0,rr.notFoundError)()}}const Tr=(0,b.kg)("ipfs:components:ipns");class Lr{constructor(e={pass:""}){this.options=e,this.offline=null,this.online=null}getIPNS(){const e=this.online||this.offline;if(e)return e;throw new it}get routing(){return this.getIPNS().routing}startOffline({repo:e,peerId:t,keychain:r}){if(null!=this.offline)throw new ct;Tr("initializing IPNS keyspace (offline)");const n=new Sr(e.datastore),a=new br(n,e.datastore,t,r,this.options);this.offline=a}async startOnline({libp2p:e,repo:t,peerId:r,keychain:n}){if(null!=this.online)throw new ct;const a=function({libp2p:e,repo:t,peerId:r,options:n}){const a=[];let s;if(vr(n,"EXPERIMENTAL.ipnsPubsub",!1)&&(s=new Ar(e.pubsub,t.datastore,r),a.push(s)),!0!==vr(n,"offline",!1)&&["dht","dhtclient","dhtserver"].includes(vr(n,"config.Routing.Type","none"))&&a.push(new Dr(e.dht)),vr(n,"offline",!1)||0===a.length){const e=new Sr(t.datastore);a.push(e)}return new _r.z(a)}({libp2p:e,repo:t,peerId:r,options:this.options}),s=new br(a,t.datastore,r,n,this.options);await s.republisher.start(),this.online=s}async stop(){const e=this.online;e&&(await e.republisher.stop(),this.online=null)}publish(e,t,r,n){return this.getIPNS().publish(e,t,r,n)}resolve(e,t){return this.getIPNS().resolve(e,t)}initializeKeyspace(e,t,r){return this.getIPNS().initializeKeyspace(e,t,r)}}var Cr=r(92816);async function zr({ipns:e,repo:t,codecs:r},n,a){if(Ct(n))return e.resolve(n);const{cid:s,path:i}=(0,Ut.B)(n);await(0,Nr.Z)(Ft(s,i||"",r,t,a))}const Or=(0,b.kg)("ipfs:name:publish");function Ur({ipns:e,repo:t,codecs:r,peerId:n,isOnline:a,keychain:s}){const i=async e=>{let t;if("self"===e&&null!=n.privateKey)t=await(0,cr.unmarshalPrivateKey)(n.privateKey);else try{const r=await s.exportKey(e,"temp");t=await(0,cr.importKey)(r,"temp")}catch(e){throw Or.error(e),_(e,"ERR_CANNOT_GET_KEY")}return(0,Wt.y5)(t.public.bytes,t.bytes)};return(0,Ot.a)((async function(n,s={}){const o=!(!1===s.resolve),c=s.lifetime||"24h",d=s.key||"self";if(!a())throw _(new Error($t),"OFFLINE_ERROR");try{n=(e=>{if(We.asCID(e))return`/ipfs/${e}`;const t=e.toString();try{return`/ipfs/${We.parse(t)}`}catch{}if(Lt(t))return t;throw _(new Error(`invalid path: ${e}`),"ERR_BAD_PATH")})(n)}catch(e){throw Or.error(e),e}let l=0;try{l=(0,Cr.Z)(c)||0,l=parseFloat(l.toFixed(6))}catch(e){throw Or.error(e),e}const h=await Promise.all([i(d),o?zr({ipns:e,repo:t,codecs:r},n):Promise.resolve()]),u=bt(n),p=await e.publish(h[0],u,l,s);return{name:p.name,value:Rt(p.value)}}))}var $r=r(82734);const jr=y.Z.bind({ignoreUndefined:!0}),Mr=(0,b.kg)("ipfs:name:resolve"),Br=(e,t)=>t.length>0?e+"/"+t.join("/"):e;function Zr(e,t){if(!e||!t||!t.ipnsPubsub)throw _(new Error("IPNS pubsub subsystem is not enabled"),"ERR_IPNS_PUBSUB_NOT_ENABLED");if(e.routing instanceof Ar)return e.routing;const r=(e.routing.stores||[]).find((e=>e instanceof Ar));if(!r)throw _(new Error("IPNS pubsub datastore not found"),"ERR_PUBSUB_DATASTORE_NOT_FOUND");return r}class Vr{constructor({ipns:e,options:t}){this.cancel=function({ipns:e,options:t}){const r=t.EXPERIMENTAL;return(0,Ot.a)((async function(t,n={}){return Zr(e,r).cancel(t,n)}))}({ipns:e,options:t}),this.state=function({ipns:e,options:t}){const r=t.EXPERIMENTAL;return(0,Ot.a)((async function(t={}){try{return{enabled:Boolean(Zr(e,r))}}catch(e){return{enabled:!1}}}))}({ipns:e,options:t}),this.subs=function({ipns:e,options:t}){const r=t.EXPERIMENTAL;return(0,Ot.a)((async function(t={}){return Zr(e,r).getSubscriptions(t)}))}({ipns:e,options:t})}}class Hr{constructor({dns:e,ipns:t,repo:r,codecs:n,peerId:a,isOnline:s,keychain:i,options:o}){this.publish=Ur({ipns:t,repo:r,codecs:n,peerId:a,isOnline:s,keychain:i}),this.resolve=function({dns:e,ipns:t,isOnline:r,options:{offline:n}}){return(0,Ot.a)((async function*(a,s={}){if(s=jr({nocache:!1,recursive:!0},s),n&&s&&s.nocache)throw _(new Error("cannot specify both offline and nocache"),"ERR_NOCACHE_AND_OFFLINE");if(!r()&&!n)throw _(new Error($t),"OFFLINE_ERROR");let i=a.toString();i.startsWith("/ipns/")||(i=`/ipns/${i}`);let[o,c,...d]=i.slice(1).split("/");try{if("1"===c.substring(0,1)){const e=(0,Wt.jE)(c),t=H(e.toBytes());c=We.createV1(114,t).toString(be)}else{const e=We.parse(c);1===e.version&&(c=e.toString(be))}}catch(t){if($r(c))return void(yield Br(await e(c,s),d));throw Mr.error(t),_(new Error("Invalid IPNS name"),"ERR_IPNS_INVALID_NAME")}const l=await t.resolve(`/${o}/${c}`,s);yield Br(l instanceof Uint8Array?Rt(l):l,d)}))}({dns:e,ipns:t,isOnline:s,options:o}),this.pubsub=new Vr({ipns:t,options:o})}}var Fr=r(32044);const Kr=(0,rr.notFoundError)().code,Gr="<dst>",Wr="<src> -> <dst>";function qr({repo:e,codecs:t,resolve:r,preload:n}){return async function*(a,s={}){if(0===s.maxDepth)return;if(s.edges&&s.format&&s.format!==Gr)throw new Error("Cannot set edges to true and also specify format");if(s.format=s.edges?Wr:s.format,"number"!=typeof s.maxDepth&&(s.maxDepth=s.recursive?1/0:1),s.timeout){const e=[new _t.TimeoutController(s.timeout).signal];s.signal&&e.push(s.signal),s.signal=(0,Fr.anySignal)(e)}const i=(Array.isArray(a)?a:[a]).map((e=>function(e,t,r){const{cid:n,path:a}=(0,Ut.B)(t);!1!==r.preload&&e(n);return`/ipfs/${n}${a||""}`}(n,e,s)));for(const n of i)try{yield*Yr(r,e,t,n,s)}catch(e){yield{ref:"",err:e.message}}}}async function*Yr(e,t,r,n,a){const s=await e(n,a),{cid:i}=(0,Ut.B)(s),o=null!=a.maxDepth?a.maxDepth:1/0,c=a.unique||!1;for await(const e of async function*(e,t,r,n,a,s){const i=new Set;async function*o(r,c){const d=c+1;if(!(d>n))try{for await(const n of async function*(e,t,r,n){const a=await e.blocks.get(r,n),s=(await t.getCodec(r.code)).decode(a),i=r.code===E.code,o=[];for(const[e,t]of Jr(s,o)){if(i){const r=e.match(/^Links\/(\d+)\/Hash$/);if(r){const e=Number(r[1]);if(e<s.Links.length){yield{name:s.Links[e].Name,cid:t};continue}}}yield{name:e,cid:t}}}(e,t,r.cid,s))yield{parent:r,node:n,isDuplicate:a&&i.has(n.cid.toString())},a&&i.add(n.cid.toString()),yield*o(n,d)}catch(e){throw e.code===Kr&&(e.message=`Could not find object with CID: ${r.cid}`),e}}yield*o({cid:r},0)}(t,r,i,o,c,a))e.parent&&(e.isDuplicate||(yield{ref:Xr(e.parent.cid,e.node.cid,e.node.name,a.format)}))}function Xr(e,t,r="",n=Gr){let a=n.replace(/<src>/g,e.toString());return a=a.replace(/<dst>/g,t.toString()),a=a.replace(/<linkname>/g,r),a}const Jr=function*(e,t){if(null!=e&&!(e instanceof Uint8Array)){for(const[r,n]of Object.entries(e)){const e=[...t,r];if(null!=n&&"object"==typeof n)if(Array.isArray(n))for(const[t,r]of n.entries()){const n=[...e,t],a=We.asCID(r);a?yield[n.join("/"),a]:"object"==typeof r&&(yield*Jr(r,n))}else{const t=We.asCID(n);t?yield[e.join("/"),t]:yield*Jr(n,e)}}return[]}};function Qr({repo:e}){return(0,Ot.a)((async function*(t={}){for await(const r of e.blocks.queryKeys({},{signal:t.signal}))yield{ref:r.toString()}}))}function en({network:e}){return(0,Ot.a)((async function(t={}){const r=(await e.use(t)).bitswap,n=r.stat().snapshot;return{provideBufLen:parseInt(n.providesBufferLength.toString()),blocksReceived:BigInt(n.blocksReceived.toString()),wantlist:Array.from(r.getWantlist()).map((e=>e[1].cid)),peers:r.peers(),dupBlksReceived:BigInt(n.dupBlksReceived.toString()),dupDataReceived:BigInt(n.dupDataReceived.toString()),dataReceived:BigInt(n.dataReceived.toString()),blocksSent:BigInt(n.blocksSent.toString()),dataSent:BigInt(n.dataSent.toString())}}))}class tn{constructor({network:e}){this.wantlist=function({network:e}){return(0,Ot.a)((async function(t={}){const{bitswap:r}=await e.use(t),n=r.getWantlist();return Array.from(n).map((e=>e[1].cid))}))}({network:e}),this.wantlistForPeer=function({network:e}){return(0,Ot.a)((async function(t,r={}){const{bitswap:n}=await e.use(r),a=n.wantlistForPeer(t);return Array.from(a).map((e=>e[1].cid))}))}({network:e}),this.unwant=function({network:e}){return(0,Ot.a)((async function(t,r={}){const{bitswap:n}=await e.use(r);return Array.isArray(t)||(t=[t]),n.unwant(t)}))}({network:e}),this.stat=en({network:e})}}function rn(e){try{return Et.Cz.matches(e)}catch(e){return!1}}var nn=r(71115);class an{constructor({repo:e}){this.add=function({repo:e}){return(0,Ot.a)((async function(t,r={}){if(!rn(t))throw new Error(`${t} is not a valid Multiaddr`);const n=await e.config.getAll(r),a=n.Bootstrap||[];return a.push(t.toString()),n.Bootstrap=Array.from(new Set(a)).sort(((e,t)=>e.localeCompare(t))),await e.config.replace(n),{Peers:[t]}}))}({repo:e}),this.list=function({repo:e}){return(0,Ot.a)((async function(t={}){return{Peers:(await e.config.get("Bootstrap",t)||[]).map((e=>(0,vt.HM)(e)))}}))}({repo:e}),this.rm=function({repo:e}){return(0,Ot.a)((async function(t,r={}){if(!rn(t))throw new Error(`${t} is not a valid Multiaddr`);const n=await e.config.getAll(r);return n.Bootstrap=(n.Bootstrap||[]).filter((e=>e.toString()!==t.toString())),await e.config.replace(n),{Peers:[t]}}))}({repo:e}),this.clear=function({repo:e}){return(0,Ot.a)((async function(t={}){const r=await e.config.getAll(t),n=r.Bootstrap||[];return r.Bootstrap=[],await e.config.replace(r),{Peers:n.map((e=>(0,vt.HM)(e)))}}))}({repo:e}),this.reset=function({repo:e}){return(0,Ot.a)((async function(t={}){const r=await e.config.getAll(t);return r.Bootstrap=(0,nn.Z)().Bootstrap,await e.config.replace(r),{Peers:(0,nn.Z)().Bootstrap.map((e=>(0,vt.HM)(e)))}}))}({repo:e})}}var sn=r(69849),on=r(21007),cn=r(44752),dn=r(88211);function ln(e){return e instanceof Uint8Array?We.decode(e):We.parse(e.toString())}class hn{constructor({codecs:e,hashers:t,preload:r,repo:n}){this.get=function({preload:e,repo:t}){return(0,Ot.a)((async function(r,n={}){return!1!==n.preload&&e(r),t.blocks.get(r,n)}))}({preload:r,repo:n}),this.put=function({codecs:e,hashers:t,repo:r,preload:n}){return(0,Ot.a)((async function(a,s={}){const i=s.pin?await r.gcLock.readLock():null;try{const o=null!=s.version?s.version:0,c=s.format||(0===o?"dag-pb":"raw"),d=await t.getHasher(s.mhtype||"sha2-256"),l=await d.digest(a),h=await e.getCodec(c),u=We.create(o,h.code,l);return await r.blocks.put(u,a,{signal:s.signal}),!1!==s.preload&&n(u),!0===s.pin&&await r.pins.pinRecursively(u,{signal:s.signal}),u}finally{i&&i()}}))}({codecs:e,hashers:t,preload:r,repo:n}),this.rm=function({repo:e}){return(0,Ot.a)((async function*(t,r={}){Array.isArray(t)||(t=[t]);const n=await e.gcLock.writeLock();try{yield*(0,dn.zG)(t,(t=>(0,on.Z)(t,(t=>async()=>{const n={cid:t=ln(t)};try{if(!await e.blocks.has(t))throw _(new Error("block not found"),"ERR_BLOCK_NOT_FOUND");await e.blocks.delete(t)}catch(e){r.force||(e.message=`cannot remove ${t}: ${e.message}`,n.error=e)}return n}))),(e=>(0,sn.Z)(e,{concurrency:8})),(e=>(0,cn.Z)(e,(()=>!r.quiet))))}finally{n()}}))}({repo:n}),this.stat=function({repo:e,preload:t}){return(0,Ot.a)((async function(r,n={}){return r=ln(r),!1!==n.preload&&t(r),{cid:r,size:(await e.blocks.get(r)).length}}))}({preload:r,repo:n})}}var un=r(56740);var pn=r(53902),fn=r(3064);const wn=e=>{if(e){if(e.startsWith("size-")){const t=e.split("-")[1],r=parseInt(t);if(isNaN(r))throw new Error("Chunker parameter size must be an integer");return{chunker:"fixed",maxChunkSize:r}}if(e.startsWith("rabin"))return{chunker:"rabin",...gn(e)};throw new Error(`Unrecognized chunker option: ${e}`)}return{chunker:"fixed"}},gn=e=>{const t={},r=e.split("-");switch(r.length){case 1:t.avgChunkSize=262144;break;case 2:t.avgChunkSize=yn(r[1],"avg");break;case 4:t.minChunkSize=yn(r[1],"min"),t.avgChunkSize=yn(r[2],"avg"),t.maxChunkSize=yn(r[3],"max");break;default:throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"')}return t},yn=(e,t)=>{const r=parseInt(e);if(isNaN(r))throw new Error(`Chunker parameter ${t} must be an integer`);return r},mn=y.Z.bind({ignoreUndefined:!0});var bn=r(69491);var _n=r(36672);function vn(e){let t=e.length;for(;--t>=0;)e[t]=0}const En=256,kn=286,Rn=30,An=15,In=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),xn=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),Sn=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),Nn=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Pn=new Array(576);vn(Pn);const Dn=new Array(60);vn(Dn);const Tn=new Array(512);vn(Tn);const Ln=new Array(256);vn(Ln);const Cn=new Array(29);vn(Cn);const zn=new Array(Rn);function On(e,t,r,n,a){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=a,this.has_stree=e&&e.length}let Un,$n,jn;function Mn(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}vn(zn);const Bn=e=>e<256?Tn[e]:Tn[256+(e>>>7)],Zn=(e,t)=>{e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255},Vn=(e,t,r)=>{e.bi_valid>16-r?(e.bi_buf|=t<<e.bi_valid&65535,Zn(e,e.bi_buf),e.bi_buf=t>>16-e.bi_valid,e.bi_valid+=r-16):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r)},Hn=(e,t,r)=>{Vn(e,r[2*t],r[2*t+1])},Fn=(e,t)=>{let r=0;do{r|=1&e,e>>>=1,r<<=1}while(--t>0);return r>>>1},Kn=(e,t,r)=>{const n=new Array(16);let a,s,i=0;for(a=1;a<=An;a++)i=i+r[a-1]<<1,n[a]=i;for(s=0;s<=t;s++){let t=e[2*s+1];0!==t&&(e[2*s]=Fn(n[t]++,t))}},Gn=e=>{let t;for(t=0;t<kn;t++)e.dyn_ltree[2*t]=0;for(t=0;t<Rn;t++)e.dyn_dtree[2*t]=0;for(t=0;t<19;t++)e.bl_tree[2*t]=0;e.dyn_ltree[512]=1,e.opt_len=e.static_len=0,e.sym_next=e.matches=0},Wn=e=>{e.bi_valid>8?Zn(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0},qn=(e,t,r,n)=>{const a=2*t,s=2*r;return e[a]<e[s]||e[a]===e[s]&&n[t]<=n[r]},Yn=(e,t,r)=>{const n=e.heap[r];let a=r<<1;for(;a<=e.heap_len&&(a<e.heap_len&&qn(t,e.heap[a+1],e.heap[a],e.depth)&&a++,!qn(t,n,e.heap[a],e.depth));)e.heap[r]=e.heap[a],r=a,a<<=1;e.heap[r]=n},Xn=(e,t,r)=>{let n,a,s,i,o=0;if(0!==e.sym_next)do{n=255&e.pending_buf[e.sym_buf+o++],n+=(255&e.pending_buf[e.sym_buf+o++])<<8,a=e.pending_buf[e.sym_buf+o++],0===n?Hn(e,a,t):(s=Ln[a],Hn(e,s+En+1,t),i=In[s],0!==i&&(a-=Cn[s],Vn(e,a,i)),n--,s=Bn(n),Hn(e,s,r),i=xn[s],0!==i&&(n-=zn[s],Vn(e,n,i)))}while(o<e.sym_next);Hn(e,256,t)},Jn=(e,t)=>{const r=t.dyn_tree,n=t.stat_desc.static_tree,a=t.stat_desc.has_stree,s=t.stat_desc.elems;let i,o,c,d=-1;for(e.heap_len=0,e.heap_max=573,i=0;i<s;i++)0!==r[2*i]?(e.heap[++e.heap_len]=d=i,e.depth[i]=0):r[2*i+1]=0;for(;e.heap_len<2;)c=e.heap[++e.heap_len]=d<2?++d:0,r[2*c]=1,e.depth[c]=0,e.opt_len--,a&&(e.static_len-=n[2*c+1]);for(t.max_code=d,i=e.heap_len>>1;i>=1;i--)Yn(e,r,i);c=s;do{i=e.heap[1],e.heap[1]=e.heap[e.heap_len--],Yn(e,r,1),o=e.heap[1],e.heap[--e.heap_max]=i,e.heap[--e.heap_max]=o,r[2*c]=r[2*i]+r[2*o],e.depth[c]=(e.depth[i]>=e.depth[o]?e.depth[i]:e.depth[o])+1,r[2*i+1]=r[2*o+1]=c,e.heap[1]=c++,Yn(e,r,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],((e,t)=>{const r=t.dyn_tree,n=t.max_code,a=t.stat_desc.static_tree,s=t.stat_desc.has_stree,i=t.stat_desc.extra_bits,o=t.stat_desc.extra_base,c=t.stat_desc.max_length;let d,l,h,u,p,f,w=0;for(u=0;u<=An;u++)e.bl_count[u]=0;for(r[2*e.heap[e.heap_max]+1]=0,d=e.heap_max+1;d<573;d++)l=e.heap[d],u=r[2*r[2*l+1]+1]+1,u>c&&(u=c,w++),r[2*l+1]=u,l>n||(e.bl_count[u]++,p=0,l>=o&&(p=i[l-o]),f=r[2*l],e.opt_len+=f*(u+p),s&&(e.static_len+=f*(a[2*l+1]+p)));if(0!==w){do{for(u=c-1;0===e.bl_count[u];)u--;e.bl_count[u]--,e.bl_count[u+1]+=2,e.bl_count[c]--,w-=2}while(w>0);for(u=c;0!==u;u--)for(l=e.bl_count[u];0!==l;)h=e.heap[--d],h>n||(r[2*h+1]!==u&&(e.opt_len+=(u-r[2*h+1])*r[2*h],r[2*h+1]=u),l--)}})(e,t),Kn(r,d,e.bl_count)},Qn=(e,t,r)=>{let n,a,s=-1,i=t[1],o=0,c=7,d=4;for(0===i&&(c=138,d=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)a=i,i=t[2*(n+1)+1],++o<c&&a===i||(o<d?e.bl_tree[2*a]+=o:0!==a?(a!==s&&e.bl_tree[2*a]++,e.bl_tree[32]++):o<=10?e.bl_tree[34]++:e.bl_tree[36]++,o=0,s=a,0===i?(c=138,d=3):a===i?(c=6,d=3):(c=7,d=4))},ea=(e,t,r)=>{let n,a,s=-1,i=t[1],o=0,c=7,d=4;for(0===i&&(c=138,d=3),n=0;n<=r;n++)if(a=i,i=t[2*(n+1)+1],!(++o<c&&a===i)){if(o<d)do{Hn(e,a,e.bl_tree)}while(0!=--o);else 0!==a?(a!==s&&(Hn(e,a,e.bl_tree),o--),Hn(e,16,e.bl_tree),Vn(e,o-3,2)):o<=10?(Hn(e,17,e.bl_tree),Vn(e,o-3,3)):(Hn(e,18,e.bl_tree),Vn(e,o-11,7));o=0,s=a,0===i?(c=138,d=3):a===i?(c=6,d=3):(c=7,d=4)}};let ta=!1;const ra=(e,t,r,n)=>{Vn(e,0+(n?1:0),3),Wn(e),Zn(e,r),Zn(e,~r),r&&e.pending_buf.set(e.window.subarray(t,t+r),e.pending),e.pending+=r};var na=e=>{ta||((()=>{let e,t,r,n,a;const s=new Array(16);for(r=0,n=0;n<28;n++)for(Cn[n]=r,e=0;e<1<<In[n];e++)Ln[r++]=n;for(Ln[r-1]=n,a=0,n=0;n<16;n++)for(zn[n]=a,e=0;e<1<<xn[n];e++)Tn[a++]=n;for(a>>=7;n<Rn;n++)for(zn[n]=a<<7,e=0;e<1<<xn[n]-7;e++)Tn[256+a++]=n;for(t=0;t<=An;t++)s[t]=0;for(e=0;e<=143;)Pn[2*e+1]=8,e++,s[8]++;for(;e<=255;)Pn[2*e+1]=9,e++,s[9]++;for(;e<=279;)Pn[2*e+1]=7,e++,s[7]++;for(;e<=287;)Pn[2*e+1]=8,e++,s[8]++;for(Kn(Pn,287,s),e=0;e<Rn;e++)Dn[2*e+1]=5,Dn[2*e]=Fn(e,5);Un=new On(Pn,In,257,kn,An),$n=new On(Dn,xn,0,Rn,An),jn=new On(new Array(0),Sn,0,19,7)})(),ta=!0),e.l_desc=new Mn(e.dyn_ltree,Un),e.d_desc=new Mn(e.dyn_dtree,$n),e.bl_desc=new Mn(e.bl_tree,jn),e.bi_buf=0,e.bi_valid=0,Gn(e)},aa=(e,t,r,n)=>{let a,s,i=0;e.level>0?(2===e.strm.data_type&&(e.strm.data_type=(e=>{let t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return 0;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return 1;for(t=32;t<En;t++)if(0!==e.dyn_ltree[2*t])return 1;return 0})(e)),Jn(e,e.l_desc),Jn(e,e.d_desc),i=(e=>{let t;for(Qn(e,e.dyn_ltree,e.l_desc.max_code),Qn(e,e.dyn_dtree,e.d_desc.max_code),Jn(e,e.bl_desc),t=18;t>=3&&0===e.bl_tree[2*Nn[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t})(e),a=e.opt_len+3+7>>>3,s=e.static_len+3+7>>>3,s<=a&&(a=s)):a=s=r+5,r+4<=a&&-1!==t?ra(e,t,r,n):4===e.strategy||s===a?(Vn(e,2+(n?1:0),3),Xn(e,Pn,Dn)):(Vn(e,4+(n?1:0),3),((e,t,r,n)=>{let a;for(Vn(e,t-257,5),Vn(e,r-1,5),Vn(e,n-4,4),a=0;a<n;a++)Vn(e,e.bl_tree[2*Nn[a]+1],3);ea(e,e.dyn_ltree,t-1),ea(e,e.dyn_dtree,r-1)})(e,e.l_desc.max_code+1,e.d_desc.max_code+1,i+1),Xn(e,e.dyn_ltree,e.dyn_dtree)),Gn(e),n&&Wn(e)},sa={_tr_init:na,_tr_stored_block:ra,_tr_flush_block:aa,_tr_tally:(e,t,r)=>(e.pending_buf[e.sym_buf+e.sym_next++]=t,e.pending_buf[e.sym_buf+e.sym_next++]=t>>8,e.pending_buf[e.sym_buf+e.sym_next++]=r,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(Ln[r]+En+1)]++,e.dyn_dtree[2*Bn(t)]++),e.sym_next===e.sym_end),_tr_align:e=>{Vn(e,2,3),Hn(e,256,Pn),(e=>{16===e.bi_valid?(Zn(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)})(e)}};var ia=(e,t,r,n)=>{let a=65535&e|0,s=e>>>16&65535|0,i=0;for(;0!==r;){i=r>2e3?2e3:r,r-=i;do{a=a+t[n++]|0,s=s+a|0}while(--i);a%=65521,s%=65521}return a|s<<16|0};const oa=new Uint32Array((()=>{let e,t=[];for(var r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t})());var ca=(e,t,r,n)=>{const a=oa,s=n+r;e^=-1;for(let r=n;r<s;r++)e=e>>>8^a[255&(e^t[r])];return-1^e},da={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},la={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:ha,_tr_stored_block:ua,_tr_flush_block:pa,_tr_tally:fa,_tr_align:wa}=sa,{Z_NO_FLUSH:ga,Z_PARTIAL_FLUSH:ya,Z_FULL_FLUSH:ma,Z_FINISH:ba,Z_BLOCK:_a,Z_OK:va,Z_STREAM_END:Ea,Z_STREAM_ERROR:ka,Z_DATA_ERROR:Ra,Z_BUF_ERROR:Aa,Z_DEFAULT_COMPRESSION:Ia,Z_FILTERED:xa,Z_HUFFMAN_ONLY:Sa,Z_RLE:Na,Z_FIXED:Pa,Z_DEFAULT_STRATEGY:Da,Z_UNKNOWN:Ta,Z_DEFLATED:La}=la,Ca=258,za=262,Oa=42,Ua=113,$a=666,ja=(e,t)=>(e.msg=da[t],t),Ma=e=>2*e-(e>4?9:0),Ba=e=>{let t=e.length;for(;--t>=0;)e[t]=0},Za=e=>{let t,r,n,a=e.w_size;t=e.hash_size,n=t;do{r=e.head[--n],e.head[n]=r>=a?r-a:0}while(--t);t=a,n=t;do{r=e.prev[--n],e.prev[n]=r>=a?r-a:0}while(--t)};let Va=(e,t,r)=>(t<<e.hash_shift^r)&e.hash_mask;const Ha=e=>{const t=e.state;let r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(e.output.set(t.pending_buf.subarray(t.pending_out,t.pending_out+r),e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0))},Fa=(e,t)=>{pa(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,Ha(e.strm)},Ka=(e,t)=>{e.pending_buf[e.pending++]=t},Ga=(e,t)=>{e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t},Wa=(e,t,r,n)=>{let a=e.avail_in;return a>n&&(a=n),0===a?0:(e.avail_in-=a,t.set(e.input.subarray(e.next_in,e.next_in+a),r),1===e.state.wrap?e.adler=ia(e.adler,t,a,r):2===e.state.wrap&&(e.adler=ca(e.adler,t,a,r)),e.next_in+=a,e.total_in+=a,a)},qa=(e,t)=>{let r,n,a=e.max_chain_length,s=e.strstart,i=e.prev_length,o=e.nice_match;const c=e.strstart>e.w_size-za?e.strstart-(e.w_size-za):0,d=e.window,l=e.w_mask,h=e.prev,u=e.strstart+Ca;let p=d[s+i-1],f=d[s+i];e.prev_length>=e.good_match&&(a>>=2),o>e.lookahead&&(o=e.lookahead);do{if(r=t,d[r+i]===f&&d[r+i-1]===p&&d[r]===d[s]&&d[++r]===d[s+1]){s+=2,r++;do{}while(d[++s]===d[++r]&&d[++s]===d[++r]&&d[++s]===d[++r]&&d[++s]===d[++r]&&d[++s]===d[++r]&&d[++s]===d[++r]&&d[++s]===d[++r]&&d[++s]===d[++r]&&s<u);if(n=Ca-(u-s),s=u-Ca,n>i){if(e.match_start=t,i=n,n>=o)break;p=d[s+i-1],f=d[s+i]}}}while((t=h[t&l])>c&&0!=--a);return i<=e.lookahead?i:e.lookahead},Ya=e=>{const t=e.w_size;let r,n,a;do{if(n=e.window_size-e.lookahead-e.strstart,e.strstart>=t+(t-za)&&(e.window.set(e.window.subarray(t,t+t-n),0),e.match_start-=t,e.strstart-=t,e.block_start-=t,e.insert>e.strstart&&(e.insert=e.strstart),Za(e),n+=t),0===e.strm.avail_in)break;if(r=Wa(e.strm,e.window,e.strstart+e.lookahead,n),e.lookahead+=r,e.lookahead+e.insert>=3)for(a=e.strstart-e.insert,e.ins_h=e.window[a],e.ins_h=Va(e,e.ins_h,e.window[a+1]);e.insert&&(e.ins_h=Va(e,e.ins_h,e.window[a+3-1]),e.prev[a&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=a,a++,e.insert--,!(e.lookahead+e.insert<3)););}while(e.lookahead<za&&0!==e.strm.avail_in)},Xa=(e,t)=>{let r,n,a,s=e.pending_buf_size-5>e.w_size?e.w_size:e.pending_buf_size-5,i=0,o=e.strm.avail_in;do{if(r=65535,a=e.bi_valid+42>>3,e.strm.avail_out<a)break;if(a=e.strm.avail_out-a,n=e.strstart-e.block_start,r>n+e.strm.avail_in&&(r=n+e.strm.avail_in),r>a&&(r=a),r<s&&(0===r&&t!==ba||t===ga||r!==n+e.strm.avail_in))break;i=t===ba&&r===n+e.strm.avail_in?1:0,ua(e,0,0,i),e.pending_buf[e.pending-4]=r,e.pending_buf[e.pending-3]=r>>8,e.pending_buf[e.pending-2]=~r,e.pending_buf[e.pending-1]=~r>>8,Ha(e.strm),n&&(n>r&&(n=r),e.strm.output.set(e.window.subarray(e.block_start,e.block_start+n),e.strm.next_out),e.strm.next_out+=n,e.strm.avail_out-=n,e.strm.total_out+=n,e.block_start+=n,r-=n),r&&(Wa(e.strm,e.strm.output,e.strm.next_out,r),e.strm.next_out+=r,e.strm.avail_out-=r,e.strm.total_out+=r)}while(0===i);return o-=e.strm.avail_in,o&&(o>=e.w_size?(e.matches=2,e.window.set(e.strm.input.subarray(e.strm.next_in-e.w_size,e.strm.next_in),0),e.strstart=e.w_size,e.insert=e.strstart):(e.window_size-e.strstart<=o&&(e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,e.insert>e.strstart&&(e.insert=e.strstart)),e.window.set(e.strm.input.subarray(e.strm.next_in-o,e.strm.next_in),e.strstart),e.strstart+=o,e.insert+=o>e.w_size-e.insert?e.w_size-e.insert:o),e.block_start=e.strstart),e.high_water<e.strstart&&(e.high_water=e.strstart),i?4:t!==ga&&t!==ba&&0===e.strm.avail_in&&e.strstart===e.block_start?2:(a=e.window_size-e.strstart,e.strm.avail_in>a&&e.block_start>=e.w_size&&(e.block_start-=e.w_size,e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,a+=e.w_size,e.insert>e.strstart&&(e.insert=e.strstart)),a>e.strm.avail_in&&(a=e.strm.avail_in),a&&(Wa(e.strm,e.window,e.strstart,a),e.strstart+=a,e.insert+=a>e.w_size-e.insert?e.w_size-e.insert:a),e.high_water<e.strstart&&(e.high_water=e.strstart),a=e.bi_valid+42>>3,a=e.pending_buf_size-a>65535?65535:e.pending_buf_size-a,s=a>e.w_size?e.w_size:a,n=e.strstart-e.block_start,(n>=s||(n||t===ba)&&t!==ga&&0===e.strm.avail_in&&n<=a)&&(r=n>a?a:n,i=t===ba&&0===e.strm.avail_in&&r===n?1:0,ua(e,e.block_start,r,i),e.block_start+=r,Ha(e.strm)),i?3:1)},Ja=(e,t)=>{let r,n;for(;;){if(e.lookahead<za){if(Ya(e),e.lookahead<za&&t===ga)return 1;if(0===e.lookahead)break}if(r=0,e.lookahead>=3&&(e.ins_h=Va(e,e.ins_h,e.window[e.strstart+3-1]),r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-za&&(e.match_length=qa(e,r)),e.match_length>=3)if(n=fa(e,e.strstart-e.match_start,e.match_length-3),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=3){e.match_length--;do{e.strstart++,e.ins_h=Va(e,e.ins_h,e.window[e.strstart+3-1]),r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart}while(0!=--e.match_length);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=Va(e,e.ins_h,e.window[e.strstart+1]);else n=fa(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(Fa(e,!1),0===e.strm.avail_out))return 1}return e.insert=e.strstart<2?e.strstart:2,t===ba?(Fa(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(Fa(e,!1),0===e.strm.avail_out)?1:2},Qa=(e,t)=>{let r,n,a;for(;;){if(e.lookahead<za){if(Ya(e),e.lookahead<za&&t===ga)return 1;if(0===e.lookahead)break}if(r=0,e.lookahead>=3&&(e.ins_h=Va(e,e.ins_h,e.window[e.strstart+3-1]),r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=2,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-za&&(e.match_length=qa(e,r),e.match_length<=5&&(e.strategy===xa||3===e.match_length&&e.strstart-e.match_start>4096)&&(e.match_length=2)),e.prev_length>=3&&e.match_length<=e.prev_length){a=e.strstart+e.lookahead-3,n=fa(e,e.strstart-1-e.prev_match,e.prev_length-3),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=a&&(e.ins_h=Va(e,e.ins_h,e.window[e.strstart+3-1]),r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart)}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=2,e.strstart++,n&&(Fa(e,!1),0===e.strm.avail_out))return 1}else if(e.match_available){if(n=fa(e,0,e.window[e.strstart-1]),n&&Fa(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return 1}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(n=fa(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<2?e.strstart:2,t===ba?(Fa(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(Fa(e,!1),0===e.strm.avail_out)?1:2};function es(e,t,r,n,a){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=a}const ts=[new es(0,0,0,0,Xa),new es(4,4,8,4,Ja),new es(4,5,16,8,Ja),new es(4,6,32,32,Ja),new es(4,4,16,16,Qa),new es(8,16,32,32,Qa),new es(8,16,128,128,Qa),new es(8,32,128,256,Qa),new es(32,128,258,1024,Qa),new es(32,258,258,4096,Qa)];function rs(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=La,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),Ba(this.dyn_ltree),Ba(this.dyn_dtree),Ba(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),Ba(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),Ba(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const ns=e=>{if(!e)return 1;const t=e.state;return!t||t.strm!==e||t.status!==Oa&&57!==t.status&&69!==t.status&&73!==t.status&&91!==t.status&&103!==t.status&&t.status!==Ua&&t.status!==$a?1:0},as=e=>{if(ns(e))return ja(e,ka);e.total_in=e.total_out=0,e.data_type=Ta;const t=e.state;return t.pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=2===t.wrap?57:t.wrap?Oa:Ua,e.adler=2===t.wrap?0:1,t.last_flush=-2,ha(t),va},ss=e=>{const t=as(e);var r;return t===va&&((r=e.state).window_size=2*r.w_size,Ba(r.head),r.max_lazy_match=ts[r.level].max_lazy,r.good_match=ts[r.level].good_length,r.nice_match=ts[r.level].nice_length,r.max_chain_length=ts[r.level].max_chain,r.strstart=0,r.block_start=0,r.lookahead=0,r.insert=0,r.match_length=r.prev_length=2,r.match_available=0,r.ins_h=0),t},is=(e,t,r,n,a,s)=>{if(!e)return ka;let i=1;if(t===Ia&&(t=6),n<0?(i=0,n=-n):n>15&&(i=2,n-=16),a<1||a>9||r!==La||n<8||n>15||t<0||t>9||s<0||s>Pa||8===n&&1!==i)return ja(e,ka);8===n&&(n=9);const o=new rs;return e.state=o,o.strm=e,o.status=Oa,o.wrap=i,o.gzhead=null,o.w_bits=n,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=a+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+3-1)/3),o.window=new Uint8Array(2*o.w_size),o.head=new Uint16Array(o.hash_size),o.prev=new Uint16Array(o.w_size),o.lit_bufsize=1<<a+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new Uint8Array(o.pending_buf_size),o.sym_buf=o.lit_bufsize,o.sym_end=3*(o.lit_bufsize-1),o.level=t,o.strategy=s,o.method=r,ss(e)};var os=(e,t)=>{if(ns(e)||t>_a||t<0)return e?ja(e,ka):ka;const r=e.state;if(!e.output||0!==e.avail_in&&!e.input||r.status===$a&&t!==ba)return ja(e,0===e.avail_out?Aa:ka);const n=r.last_flush;if(r.last_flush=t,0!==r.pending){if(Ha(e),0===e.avail_out)return r.last_flush=-1,va}else if(0===e.avail_in&&Ma(t)<=Ma(n)&&t!==ba)return ja(e,Aa);if(r.status===$a&&0!==e.avail_in)return ja(e,Aa);if(r.status===Oa&&0===r.wrap&&(r.status=Ua),r.status===Oa){let t=La+(r.w_bits-8<<4)<<8,n=-1;if(n=r.strategy>=Sa||r.level<2?0:r.level<6?1:6===r.level?2:3,t|=n<<6,0!==r.strstart&&(t|=32),t+=31-t%31,Ga(r,t),0!==r.strstart&&(Ga(r,e.adler>>>16),Ga(r,65535&e.adler)),e.adler=1,r.status=Ua,Ha(e),0!==r.pending)return r.last_flush=-1,va}if(57===r.status)if(e.adler=0,Ka(r,31),Ka(r,139),Ka(r,8),r.gzhead)Ka(r,(r.gzhead.text?1:0)+(r.gzhead.hcrc?2:0)+(r.gzhead.extra?4:0)+(r.gzhead.name?8:0)+(r.gzhead.comment?16:0)),Ka(r,255&r.gzhead.time),Ka(r,r.gzhead.time>>8&255),Ka(r,r.gzhead.time>>16&255),Ka(r,r.gzhead.time>>24&255),Ka(r,9===r.level?2:r.strategy>=Sa||r.level<2?4:0),Ka(r,255&r.gzhead.os),r.gzhead.extra&&r.gzhead.extra.length&&(Ka(r,255&r.gzhead.extra.length),Ka(r,r.gzhead.extra.length>>8&255)),r.gzhead.hcrc&&(e.adler=ca(e.adler,r.pending_buf,r.pending,0)),r.gzindex=0,r.status=69;else if(Ka(r,0),Ka(r,0),Ka(r,0),Ka(r,0),Ka(r,0),Ka(r,9===r.level?2:r.strategy>=Sa||r.level<2?4:0),Ka(r,3),r.status=Ua,Ha(e),0!==r.pending)return r.last_flush=-1,va;if(69===r.status){if(r.gzhead.extra){let t=r.pending,n=(65535&r.gzhead.extra.length)-r.gzindex;for(;r.pending+n>r.pending_buf_size;){let a=r.pending_buf_size-r.pending;if(r.pending_buf.set(r.gzhead.extra.subarray(r.gzindex,r.gzindex+a),r.pending),r.pending=r.pending_buf_size,r.gzhead.hcrc&&r.pending>t&&(e.adler=ca(e.adler,r.pending_buf,r.pending-t,t)),r.gzindex+=a,Ha(e),0!==r.pending)return r.last_flush=-1,va;t=0,n-=a}let a=new Uint8Array(r.gzhead.extra);r.pending_buf.set(a.subarray(r.gzindex,r.gzindex+n),r.pending),r.pending+=n,r.gzhead.hcrc&&r.pending>t&&(e.adler=ca(e.adler,r.pending_buf,r.pending-t,t)),r.gzindex=0}r.status=73}if(73===r.status){if(r.gzhead.name){let t,n=r.pending;do{if(r.pending===r.pending_buf_size){if(r.gzhead.hcrc&&r.pending>n&&(e.adler=ca(e.adler,r.pending_buf,r.pending-n,n)),Ha(e),0!==r.pending)return r.last_flush=-1,va;n=0}t=r.gzindex<r.gzhead.name.length?255&r.gzhead.name.charCodeAt(r.gzindex++):0,Ka(r,t)}while(0!==t);r.gzhead.hcrc&&r.pending>n&&(e.adler=ca(e.adler,r.pending_buf,r.pending-n,n)),r.gzindex=0}r.status=91}if(91===r.status){if(r.gzhead.comment){let t,n=r.pending;do{if(r.pending===r.pending_buf_size){if(r.gzhead.hcrc&&r.pending>n&&(e.adler=ca(e.adler,r.pending_buf,r.pending-n,n)),Ha(e),0!==r.pending)return r.last_flush=-1,va;n=0}t=r.gzindex<r.gzhead.comment.length?255&r.gzhead.comment.charCodeAt(r.gzindex++):0,Ka(r,t)}while(0!==t);r.gzhead.hcrc&&r.pending>n&&(e.adler=ca(e.adler,r.pending_buf,r.pending-n,n))}r.status=103}if(103===r.status){if(r.gzhead.hcrc){if(r.pending+2>r.pending_buf_size&&(Ha(e),0!==r.pending))return r.last_flush=-1,va;Ka(r,255&e.adler),Ka(r,e.adler>>8&255),e.adler=0}if(r.status=Ua,Ha(e),0!==r.pending)return r.last_flush=-1,va}if(0!==e.avail_in||0!==r.lookahead||t!==ga&&r.status!==$a){let n=0===r.level?Xa(r,t):r.strategy===Sa?((e,t)=>{let r;for(;;){if(0===e.lookahead&&(Ya(e),0===e.lookahead)){if(t===ga)return 1;break}if(e.match_length=0,r=fa(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(Fa(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,t===ba?(Fa(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(Fa(e,!1),0===e.strm.avail_out)?1:2})(r,t):r.strategy===Na?((e,t)=>{let r,n,a,s;const i=e.window;for(;;){if(e.lookahead<=Ca){if(Ya(e),e.lookahead<=Ca&&t===ga)return 1;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=3&&e.strstart>0&&(a=e.strstart-1,n=i[a],n===i[++a]&&n===i[++a]&&n===i[++a])){s=e.strstart+Ca;do{}while(n===i[++a]&&n===i[++a]&&n===i[++a]&&n===i[++a]&&n===i[++a]&&n===i[++a]&&n===i[++a]&&n===i[++a]&&a<s);e.match_length=Ca-(s-a),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=3?(r=fa(e,1,e.match_length-3),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=fa(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(Fa(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,t===ba?(Fa(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(Fa(e,!1),0===e.strm.avail_out)?1:2})(r,t):ts[r.level].func(r,t);if(3!==n&&4!==n||(r.status=$a),1===n||3===n)return 0===e.avail_out&&(r.last_flush=-1),va;if(2===n&&(t===ya?wa(r):t!==_a&&(ua(r,0,0,!1),t===ma&&(Ba(r.head),0===r.lookahead&&(r.strstart=0,r.block_start=0,r.insert=0))),Ha(e),0===e.avail_out))return r.last_flush=-1,va}return t!==ba?va:r.wrap<=0?Ea:(2===r.wrap?(Ka(r,255&e.adler),Ka(r,e.adler>>8&255),Ka(r,e.adler>>16&255),Ka(r,e.adler>>24&255),Ka(r,255&e.total_in),Ka(r,e.total_in>>8&255),Ka(r,e.total_in>>16&255),Ka(r,e.total_in>>24&255)):(Ga(r,e.adler>>>16),Ga(r,65535&e.adler)),Ha(e),r.wrap>0&&(r.wrap=-r.wrap),0!==r.pending?va:Ea)},cs=(e,t)=>{let r=t.length;if(ns(e))return ka;const n=e.state,a=n.wrap;if(2===a||1===a&&n.status!==Oa||n.lookahead)return ka;if(1===a&&(e.adler=ia(e.adler,t,r,0)),n.wrap=0,r>=n.w_size){0===a&&(Ba(n.head),n.strstart=0,n.block_start=0,n.insert=0);let e=new Uint8Array(n.w_size);e.set(t.subarray(r-n.w_size,r),0),t=e,r=n.w_size}const s=e.avail_in,i=e.next_in,o=e.input;for(e.avail_in=r,e.next_in=0,e.input=t,Ya(n);n.lookahead>=3;){let e=n.strstart,t=n.lookahead-2;do{n.ins_h=Va(n,n.ins_h,n.window[e+3-1]),n.prev[e&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=e,e++}while(--t);n.strstart=e,n.lookahead=2,Ya(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=2,n.match_available=0,e.next_in=i,e.input=o,e.avail_in=s,n.wrap=a,va},ds={deflateInit:(e,t)=>is(e,t,La,15,8,Da),deflateInit2:is,deflateReset:ss,deflateResetKeep:as,deflateSetHeader:(e,t)=>ns(e)||2!==e.state.wrap?ka:(e.state.gzhead=t,va),deflate:os,deflateEnd:e=>{if(ns(e))return ka;const t=e.state.status;return e.state=null,t===Ua?ja(e,Ra):va},deflateSetDictionary:cs,deflateInfo:"pako deflate (from Nodeca project)"};const ls=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var hs=function(e){const t=Array.prototype.slice.call(arguments,1);for(;t.length;){const r=t.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(const t in r)ls(r,t)&&(e[t]=r[t])}}return e},us=e=>{let t=0;for(let r=0,n=e.length;r<n;r++)t+=e[r].length;const r=new Uint8Array(t);for(let t=0,n=0,a=e.length;t<a;t++){let a=e[t];r.set(a,n),n+=a.length}return r};let ps=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){ps=!1}const fs=new Uint8Array(256);for(let e=0;e<256;e++)fs[e]=e>=252?6:e>=248?5:e>=240?4:e>=224?3:e>=192?2:1;fs[254]=fs[254]=1;var ws=e=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(e);let t,r,n,a,s,i=e.length,o=0;for(a=0;a<i;a++)r=e.charCodeAt(a),55296==(64512&r)&&a+1<i&&(n=e.charCodeAt(a+1),56320==(64512&n)&&(r=65536+(r-55296<<10)+(n-56320),a++)),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=new Uint8Array(o),s=0,a=0;s<o;a++)r=e.charCodeAt(a),55296==(64512&r)&&a+1<i&&(n=e.charCodeAt(a+1),56320==(64512&n)&&(r=65536+(r-55296<<10)+(n-56320),a++)),r<128?t[s++]=r:r<2048?(t[s++]=192|r>>>6,t[s++]=128|63&r):r<65536?(t[s++]=224|r>>>12,t[s++]=128|r>>>6&63,t[s++]=128|63&r):(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63,t[s++]=128|r>>>6&63,t[s++]=128|63&r);return t},gs=(e,t)=>{const r=t||e.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(e.subarray(0,t));let n,a;const s=new Array(2*r);for(a=0,n=0;n<r;){let t=e[n++];if(t<128){s[a++]=t;continue}let i=fs[t];if(i>4)s[a++]=65533,n+=i-1;else{for(t&=2===i?31:3===i?15:7;i>1&&n<r;)t=t<<6|63&e[n++],i--;i>1?s[a++]=65533:t<65536?s[a++]=t:(t-=65536,s[a++]=55296|t>>10&1023,s[a++]=56320|1023&t)}}return((e,t)=>{if(t<65534&&e.subarray&&ps)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));let r="";for(let n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r})(s,a)},ys=(e,t)=>{(t=t||e.length)>e.length&&(t=e.length);let r=t-1;for(;r>=0&&128==(192&e[r]);)r--;return r<0||0===r?t:r+fs[e[r]]>t?r:t};var ms=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const bs=Object.prototype.toString,{Z_NO_FLUSH:_s,Z_SYNC_FLUSH:vs,Z_FULL_FLUSH:Es,Z_FINISH:ks,Z_OK:Rs,Z_STREAM_END:As,Z_DEFAULT_COMPRESSION:Is,Z_DEFAULT_STRATEGY:xs,Z_DEFLATED:Ss}=la;function Ns(e){this.options=hs({level:Is,method:Ss,chunkSize:16384,windowBits:15,memLevel:8,strategy:xs},e||{});let t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new ms,this.strm.avail_out=0;let r=ds.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(r!==Rs)throw new Error(da[r]);if(t.header&&ds.deflateSetHeader(this.strm,t.header),t.dictionary){let e;if(e="string"==typeof t.dictionary?ws(t.dictionary):"[object ArrayBuffer]"===bs.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,r=ds.deflateSetDictionary(this.strm,e),r!==Rs)throw new Error(da[r]);this._dict_set=!0}}function Ps(e,t){const r=new Ns(t);if(r.push(e,!0),r.err)throw r.msg||da[r.err];return r.result}Ns.prototype.push=function(e,t){const r=this.strm,n=this.options.chunkSize;let a,s;if(this.ended)return!1;for(s=t===~~t?t:!0===t?ks:_s,"string"==typeof e?r.input=ws(e):"[object ArrayBuffer]"===bs.call(e)?r.input=new Uint8Array(e):r.input=e,r.next_in=0,r.avail_in=r.input.length;;)if(0===r.avail_out&&(r.output=new Uint8Array(n),r.next_out=0,r.avail_out=n),(s===vs||s===Es)&&r.avail_out<=6)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else{if(a=ds.deflate(r,s),a===As)return r.next_out>0&&this.onData(r.output.subarray(0,r.next_out)),a=ds.deflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===Rs;if(0!==r.avail_out){if(s>0&&r.next_out>0)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else if(0===r.avail_in)break}else this.onData(r.output)}return!0},Ns.prototype.onData=function(e){this.chunks.push(e)},Ns.prototype.onEnd=function(e){e===Rs&&(this.result=us(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var Ds={Deflate:Ns,deflate:Ps,deflateRaw:function(e,t){return(t=t||{}).raw=!0,Ps(e,t)},gzip:function(e,t){return(t=t||{}).gzip=!0,Ps(e,t)},constants:la};const Ts=16209;var Ls=function(e,t){let r,n,a,s,i,o,c,d,l,h,u,p,f,w,g,y,m,b,_,v,E,k,R,A;const I=e.state;r=e.next_in,R=e.input,n=r+(e.avail_in-5),a=e.next_out,A=e.output,s=a-(t-e.avail_out),i=a+(e.avail_out-257),o=I.dmax,c=I.wsize,d=I.whave,l=I.wnext,h=I.window,u=I.hold,p=I.bits,f=I.lencode,w=I.distcode,g=(1<<I.lenbits)-1,y=(1<<I.distbits)-1;e:do{p<15&&(u+=R[r++]<<p,p+=8,u+=R[r++]<<p,p+=8),m=f[u&g];t:for(;;){if(b=m>>>24,u>>>=b,p-=b,b=m>>>16&255,0===b)A[a++]=65535&m;else{if(!(16&b)){if(0==(64&b)){m=f[(65535&m)+(u&(1<<b)-1)];continue t}if(32&b){I.mode=16191;break e}e.msg="invalid literal/length code",I.mode=Ts;break e}_=65535&m,b&=15,b&&(p<b&&(u+=R[r++]<<p,p+=8),_+=u&(1<<b)-1,u>>>=b,p-=b),p<15&&(u+=R[r++]<<p,p+=8,u+=R[r++]<<p,p+=8),m=w[u&y];r:for(;;){if(b=m>>>24,u>>>=b,p-=b,b=m>>>16&255,!(16&b)){if(0==(64&b)){m=w[(65535&m)+(u&(1<<b)-1)];continue r}e.msg="invalid distance code",I.mode=Ts;break e}if(v=65535&m,b&=15,p<b&&(u+=R[r++]<<p,p+=8,p<b&&(u+=R[r++]<<p,p+=8)),v+=u&(1<<b)-1,v>o){e.msg="invalid distance too far back",I.mode=Ts;break e}if(u>>>=b,p-=b,b=a-s,v>b){if(b=v-b,b>d&&I.sane){e.msg="invalid distance too far back",I.mode=Ts;break e}if(E=0,k=h,0===l){if(E+=c-b,b<_){_-=b;do{A[a++]=h[E++]}while(--b);E=a-v,k=A}}else if(l<b){if(E+=c+l-b,b-=l,b<_){_-=b;do{A[a++]=h[E++]}while(--b);if(E=0,l<_){b=l,_-=b;do{A[a++]=h[E++]}while(--b);E=a-v,k=A}}}else if(E+=l-b,b<_){_-=b;do{A[a++]=h[E++]}while(--b);E=a-v,k=A}for(;_>2;)A[a++]=k[E++],A[a++]=k[E++],A[a++]=k[E++],_-=3;_&&(A[a++]=k[E++],_>1&&(A[a++]=k[E++]))}else{E=a-v;do{A[a++]=A[E++],A[a++]=A[E++],A[a++]=A[E++],_-=3}while(_>2);_&&(A[a++]=A[E++],_>1&&(A[a++]=A[E++]))}break}}break}}while(r<n&&a<i);_=p>>3,r-=_,p-=_<<3,u&=(1<<p)-1,e.next_in=r,e.next_out=a,e.avail_in=r<n?n-r+5:5-(r-n),e.avail_out=a<i?i-a+257:257-(a-i),I.hold=u,I.bits=p};const Cs=15,zs=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Os=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),Us=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),$s=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var js=(e,t,r,n,a,s,i,o)=>{const c=o.bits;let d,l,h,u,p,f,w=0,g=0,y=0,m=0,b=0,_=0,v=0,E=0,k=0,R=0,A=null;const I=new Uint16Array(16),x=new Uint16Array(16);let S,N,P,D=null;for(w=0;w<=Cs;w++)I[w]=0;for(g=0;g<n;g++)I[t[r+g]]++;for(b=c,m=Cs;m>=1&&0===I[m];m--);if(b>m&&(b=m),0===m)return a[s++]=20971520,a[s++]=20971520,o.bits=1,0;for(y=1;y<m&&0===I[y];y++);for(b<y&&(b=y),E=1,w=1;w<=Cs;w++)if(E<<=1,E-=I[w],E<0)return-1;if(E>0&&(0===e||1!==m))return-1;for(x[1]=0,w=1;w<Cs;w++)x[w+1]=x[w]+I[w];for(g=0;g<n;g++)0!==t[r+g]&&(i[x[t[r+g]]++]=g);if(0===e?(A=D=i,f=20):1===e?(A=zs,D=Os,f=257):(A=Us,D=$s,f=0),R=0,g=0,w=y,p=s,_=b,v=0,h=-1,k=1<<b,u=k-1,1===e&&k>852||2===e&&k>592)return 1;for(;;){S=w-v,i[g]+1<f?(N=0,P=i[g]):i[g]>=f?(N=D[i[g]-f],P=A[i[g]-f]):(N=96,P=0),d=1<<w-v,l=1<<_,y=l;do{l-=d,a[p+(R>>v)+l]=S<<24|N<<16|P|0}while(0!==l);for(d=1<<w-1;R&d;)d>>=1;if(0!==d?(R&=d-1,R+=d):R=0,g++,0==--I[w]){if(w===m)break;w=t[r+i[g]]}if(w>b&&(R&u)!==h){for(0===v&&(v=b),p+=y,_=w-v,E=1<<_;_+v<m&&(E-=I[_+v],!(E<=0));)_++,E<<=1;if(k+=1<<_,1===e&&k>852||2===e&&k>592)return 1;h=R&u,a[h]=b<<24|_<<16|p-s|0}}return 0!==R&&(a[p+R]=w-v<<24|64<<16|0),o.bits=b,0};const{Z_FINISH:Ms,Z_BLOCK:Bs,Z_TREES:Zs,Z_OK:Vs,Z_STREAM_END:Hs,Z_NEED_DICT:Fs,Z_STREAM_ERROR:Ks,Z_DATA_ERROR:Gs,Z_MEM_ERROR:Ws,Z_BUF_ERROR:qs,Z_DEFLATED:Ys}=la,Xs=16180,Js=16190,Qs=16191,ei=16192,ti=16194,ri=16199,ni=16200,ai=16206,si=16209,ii=e=>(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24);function oi(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const ci=e=>{if(!e)return 1;const t=e.state;return!t||t.strm!==e||t.mode<Xs||t.mode>16211?1:0},di=e=>{if(ci(e))return Ks;const t=e.state;return e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=Xs,t.last=0,t.havedict=0,t.flags=-1,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(852),t.distcode=t.distdyn=new Int32Array(592),t.sane=1,t.back=-1,Vs},li=e=>{if(ci(e))return Ks;const t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,di(e)},hi=(e,t)=>{let r;if(ci(e))return Ks;const n=e.state;return t<0?(r=0,t=-t):(r=5+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?Ks:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,li(e))},ui=(e,t)=>{if(!e)return Ks;const r=new oi;e.state=r,r.strm=e,r.window=null,r.mode=Xs;const n=hi(e,t);return n!==Vs&&(e.state=null),n};let pi,fi,wi=!0;const gi=e=>{if(wi){pi=new Int32Array(512),fi=new Int32Array(32);let t=0;for(;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(js(1,e.lens,0,288,pi,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;js(2,e.lens,0,32,fi,0,e.work,{bits:5}),wi=!1}e.lencode=pi,e.lenbits=9,e.distcode=fi,e.distbits=5},yi=(e,t,r,n)=>{let a;const s=e.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new Uint8Array(s.wsize)),n>=s.wsize?(s.window.set(t.subarray(r-s.wsize,r),0),s.wnext=0,s.whave=s.wsize):(a=s.wsize-s.wnext,a>n&&(a=n),s.window.set(t.subarray(r-n,r-n+a),s.wnext),(n-=a)?(s.window.set(t.subarray(r-n,r),0),s.wnext=n,s.whave=s.wsize):(s.wnext+=a,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=a))),0};var mi=(e,t)=>{let r,n,a,s,i,o,c,d,l,h,u,p,f,w,g,y,m,b,_,v,E,k,R=0;const A=new Uint8Array(4);let I,x;const S=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(ci(e)||!e.output||!e.input&&0!==e.avail_in)return Ks;r=e.state,r.mode===Qs&&(r.mode=ei),i=e.next_out,a=e.output,c=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,d=r.hold,l=r.bits,h=o,u=c,k=Vs;e:for(;;)switch(r.mode){case Xs:if(0===r.wrap){r.mode=ei;break}for(;l<16;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}if(2&r.wrap&&35615===d){0===r.wbits&&(r.wbits=15),r.check=0,A[0]=255&d,A[1]=d>>>8&255,r.check=ca(r.check,A,2,0),d=0,l=0,r.mode=16181;break}if(r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&d)<<8)+(d>>8))%31){e.msg="incorrect header check",r.mode=si;break}if((15&d)!==Ys){e.msg="unknown compression method",r.mode=si;break}if(d>>>=4,l-=4,E=8+(15&d),0===r.wbits&&(r.wbits=E),E>15||E>r.wbits){e.msg="invalid window size",r.mode=si;break}r.dmax=1<<r.wbits,r.flags=0,e.adler=r.check=1,r.mode=512&d?16189:Qs,d=0,l=0;break;case 16181:for(;l<16;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}if(r.flags=d,(255&r.flags)!==Ys){e.msg="unknown compression method",r.mode=si;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=si;break}r.head&&(r.head.text=d>>8&1),512&r.flags&&4&r.wrap&&(A[0]=255&d,A[1]=d>>>8&255,r.check=ca(r.check,A,2,0)),d=0,l=0,r.mode=16182;case 16182:for(;l<32;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}r.head&&(r.head.time=d),512&r.flags&&4&r.wrap&&(A[0]=255&d,A[1]=d>>>8&255,A[2]=d>>>16&255,A[3]=d>>>24&255,r.check=ca(r.check,A,4,0)),d=0,l=0,r.mode=16183;case 16183:for(;l<16;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}r.head&&(r.head.xflags=255&d,r.head.os=d>>8),512&r.flags&&4&r.wrap&&(A[0]=255&d,A[1]=d>>>8&255,r.check=ca(r.check,A,2,0)),d=0,l=0,r.mode=16184;case 16184:if(1024&r.flags){for(;l<16;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}r.length=d,r.head&&(r.head.extra_len=d),512&r.flags&&4&r.wrap&&(A[0]=255&d,A[1]=d>>>8&255,r.check=ca(r.check,A,2,0)),d=0,l=0}else r.head&&(r.head.extra=null);r.mode=16185;case 16185:if(1024&r.flags&&(p=r.length,p>o&&(p=o),p&&(r.head&&(E=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Uint8Array(r.head.extra_len)),r.head.extra.set(n.subarray(s,s+p),E)),512&r.flags&&4&r.wrap&&(r.check=ca(r.check,n,p,s)),o-=p,s+=p,r.length-=p),r.length))break e;r.length=0,r.mode=16186;case 16186:if(2048&r.flags){if(0===o)break e;p=0;do{E=n[s+p++],r.head&&E&&r.length<65536&&(r.head.name+=String.fromCharCode(E))}while(E&&p<o);if(512&r.flags&&4&r.wrap&&(r.check=ca(r.check,n,p,s)),o-=p,s+=p,E)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=16187;case 16187:if(4096&r.flags){if(0===o)break e;p=0;do{E=n[s+p++],r.head&&E&&r.length<65536&&(r.head.comment+=String.fromCharCode(E))}while(E&&p<o);if(512&r.flags&&4&r.wrap&&(r.check=ca(r.check,n,p,s)),o-=p,s+=p,E)break e}else r.head&&(r.head.comment=null);r.mode=16188;case 16188:if(512&r.flags){for(;l<16;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}if(4&r.wrap&&d!==(65535&r.check)){e.msg="header crc mismatch",r.mode=si;break}d=0,l=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=Qs;break;case 16189:for(;l<32;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}e.adler=r.check=ii(d),d=0,l=0,r.mode=Js;case Js:if(0===r.havedict)return e.next_out=i,e.avail_out=c,e.next_in=s,e.avail_in=o,r.hold=d,r.bits=l,Fs;e.adler=r.check=1,r.mode=Qs;case Qs:if(t===Bs||t===Zs)break e;case ei:if(r.last){d>>>=7&l,l-=7&l,r.mode=ai;break}for(;l<3;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}switch(r.last=1&d,d>>>=1,l-=1,3&d){case 0:r.mode=16193;break;case 1:if(gi(r),r.mode=ri,t===Zs){d>>>=2,l-=2;break e}break;case 2:r.mode=16196;break;case 3:e.msg="invalid block type",r.mode=si}d>>>=2,l-=2;break;case 16193:for(d>>>=7&l,l-=7&l;l<32;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}if((65535&d)!=(d>>>16^65535)){e.msg="invalid stored block lengths",r.mode=si;break}if(r.length=65535&d,d=0,l=0,r.mode=ti,t===Zs)break e;case ti:r.mode=16195;case 16195:if(p=r.length,p){if(p>o&&(p=o),p>c&&(p=c),0===p)break e;a.set(n.subarray(s,s+p),i),o-=p,s+=p,c-=p,i+=p,r.length-=p;break}r.mode=Qs;break;case 16196:for(;l<14;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}if(r.nlen=257+(31&d),d>>>=5,l-=5,r.ndist=1+(31&d),d>>>=5,l-=5,r.ncode=4+(15&d),d>>>=4,l-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=si;break}r.have=0,r.mode=16197;case 16197:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}r.lens[S[r.have++]]=7&d,d>>>=3,l-=3}for(;r.have<19;)r.lens[S[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,I={bits:r.lenbits},k=js(0,r.lens,0,19,r.lencode,0,r.work,I),r.lenbits=I.bits,k){e.msg="invalid code lengths set",r.mode=si;break}r.have=0,r.mode=16198;case 16198:for(;r.have<r.nlen+r.ndist;){for(;R=r.lencode[d&(1<<r.lenbits)-1],g=R>>>24,y=R>>>16&255,m=65535&R,!(g<=l);){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}if(m<16)d>>>=g,l-=g,r.lens[r.have++]=m;else{if(16===m){for(x=g+2;l<x;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}if(d>>>=g,l-=g,0===r.have){e.msg="invalid bit length repeat",r.mode=si;break}E=r.lens[r.have-1],p=3+(3&d),d>>>=2,l-=2}else if(17===m){for(x=g+3;l<x;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}d>>>=g,l-=g,E=0,p=3+(7&d),d>>>=3,l-=3}else{for(x=g+7;l<x;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}d>>>=g,l-=g,E=0,p=11+(127&d),d>>>=7,l-=7}if(r.have+p>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=si;break}for(;p--;)r.lens[r.have++]=E}}if(r.mode===si)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=si;break}if(r.lenbits=9,I={bits:r.lenbits},k=js(1,r.lens,0,r.nlen,r.lencode,0,r.work,I),r.lenbits=I.bits,k){e.msg="invalid literal/lengths set",r.mode=si;break}if(r.distbits=6,r.distcode=r.distdyn,I={bits:r.distbits},k=js(2,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,I),r.distbits=I.bits,k){e.msg="invalid distances set",r.mode=si;break}if(r.mode=ri,t===Zs)break e;case ri:r.mode=ni;case ni:if(o>=6&&c>=258){e.next_out=i,e.avail_out=c,e.next_in=s,e.avail_in=o,r.hold=d,r.bits=l,Ls(e,u),i=e.next_out,a=e.output,c=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,d=r.hold,l=r.bits,r.mode===Qs&&(r.back=-1);break}for(r.back=0;R=r.lencode[d&(1<<r.lenbits)-1],g=R>>>24,y=R>>>16&255,m=65535&R,!(g<=l);){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}if(y&&0==(240&y)){for(b=g,_=y,v=m;R=r.lencode[v+((d&(1<<b+_)-1)>>b)],g=R>>>24,y=R>>>16&255,m=65535&R,!(b+g<=l);){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}d>>>=b,l-=b,r.back+=b}if(d>>>=g,l-=g,r.back+=g,r.length=m,0===y){r.mode=16205;break}if(32&y){r.back=-1,r.mode=Qs;break}if(64&y){e.msg="invalid literal/length code",r.mode=si;break}r.extra=15&y,r.mode=16201;case 16201:if(r.extra){for(x=r.extra;l<x;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}r.length+=d&(1<<r.extra)-1,d>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=16202;case 16202:for(;R=r.distcode[d&(1<<r.distbits)-1],g=R>>>24,y=R>>>16&255,m=65535&R,!(g<=l);){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}if(0==(240&y)){for(b=g,_=y,v=m;R=r.distcode[v+((d&(1<<b+_)-1)>>b)],g=R>>>24,y=R>>>16&255,m=65535&R,!(b+g<=l);){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}d>>>=b,l-=b,r.back+=b}if(d>>>=g,l-=g,r.back+=g,64&y){e.msg="invalid distance code",r.mode=si;break}r.offset=m,r.extra=15&y,r.mode=16203;case 16203:if(r.extra){for(x=r.extra;l<x;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}r.offset+=d&(1<<r.extra)-1,d>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=si;break}r.mode=16204;case 16204:if(0===c)break e;if(p=u-c,r.offset>p){if(p=r.offset-p,p>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=si;break}p>r.wnext?(p-=r.wnext,f=r.wsize-p):f=r.wnext-p,p>r.length&&(p=r.length),w=r.window}else w=a,f=i-r.offset,p=r.length;p>c&&(p=c),c-=p,r.length-=p;do{a[i++]=w[f++]}while(--p);0===r.length&&(r.mode=ni);break;case 16205:if(0===c)break e;a[i++]=r.length,c--,r.mode=ni;break;case ai:if(r.wrap){for(;l<32;){if(0===o)break e;o--,d|=n[s++]<<l,l+=8}if(u-=c,e.total_out+=u,r.total+=u,4&r.wrap&&u&&(e.adler=r.check=r.flags?ca(r.check,a,u,i-u):ia(r.check,a,u,i-u)),u=c,4&r.wrap&&(r.flags?d:ii(d))!==r.check){e.msg="incorrect data check",r.mode=si;break}d=0,l=0}r.mode=16207;case 16207:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break e;o--,d+=n[s++]<<l,l+=8}if(4&r.wrap&&d!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=si;break}d=0,l=0}r.mode=16208;case 16208:k=Hs;break e;case si:k=Gs;break e;case 16210:return Ws;default:return Ks}return e.next_out=i,e.avail_out=c,e.next_in=s,e.avail_in=o,r.hold=d,r.bits=l,(r.wsize||u!==e.avail_out&&r.mode<si&&(r.mode<ai||t!==Ms))&&yi(e,e.output,e.next_out,u-e.avail_out),h-=e.avail_in,u-=e.avail_out,e.total_in+=h,e.total_out+=u,r.total+=u,4&r.wrap&&u&&(e.adler=r.check=r.flags?ca(r.check,a,u,e.next_out-u):ia(r.check,a,u,e.next_out-u)),e.data_type=r.bits+(r.last?64:0)+(r.mode===Qs?128:0)+(r.mode===ri||r.mode===ti?256:0),(0===h&&0===u||t===Ms)&&k===Vs&&(k=qs),k},bi={inflateReset:li,inflateReset2:hi,inflateResetKeep:di,inflateInit:e=>ui(e,15),inflateInit2:ui,inflate:mi,inflateEnd:e=>{if(ci(e))return Ks;let t=e.state;return t.window&&(t.window=null),e.state=null,Vs},inflateGetHeader:(e,t)=>{if(ci(e))return Ks;const r=e.state;return 0==(2&r.wrap)?Ks:(r.head=t,t.done=!1,Vs)},inflateSetDictionary:(e,t)=>{const r=t.length;let n,a,s;return ci(e)?Ks:(n=e.state,0!==n.wrap&&n.mode!==Js?Ks:n.mode===Js&&(a=1,a=ia(a,t,r,0),a!==n.check)?Gs:(s=yi(e,t,r,r),s?(n.mode=16210,Ws):(n.havedict=1,Vs)))},inflateInfo:"pako inflate (from Nodeca project)"};var _i=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const vi=Object.prototype.toString,{Z_NO_FLUSH:Ei,Z_FINISH:ki,Z_OK:Ri,Z_STREAM_END:Ai,Z_NEED_DICT:Ii,Z_STREAM_ERROR:xi,Z_DATA_ERROR:Si,Z_MEM_ERROR:Ni}=la;function Pi(e){this.options=hs({chunkSize:65536,windowBits:15,to:""},e||{});const t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new ms,this.strm.avail_out=0;let r=bi.inflateInit2(this.strm,t.windowBits);if(r!==Ri)throw new Error(da[r]);if(this.header=new _i,bi.inflateGetHeader(this.strm,this.header),t.dictionary&&("string"==typeof t.dictionary?t.dictionary=ws(t.dictionary):"[object ArrayBuffer]"===vi.call(t.dictionary)&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(r=bi.inflateSetDictionary(this.strm,t.dictionary),r!==Ri)))throw new Error(da[r])}function Di(e,t){const r=new Pi(t);if(r.push(e),r.err)throw r.msg||da[r.err];return r.result}Pi.prototype.push=function(e,t){const r=this.strm,n=this.options.chunkSize,a=this.options.dictionary;let s,i,o;if(this.ended)return!1;for(i=t===~~t?t:!0===t?ki:Ei,"[object ArrayBuffer]"===vi.call(e)?r.input=new Uint8Array(e):r.input=e,r.next_in=0,r.avail_in=r.input.length;;){for(0===r.avail_out&&(r.output=new Uint8Array(n),r.next_out=0,r.avail_out=n),s=bi.inflate(r,i),s===Ii&&a&&(s=bi.inflateSetDictionary(r,a),s===Ri?s=bi.inflate(r,i):s===Si&&(s=Ii));r.avail_in>0&&s===Ai&&r.state.wrap>0&&0!==e[r.next_in];)bi.inflateReset(r),s=bi.inflate(r,i);switch(s){case xi:case Si:case Ii:case Ni:return this.onEnd(s),this.ended=!0,!1}if(o=r.avail_out,r.next_out&&(0===r.avail_out||s===Ai))if("string"===this.options.to){let e=ys(r.output,r.next_out),t=r.next_out-e,a=gs(r.output,e);r.next_out=t,r.avail_out=n-t,t&&r.output.set(r.output.subarray(e,e+t),0),this.onData(a)}else this.onData(r.output.length===r.next_out?r.output:r.output.subarray(0,r.next_out));if(s!==Ri||0!==o){if(s===Ai)return s=bi.inflateEnd(this.strm),this.onEnd(s),this.ended=!0,!0;if(0===r.avail_in)break}}return!0},Pi.prototype.onData=function(e){this.chunks.push(e)},Pi.prototype.onEnd=function(e){e===Ri&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=us(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var Ti={Inflate:Pi,inflate:Di,inflateRaw:function(e,t){return(t=t||{}).raw=!0,Di(e,t)},ungzip:Di,constants:la};const{Deflate:Li,deflate:Ci,deflateRaw:zi,gzip:Oi}=Ds,{Inflate:Ui,inflate:$i,inflateRaw:ji,ungzip:Mi}=Ti;var Bi={Deflate:Li,deflate:Ci,deflateRaw:zi,gzip:Oi,Inflate:Ui,inflate:$i,inflateRaw:ji,ungzip:Mi,constants:la},Zi=r(48438);class Vi{constructor({preload:e,repo:t,hashers:r,options:n}){const a=function({repo:e,preload:t,hashers:r,options:n}){const a=n&&n.sharding;return(0,Ot.a)((async function*(n,s={}){const i=mn({shardSplitThreshold:a?1e3:1/0,strategy:"balanced"},s,{...wn(s.chunker)});i.hashAlg&&"sha2-256"!==i.hashAlg&&1!==i.cidVersion&&(i.cidVersion=1),i.trickle&&(i.strategy="trickle"),"trickle"===i.strategy&&(i.leafType="raw",i.reduceSingleLeafToSelf=!1),i.cidVersion>0&&void 0===i.rawLeaves&&(i.rawLeaves=!0),void 0!==i.hashAlg&&void 0===i.rawLeaves&&(i.rawLeaves=!0),delete i.trickle;const o={};if(i.progress){const e=i.progress;i.progress=(t,r)=>{o[r]||(o[r]=0),o[r]+=t,e(o[r],r)}}let c;null!=i.hashAlg&&(c=await r.getHasher(i.hashAlg));const d=(0,dn.zG)((0,fn.f)(n),(t=>(0,pn.Z)(t,e.blocks,{...i,hasher:c,pin:!1})),function(e){async function*t(t){for await(const r of t){let t=r.cid;1===e.cidVersion&&(t=t.toV1());let n=r.path?r.path:t.toString();e.wrapWithDirectory&&!r.path&&(n=""),yield{path:n,cid:t,size:r.size,mode:r.unixfs&&r.unixfs.mode,mtime:r.unixfs&&r.unixfs.mtime}}}return t}(i),function(e,t){async function*r(r){for await(const n of r)(!n.path||t.wrapWithDirectory?""===n.path:!n.path.includes("/"))&&!t.onlyHash&&!1!==t.preload&&e(n.cid),yield n}return r}(t,i),function(e,t){async function*r(r){for await(const n of r){const r=!(n.path&&n.path.includes("/"));(null==t.pin||t.pin)&&r&&!t.onlyHash&&await e.pins.pinRecursively(n.cid),yield n}}return r}(e,i)),l=await e.gcLock.readLock();try{for await(const e of d){const t=e.path??e.cid.toString();delete o[t],yield{...e,path:t}}}finally{l()}}))}({preload:e,repo:t,options:n,hashers:r});this.addAll=a,this.add=function({addAll:e}){return async function(t,r={}){const n=await(0,Yt.Z)(e((0,un.f)(t),r));if(null==n)throw Error("Failed to add a file, if you see this please report a bug");return n}}({addAll:a}),this.cat=function({repo:e,preload:t}){return(0,Ot.a)((async function*(r,n={}){if(r=Bt(r),!1!==n.preload){const e=r.split("/");t(We.parse(e[0]))}const a=await(0,bn.OY)(r,e.blocks,n);if("directory"===a.type)throw new Error("this dag node is a directory");if(!a.content)throw new Error("this dag node has no content");yield*a.content(n)}))}({repo:t,preload:e}),this.get=function({repo:e,preload:t}){return(0,Ot.a)((async function*(r,n={}){if(null!=n.compressionLevel&&(n.compressionLevel<-1||n.compressionLevel>9))throw _(new Error("Compression level must be between -1 and 9"),"ERR_INVALID_PARAMS");if(!1!==n.preload){let e;try{e=Bt(r).split("/")}catch(e){throw _(e,"ERR_INVALID_PATH")}t(We.parse(e[0]))}const a=We.asCID(r)||r,s=await(0,bn.OY)(a,e.blocks,n);if("file"===s.type||"raw"===s.type){const e=[];return n.compress&&!0!==n.archive?e.push(s.content):e.push([{header:{name:s.path,mode:"file"===s.type&&s.unixfs.mode,mtime:"file"===s.type&&s.unixfs.mtime?new Date(1e3*s.unixfs.mtime.secs):void 0,size:s.size,type:"file"},body:s.content()}],(0,_n.P)()),n.compress&&e.push((async function*(e){const t=await(0,Zi.Z)(e);yield Bi.gzip(t,{level:n.compressionLevel||6})})),void(yield*(0,dn.zG)(...e))}if("directory"!==s.type)throw _(new Error("Not a UnixFS node"),"ERR_NOT_UNIXFS");{const t=[(0,bn.BE)(a,e.blocks,n),async function*(e){for await(const t of e){const e={header:{name:t.path,size:t.size}};if("file"===t.type)e.header.type="file",e.header.mode=null!=t.unixfs.mode?t.unixfs.mode:void 0,e.header.mtime=t.unixfs.mtime?new Date(1e3*t.unixfs.mtime.secs):void 0,e.body=t.content();else if("raw"===t.type)e.header.type="file",e.body=t.content();else{if("directory"!==t.type)throw _(new Error("Not a UnixFS node"),"ERR_NOT_UNIXFS");e.header.type="directory",e.header.mode=null!=t.unixfs.mode?t.unixfs.mode:void 0,e.header.mtime=t.unixfs.mtime?new Date(1e3*t.unixfs.mtime.secs):void 0}yield e}},(0,_n.P)()];if(n.compress){if(!n.archive)throw _(new Error("file is not regular"),"ERR_INVALID_PATH");n.compress&&t.push((async function*(e){const t=await(0,Zi.Z)(e);yield Bi.gzip(t,{level:n.compressionLevel||6})}))}yield*(0,dn.zG)(...t)}}))}({repo:t,preload:e}),this.ls=function({repo:e,preload:t}){return(0,Ot.a)((async function*(r,n={}){const a=Bt(r),s=a.split("/");!1!==n.preload&&t(We.parse(s[0]));const i=We.asCID(a)||a,o=await(0,bn.OY)(i,e.blocks,n);if("file"!==o.type){if("directory"!==o.type)throw _(new Error(`Unknown UnixFS type ${o.type}`),"ERR_UNKNOWN_UNIXFS_TYPE");for await(const e of o.content())yield Vt(e)}else yield Vt(o)}))}({repo:t,preload:e})}}const Hi="0.17.0";const Fi=(0,b.kg)("ipfs:components:id");function Ki({peerId:e,network:t}){return(0,Ot.a)((async function(r={}){const n=t.try();if(!n){if(r.peerId)throw new dt;if(null==e.publicKey)throw _(new Error("Public key missing"),"ERR_MISSING_PUBLIC_KEY");return{id:e,publicKey:Rt(e.publicKey,"base64pad"),addresses:[],agentVersion:"js-ipfs/0.17.0",protocolVersion:"9000",protocols:[]}}const{libp2p:a}=n,s=r.peerId?r.peerId:e,i=await async function(e,t,r){let n=await t.peerStore.get(e);n||(n=await async function(e,t,r){if(null==t.dht)throw _(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");for await(const n of t.dht.findPeer(e,r))if("FINAL_PEER"===n.name)break;const n=await t.peerStore.get(e);if(!n)throw _(new Error("Could not find peer"),"ERR_NOT_FOUND");return n}(e,t,r));let a=e.publicKey?e.publicKey:await t.peerStore.keyBook.get(e);if(null==a)try{a=await t.getPublicKey(e,r)}catch(t){Fi.error("Could not load public key for",e.toString(),t)}return{...n,publicKey:a,metadata:n.metadata||new Map,addresses:n.addresses.map((e=>e.multiaddr))}}(s,a,r),o=Rt(i.metadata.get("AgentVersion")||new Uint8Array),c=Rt(i.metadata.get("ProtocolVersion")||new Uint8Array),d=i.id.toString();return{id:s,publicKey:i.publicKey?Rt(i.publicKey,"base64pad"):"",addresses:(i.addresses||[]).map((e=>{const t=e.toString();return t.endsWith(`/p2p/${d}`)?t:`${t}/p2p/${d}`})).sort().map((e=>(0,vt.HM)(e))),agentVersion:o,protocolVersion:c,protocols:(i.protocols||[]).sort()}}))}var Gi=r(26679);const Wi={server:{description:"Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",transform:e=>((0,Gi.Z)(e,"Discovery.MDNS.Enabled",!1),(0,Gi.Z)(e,"Discovery.webRTCStar.Enabled",!1),e.Swarm={...e.Swarm||{},DisableNatPortMap:!0},e)},"local-discovery":{description:"Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",transform:e=>((0,Gi.Z)(e,"Discovery.MDNS.Enabled",!0),(0,Gi.Z)(e,"Discovery.webRTCStar.Enabled",!0),(0,Gi.Z)(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!1}),e)},test:{description:"Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",transform:e=>{const t=(0,nn.Z)();return(0,Gi.Z)(e,"Addresses.API",t.Addresses.API?"/ip4/127.0.0.1/tcp/0":""),(0,Gi.Z)(e,"Addresses.Gateway",t.Addresses.Gateway?"/ip4/127.0.0.1/tcp/0":""),(0,Gi.Z)(e,"Addresses.Swarm",t.Addresses.Swarm.length?["/ip4/127.0.0.1/tcp/0"]:[]),(0,Gi.Z)(e,"Addresses.Delegates",[]),(0,Gi.Z)(e,"Bootstrap",[]),(0,Gi.Z)(e,"Discovery.MDNS.Enabled",!1),(0,Gi.Z)(e,"Discovery.webRTCStar.Enabled",!1),(0,Gi.Z)(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!0}),e}},"default-networking":{description:"Restores default network settings. Inverse profile of the `test` profile.",transform:e=>{const t=(0,nn.Z)();return(0,Gi.Z)(e,"Addresses.API",t.Addresses.API),(0,Gi.Z)(e,"Addresses.Gateway",t.Addresses.Gateway),(0,Gi.Z)(e,"Addresses.Swarm",t.Addresses.Swarm),(0,Gi.Z)(e,"Addresses.Delegates",t.Addresses.Delegates),(0,Gi.Z)(e,"Bootstrap",t.Bootstrap),(0,Gi.Z)(e,"Discovery.MDNS.Enabled",t.Discovery.MDNS.Enabled),(0,Gi.Z)(e,"Discovery.webRTCStar.Enabled",t.Discovery.webRTCStar.Enabled),(0,Gi.Z)(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!1}),e}},lowpower:{description:"Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",transform:e=>{const t=e.Swarm||{},r=t.ConnMgr||{};return r.LowWater=20,r.HighWater=40,t.ConnMgr=r,e.Swarm=t,e}},"default-power":{description:'Inverse of "lowpower" profile.',transform:e=>{const t=(0,nn.Z)();return e.Swarm=t.Swarm,e}}},qi=(0,b.kg)("ipfs:core:config");async function Yi(e){return Object.keys(Wi).map((e=>({name:e,description:Wi[e].description})))}function Xi({enumerable:e=!0,configurable:t=!1}={}){return{enumerable:e,configurable:t,writable:!1}}function*Ji(e,t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))for(const[r,n]of t.entries()){const t=[...e,r],a=We.asCID(n);a?yield[t.join("/"),a]:"object"==typeof n&&(yield*Qi(n,t))}else{const r=We.asCID(t);r?yield[e.join("/"),r]:yield*Qi(t,e)}}function*Qi(e,t){if(!(null==e||e instanceof Uint8Array))for(const[r,n]of Object.entries(e)){const e=[...t,r];yield*Ji(e,n)}}function*eo(e,t){if(Array.isArray(t))for(const[r,n]of t.entries()){const t=[...e,r];yield t.join("/"),"object"!=typeof n||We.asCID(n)||(yield*to(n,t))}else yield*to(t,e)}function*to(e,t){if(null!=e&&"object"==typeof e)for(const[r,n]of Object.entries(e)){const e=[...t,r];yield e.join("/"),null==n||n instanceof Uint8Array||"object"!=typeof n||We.asCID(n)||(yield*eo(e,n))}}class ro{constructor({cid:e,bytes:t,value:r}){if(!e||!t||void 0===r)throw new Error("Missing required argument");this.cid=e,this.bytes=t,this.value=r,this.asBlock=this,Object.defineProperties(this,{cid:Xi(),bytes:Xi(),value:Xi(),asBlock:Xi()})}links(){return Qi(this.value,[])}tree(){return to(this.value,[])}get(e="/"){return function(e,t){let r=e;for(const[e,n]of t.entries()){if(r=r[n],null==r)throw new Error(`Object has no property at ${t.slice(0,e+1).map((e=>`[${JSON.stringify(e)}]`)).join("")}`);const a=We.asCID(r);if(a)return{value:a,remaining:t.slice(e+1).join("/")}}return{value:r}}(this.value,e.split("/").filter(Boolean))}}function no({bytes:e,cid:t,value:r,codec:n}){const a=void 0!==r?r:n&&n.decode(e);if(void 0===a)throw new Error('Missing required argument, must either provide "value" or "codec"');return new ro({cid:t,bytes:e,value:a})}var ao=r(71855);const so=async({cid:e,load:t,seen:r})=>{r=r||new Set;const n=e.toString(ve);if(r.has(n))return;const a=await t(e);if(r.add(n),null!==a)for(const[,e]of a.links())await so({cid:e,load:t,seen:r})},io=(0,b.kg)("ipfs:components:dag:import"),oo=[Ue,Ve];function co({repo:e,preload:t,codecs:r}){return(0,Ot.a)((async function*(n,a={}){!1!==a.preload&&t(n);const s=We.asCID(n);if(!s)throw new Error(`Unexpected error converting CID type: ${n}`);io(`Exporting ${s} as car`);const{writer:i,out:o}=await ao.Gp.create([s]);let c=null;(async()=>{try{const t=function(e,t,r,n){return async a=>{const s=await n.getCodec(a.code);if(!s)throw new Error(`Can't decode links in block with codec 0x${a.code.toString(16)} to form complete DAG`);const i=await e.blocks.get(a,r);return io(`Adding block ${a} to car`),await t.put({cid:a,bytes:i}),oo.includes(a.code)?null:no({bytes:i,cid:a,codec:s})}}(e,i,{signal:a.signal,timeout:a.timeout},r);await so({cid:s,load:t})}catch(e){c=e}finally{i.close()}})();for await(const e of o){if(c)break;yield e}if(c)throw c}))}var lo=r(91486);var ho=r(80636),uo=r(75671);const po=(0,b.kg)("ipfs:components:dag:import");async function fo(e,t,r){const n=await ho.vQ.fromIterable(r),a=await n.getRoots();return await(0,Nr.Z)(e.blocks.putMany((0,on.Z)(n,(({cid:e,bytes:t})=>(po(`Import block ${e}`),{key:e,value:t}))),{signal:t.signal})),a}class wo{constructor({repo:e,codecs:t,hashers:r,preload:n}){this.export=co({repo:e,preload:n,codecs:t}),this.get=function({codecs:e,repo:t,preload:r}){return(0,Ot.a)((async function(n,a={}){if(!1!==a.preload&&r(n),a.path){const r=a.localResolve?await(0,lo.Z)(Ft(n,a.path,e,t,a)):await(0,Yt.Z)(Ft(n,a.path,e,t,a));if(!r)throw _(new Error("Not found"),"ERR_NOT_FOUND");return r}const s=await e.getCodec(n.code),i=await t.blocks.get(n,a);return{value:s.decode(i),remainderPath:""}}))}({codecs:t,repo:e,preload:n}),this.import=function({repo:e}){return(0,Ot.a)((async function*(t,r={}){const n=await e.gcLock.readLock();try{const a={signal:r.signal,timeout:r.timeout},s=(0,uo.Z)(t),{value:i,done:o}=await s.peek();if(o)return;let c;i&&s.push(i),c=i instanceof Uint8Array?[s]:s;for await(const t of c){const n=await fo(e,a,t);if(!1!==r.pinRoots)for(const t of n){let r="";try{await e.blocks.has(t)?(po(`Pinning root ${t}`),await e.pins.pinRecursively(t)):r="blockstore: block not found"}catch(e){r=e.message}yield{root:{cid:t,pinErrorMsg:r}}}}}finally{n()}}))}({repo:e}),this.resolve=function({repo:e,codecs:t,preload:r}){return(0,Ot.a)((async function(n,a={}){const{cid:s}=(0,Ut.B)(n);return!1!==a.preload&&r(s),Zt(e,t,n,a)}))}({repo:e,codecs:t,preload:n}),this.put=function({repo:e,codecs:t,hashers:r,preload:n}){return(0,Ot.a)((async function(a,s={}){const i=s.pin?await e.gcLock.readLock():null;try{const o=await t.getCodec(s.storeCodec||"dag-cbor");if(!o)throw new Error(`Unknown storeCodec ${s.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);if(s.inputCodec){if(!(a instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");const e=await t.getCodec(s.inputCodec);if(!e)throw new Error(`Unknown inputCodec ${s.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);a=e.decode(a)}const c=null!=s.version?s.version:1,d=await r.getHasher(s.hashAlg||"sha2-256");if(!d)throw new Error(`Unknown hash algorithm ${s.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);const l=o.encode(a),h=await d.digest(l),u=We.create(c,o.code,h);return await e.blocks.put(u,l,{signal:s.signal}),s.pin&&await e.pins.pinRecursively(u),!1!==s.preload&&n(u),u}finally{i&&i()}}))}({repo:e,codecs:t,hashers:r,preload:n})}}var go=r(45182),yo=r(7688),mo=r(6);const bo=(0,b.kg)("ipfs:preload");const _o=(0,b.kg)("ipfs:mfs-preload");var vo=r(33412);let Eo;function ko(e=!1){if(Eo)return Eo;const t=(0,vo.Z)({singleProcess:e});return Eo={readLock:e=>async(...r)=>{const n=await t.readLock();try{return await e.apply(null,r)}finally{n()}},writeLock:e=>async(...r)=>{const n=await t.writeLock();try{return await e.apply(null,r)}finally{n()}}},Eo}const Ro=(0,b.kg)("ipfs:mfs:utils:with-mfs-root");async function Ao(e,t){if(t&&t.signal&&t.signal.aborted)throw _(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});let r;await e.repo.datastore.open();try{const t=await e.repo.datastore.get(jt);r=We.decode(t)}catch(n){if("ERR_NOT_FOUND"!==n.code)throw n;Ro("Creating new MFS root");const a=E.encode({Data:new v.fL({type:"directory"}).marshal(),Links:[]}),s=await Ce.digest(a);if(r=We.createV0(s),await e.repo.blocks.put(r,a),t&&t.signal&&t.signal.aborted)throw _(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});await e.repo.datastore.put(jt,r.bytes)}return Ro(`Loaded MFS root /ipfs/${r}`),r}function Io(e=""){return(e.trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean)}const xo="ipfs",So=async(e,t,r)=>{const n=await Ao(e,r);let a={entryType:"file"},s="";if(s=We.asCID(t)?`/ipfs/${t}`:t.toString(),s=s.trim(),s=s.replace(/(\/\/+)/g,"/"),s.endsWith("/")&&s.length>1&&(s=s.substring(0,s.length-1)),!s)throw _(new Error("paths must not be empty"),"ERR_NO_PATH");if("/"!==s.substring(0,1))throw _(new Error("paths must start with a leading slash"),"ERR_INVALID_PATH");"/"===s.substring(s.length-1)&&(s=s.substring(0,s.length-1));const i=Io(s);if(i[0]===xo){let e;e=2===i.length?`/${i.join("/")}`:`/${i.slice(0,i.length-1).join("/")}`,a={type:"ipfs",depth:i.length-2,entryType:"file",mfsPath:`/${i.join("/")}`,mfsDirectory:e,parts:i,path:`/${i.join("/")}`,name:i[i.length-1]}}else{const e=`/ipfs/${n}${i.length?"/"+i.join("/"):""}`,t=`/ipfs/${n}/${i.slice(0,i.length-1).join("/")}`;a={type:"mfs",depth:i.length,entryType:"file",mfsDirectory:t,mfsPath:e,parts:i,path:`/${i.join("/")}`,name:i[i.length-1]}}const o="mfs"===a.type?a.mfsPath:a.path;try{const t=await(0,bn.OY)(o,e.repo.blocks,r);a.cid=t.cid,a.mfsPath=`/ipfs/${t.path}`,a.entryType=t.type,a.content=t.content,"file"!==a.entryType&&"directory"!==a.entryType||"file"!==t.type&&"directory"!==t.type||(a.unixfs=t.unixfs)}catch(e){if("ERR_NOT_FOUND"!==e.code)throw e}return a.exists=Boolean(a.cid),a},No=y.Z.bind({ignoreUndefined:!0}),Po=(0,b.kg)("ipfs:mfs:stat"),Do={withLocal:!1};function To(e){return(0,Ot.a)((async function(t,r={}){r=No(Do,r),Po(`Fetching stats for ${t}`);const{type:n,cid:a,mfsPath:s}=await So(e,t,r),i="ipfs"===n&&a?a:s;let o;try{o=await(0,bn.OY)(i,e.repo.blocks)}catch(e){if("ERR_NOT_FOUND"===e.code)throw _(new Error(`${t} does not exist`),"ERR_NOT_FOUND");throw e}if(!Lo[o.type])throw new Error(`Cannot stat codec ${o.cid.code}`);return Lo[o.type](o)}))}const Lo={raw:e=>({cid:e.cid,size:e.node.length,cumulativeSize:e.node.length,blocks:0,type:"file",local:void 0,sizeLocal:void 0,withLocality:!1}),file:e=>{const t={cid:e.cid,type:"file",size:e.unixfs.fileSize(),cumulativeSize:E.encode(e.node).length+(e.node.Links||[]).reduce(((e,t)=>e+(t.Tsize||0)),0),blocks:e.unixfs.blockSizes.length,local:void 0,sizeLocal:void 0,withLocality:!1,mode:e.unixfs.mode};return e.unixfs.mtime&&(t.mtime=e.unixfs.mtime),t},directory:e=>{const t={cid:e.cid,type:"directory",size:0,cumulativeSize:E.encode(e.node).length+(e.node.Links||[]).reduce(((e,t)=>e+(t.Tsize||0)),0),blocks:e.node.Links.length,local:void 0,sizeLocal:void 0,withLocality:!1,mode:e.unixfs.mode};return e.unixfs.mtime&&(t.mtime=e.unixfs.mtime),t},object:e=>({cid:e.cid,size:e.node.length,cumulativeSize:e.node.length,type:"file",blocks:0,local:void 0,sizeLocal:void 0,withLocality:!1}),identity:e=>({cid:e.cid,size:e.node.length,cumulativeSize:e.node.length,blocks:0,type:"file",local:void 0,sizeLocal:void 0,withLocality:!1})},Co=(0,b.kg)("ipfs:mfs:utils:to-trail");async function zo(e,t){Co(`Creating trail for path ${t}`);const r=[];for await(const n of(0,bn.HN)(t,e.repo.blocks))r.push({name:n.name,cid:n.cid,size:n.size,type:n.type});return r}const Oo=async(e,t,r)=>{r.codec||(r.codec=E),r.hasher||(r.hasher=Ce),void 0===r.cidVersion&&(r.cidVersion=1),r.codec===E&&r.hasher!==Ce&&(r.cidVersion=1);const n=await r.hasher.digest(e),a=We.create(r.cidVersion,r.codec.code,n);return r.onlyHash||await t.put(a,e,{signal:r.signal}),a};var Uo=r(52090),$o=r(34097);const jo=$o.Pv.code;async function Mo(e){return(await $o.Pv.encode(e)).subarray(0,8).reverse()}class Bo{constructor(e,t){this.options=t||{},this.root=e.root,this.dir=e.dir,this.path=e.path,this.dirty=e.dirty,this.flat=e.flat,this.parent=e.parent,this.parentKey=e.parentKey,this.unixfs=e.unixfs,this.mode=e.mode,this.mtime=e.mtime,this.cid=void 0,this.size=void 0}async put(e,t){}get(e){return Promise.resolve(this)}async*eachChildSeries(){}async*flush(e){}}class Zo extends Bo{constructor(e,t){super(e,t),this._bucket=(0,Uo.$)({hashFn:Mo,bits:8})}async put(e,t){await this._bucket.put(e,t)}get(e){return this._bucket.get(e)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:e,value:t}of this._bucket.eachLeafSeries())yield{key:e,child:t}}async*flush(e){yield*Vo(this._bucket,e,this,this.options)}}async function*Vo(e,t,r,n){const a=e._children,s=[];let i=0;for(let e=0;e<a.length;e++){const r=a.get(e);if(!r)continue;const o=e.toString(16).toUpperCase().padStart(2,"0");if(r instanceof Uo.r){let e;for await(const a of await Vo(r,t,null,n))e=a;if(!e)throw new Error("Could not flush sharded directory, no subshard found");s.push({Name:o,Tsize:e.size,Hash:e.cid}),i+=e.size}else if("function"==typeof r.value.flush){const e=r.value;let n;for await(const r of e.flush(t))n=r,yield n;const a=o+r.key;s.push({Name:a,Tsize:n.size,Hash:n.cid}),i+=n.size}else{const e=r.value;if(!e.cid)continue;const t=o+r.key,n=e.size;s.push({Name:t,Tsize:n,Hash:e.cid}),i+=n}}const o=Uint8Array.from(a.bitField().reverse()),c={Data:new v.fL({type:"hamt-sharded-directory",data:o,fanout:e.tableSize(),hashType:jo,mtime:r&&r.mtime,mode:r&&r.mode}).marshal(),Links:s},d=(0,E.encode)((0,E.prepare)(c)),l=await Oo(d,t,n),h=d.length+i;yield{cid:l,node:c,size:h}}const Ho=(0,b.kg)("ipfs:mfs:core:utils:hamt-utils"),Fo=async(e,t,r,n)=>{if(!n.parent.Data)throw new Error("Could not update HAMT directory because parent had no data");const a=Uint8Array.from(r._children.bitField().reverse()),s=v.fL.unmarshal(n.parent.Data),i=new v.fL({type:"hamt-sharded-directory",data:a,fanout:r.tableSize(),hashType:jo,mode:s.mode,mtime:s.mtime}),o=await e.hashers.getHasher(n.hashAlg),c={Data:i.marshal(),Links:t.sort(((e,t)=>(e.Name||"").localeCompare(t.Name||"")))},d=E.encode(c),l=await o.digest(d),h=We.create(n.cidVersion,E.code,l);return n.flush&&await e.repo.blocks.put(h,d),{node:c,cid:h,size:t.reduce(((e,t)=>e+(t.Tsize||0)),d.length)}},Ko=async(e,t,r,n,a)=>{const s=new Uo.r({hash:r._options.hash,bits:r._options.bits},n,a);return n._putObjectAt(a,s),await Wo(e,t,s,r),s},Go=async e=>{const t=(0,Uo.$)({hashFn:Mo,bits:8});return await Promise.all(e.map((async e=>{const r=e.Name||"";if(2===r.length){const e=parseInt(r,16),n=new Uo.r({hash:t._options.hash,bits:t._options.bits},t,e);return t._putObjectAt(e,n),Promise.resolve()}return t.put(r.substring(2),{size:e.Tsize,cid:e.Hash})}))),t},Wo=async(e,t,r,n)=>{await Promise.all(t.map((async t=>{const a=t.Name||"";if(2===a.length){Ho("Populating sub bucket",a);const s=parseInt(a,16),i=await e.repo.blocks.get(t.Hash),o=E.decode(i),c=new Uo.r({hash:n._options.hash,bits:n._options.bits},r,s);return r._putObjectAt(s,c),await Wo(e,o.Links,c,n),Promise.resolve()}return n.put(a.substring(2),{size:t.Tsize,cid:t.Hash})})))},qo=e=>e.toString(16).toUpperCase().padStart(2,"0").substring(0,2),Yo=(0,b.kg)("ipfs:mfs:core:utils:add-link");async function Xo(e,t){let r=t.parent;if(t.parentCid){const n=We.asCID(t.parentCid);if(null===n)throw _(new Error("Invalid CID passed to addLink"),"EINVALIDPARENTCID");if(n.code!==E.code)throw _(new Error("Unsupported codec. Only DAG-PB is supported"),"EINVALIDPARENTCID");Yo(`Loading parent node ${n}`);const a=await e.repo.blocks.get(n);r=E.decode(a)}if(!r)throw _(new Error("No parent node or CID passed to addLink"),"EINVALIDPARENT");if(!t.cid)throw _(new Error("No child cid passed to addLink"),"EINVALIDCHILDCID");if(!t.name)throw _(new Error("No child name passed to addLink"),"EINVALIDCHILDNAME");if(!t.size&&0!==t.size)throw _(new Error("No child size passed to addLink"),"EINVALIDCHILDSIZE");if(!r.Data)throw _(new Error("Parent node with no data passed to addLink"),"ERR_INVALID_PARENT");const n=v.fL.unmarshal(r.Data);return"hamt-sharded-directory"===n.type?(Yo("Adding link to sharded directory"),ec(e,{...t,parent:r})):r.Links.length>=t.shardSplitThreshold?(Yo("Converting directory to sharded directory"),Jo(e,{...t,parent:r,mtime:n.mtime,mode:n.mode})):(Yo(`Adding ${t.name} (${t.cid}) to regular directory`),Qo(e,{...t,parent:r}))}const Jo=async(e,t)=>{const r=await(async(e,t,r={})=>{const n=new Zo({root:!0,dir:!0,parent:void 0,parentKey:void 0,path:"",dirty:!0,flat:!1,mtime:r.mtime,mode:r.mode},r);for(let e=0;e<t.length;e++)await n._bucket.put(t[e].name,{size:t[e].size,cid:t[e].cid});const a=await(0,Yt.Z)(n.flush(e.repo.blocks));if(!a)throw new Error("Flushing shard yielded no result");return a})(e,t.parent.Links.map((e=>({name:e.Name||"",size:e.Tsize||0,cid:e.Hash}))).concat({name:t.name,size:t.size,cid:t.cid}),t);return Yo(`Converted directory to sharded directory ${r.cid}`),r},Qo=async(e,t)=>{const r=t.parent.Links.filter((e=>e.Name!==t.name));if(r.push({Name:t.name,Tsize:t.size,Hash:t.cid}),!t.parent.Data)throw _(new Error("Parent node with no data passed to addToDirectory"),"ERR_INVALID_PARENT");const n=v.fL.unmarshal(t.parent.Data);let a;if(n.mtime){const e=Date.now(),t=Math.floor(e/1e3);n.mtime={secs:t,nsecs:1e3*(e-1e3*t)},a=n.marshal()}else a=t.parent.Data;t.parent=E.prepare({Data:a,Links:r});const s=await e.hashers.getHasher(t.hashAlg),i=E.encode(t.parent),o=await s.digest(i),c=We.create(t.cidVersion,E.code,o);return t.flush&&await e.repo.blocks.put(c,i),{node:t.parent,cid:c,size:i.length}},ec=async(e,t)=>{const{shard:r,path:n}=await tc(e,t),a=await(0,Yt.Z)(r.flush(e.repo.blocks));if(!a)throw new Error("No result from flushing shard");const s=await e.repo.blocks.get(a.cid),i=E.decode(s),o=t.parent.Links.filter((e=>(e.Name||"").substring(0,2)!==n[0].prefix)),c=i.Links.find((e=>(e.Name||"").substring(0,2)===n[0].prefix));if(!c)throw new Error(`No link found with prefix ${n[0].prefix}`);return o.push(c),Fo(e,o,n[0].bucket,t)},tc=async(e,t)=>{const r={name:t.name,cid:t.cid,size:t.size};if(!t.parent.Data)throw _(new Error("Parent node with no data passed to addFileToShardedDirectory"),"ERR_INVALID_PARENT");const n=await Go(t.parent.Links),a=v.fL.unmarshal(t.parent.Data),s=new Zo({root:!0,dir:!0,parent:void 0,parentKey:void 0,path:"",dirty:!0,flat:!1,mode:a.mode},t);s._bucket=n,a.mtime&&(s.mtime={secs:Math.round(Date.now()/1e3)});const i=await n._findNewBucketAndPos(r.name),o=rc(i);o[0].node=t.parent;let c=0;for(;c<o.length;){const t=o[c];c++;const a=t.node;if(!a)throw new Error("Segment had no node");const s=a.Links.find((e=>(e.Name||"").substring(0,2)===t.prefix));if(!s){Yo(`Link ${t.prefix}${r.name} will be added`),c=o.length;break}if(s.Name===`${t.prefix}${r.name}`){Yo(`Link ${t.prefix}${r.name} will be replaced`),c=o.length;break}if((s.Name||"").length>2){Yo(`Link ${s.Name} ${s.Hash} will be replaced with a subshard`),c=o.length;break}Yo(`Found subshard ${t.prefix}`);const i=await e.repo.blocks.get(s.Hash),d=E.decode(i);if(!o[c]){Yo(`Loaded new subshard ${t.prefix}`),await Ko(e,d.Links,n,t.bucket,parseInt(t.prefix,16));const a=await n._findNewBucketAndPos(r.name);o.push({bucket:a.bucket,prefix:qo(a.pos),node:d});break}const l=o[c];await Wo(e,d.Links,l.bucket,n),l.node=d}return await s._bucket.put(r.name,{size:r.size,cid:r.cid}),{shard:s,path:o}},rc=e=>{const t=[{bucket:e.bucket,prefix:qo(e.pos)}];let r=e.bucket._parent,n=e.bucket._posAtParent;for(;r;)t.push({bucket:r,prefix:qo(n)}),n=r._posAtParent,r=r._parent;return t.reverse(),t},nc=(0,b.kg)("ipfs:mfs:utils:update-tree"),ac={shardSplitThreshold:1e3};async function sc(e,t,r){r=Object.assign({},ac,r),nc("Trail",t),t=t.slice().reverse();let n,a=0;for await(const s of e.repo.blocks.getMany(t.map((e=>e.cid)))){const i=(0,E.decode)(s),o=t[a].cid,c=t[a].name;if(a++,!n){n={cid:o,name:c,size:s.length};continue}const d=await Xo(e,{parent:i,name:n.name,cid:n.cid,size:n.size,flush:r.flush,shardSplitThreshold:r.shardSplitThreshold,hashAlg:r.hashAlg,cidVersion:r.cidVersion});n={cid:d.cid,name:c,size:d.size}}const{cid:s}=n;return nc(`Final CID ${s}`),s}const ic=(0,b.kg)("ipfs:mfs:utils:update-mfs-root");async function oc(e,t,r){if(r&&r.signal&&r.signal.aborted)throw _(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});return ic(`New MFS root will be ${t}`),await e.repo.datastore.put(jt,t.bytes),t}const cc=y.Z.bind({ignoreUndefined:!0}),dc=(0,b.kg)("ipfs:mfs:mkdir"),lc={parents:!1,hashAlg:"sha2-256",cidVersion:0,shardSplitThreshold:1e3,flush:!0};function hc(e){return(0,Ot.a)((async function(t,r={}){const n=cc(lc,r);if(!t)throw new Error("no path given to Mkdir");if("/"===(t=t.trim())){if(n.parents)return;throw _(new Error("cannot create directory '/': Already exists"),"ERR_INVALID_PATH")}if("/"!==t.substring(0,1))throw _(new Error("paths must start with a leading slash"),"ERR_INVALID_PATH");dc(`Creating ${t}`);const a=Io(t);if("ipfs"===a[0])throw _(new Error("path cannot have the prefix 'ipfs'"),"ERR_INVALID_PATH");const s=await Ao(e,n);let i;const o=[],c=await async function(e,t,r){const n=new v.fL({type:t,mode:r.mode,mtime:r.mtime}),a=await e.hashers.getHasher(r.hashAlg),s={Data:n.marshal(),Links:[]},i=E.encode(s),o=await a.digest(i),c=We.create(r.cidVersion,E.code,o);return r.flush&&await e.repo.blocks.put(c,i),{cid:c,node:s}}(e,"directory",n);for(let r=0;r<=a.length;r++){const d=a.slice(0,r),l=`/ipfs/${s}/${d.join("/")}`;try{if(i=await(0,bn.OY)(l,e.repo.blocks),"file"!==i.type&&"directory"!==i.type)throw _(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");if(r===a.length){if(n.parents)return;throw _(new Error("file already exists"),"ERR_ALREADY_EXISTS")}o.push({name:i.name,cid:i.cid})}catch(t){if("ERR_NOT_FOUND"!==t.code)throw t;if(r<a.length&&!n.parents)throw _(new Error(`Intermediate directory path ${l} does not exist, use the -p flag to create it`),"ERR_NOT_FOUND");await uc(e,d[d.length-1],c,o[o.length-1],o,n)}}const d=await sc(e,o,n);await oc(e,d,n)}))}const uc=async(e,t,r,n,a,s)=>{dc(`Adding empty dir called ${t} to ${n.cid}`);const i=await Xo(e,{parent:n.node,parentCid:n.cid,size:0,cid:r.cid,name:t,hashAlg:s.hashAlg,cidVersion:s.cidVersion,flush:s.flush,shardSplitThreshold:s.shardSplitThreshold});a[a.length-1].cid=i.cid,a.push({name:t,cid:r.cid})},pc=y.Z.bind({ignoreUndefined:!0}),fc=(0,b.kg)("ipfs:mfs:cp"),wc={parents:!1,flush:!0,hashAlg:"sha2-256",cidVersion:0,shardSplitThreshold:1e3};function gc(e){return(0,Ot.a)((async function(t,r,n={}){const a=pc(wc,n);Array.isArray(t)||(t=[t]);const s=await Promise.all(t.map((t=>So(e,t,a))));let i=await So(e,r,a);if(!s.length||!i)throw _(new Error("Please supply at least one source"),"ERR_INVALID_PARAMS");const o=s.find((e=>!e.exists));if(o)throw _(new Error(`${o.path} does not exist`),"ERR_INVALID_PARAMS");const c=yc(i);if(i.exists){if(fc("Destination exists"),1===s.length&&!c)throw _(new Error("directory already has entry by that name"),"ERR_ALREADY_EXISTS")}else if(fc("Destination does not exist"),s.length>1){if(!a.parents)throw _(new Error("destination did not exist, pass -p to create intermediate directories"),"ERR_INVALID_PARAMS");await hc(e)(i.path,a),i=await So(e,i.path,a)}else if(i.parts.length>1){const t=`/${i.parts.slice(0,-1).join("/")}`;try{await To(e)(t,a)}catch(r){if("ERR_NOT_FOUND"!==r.code)throw r;if(!a.parents)throw _(new Error("destination did not exist, pass -p to create intermediate directories"),"ERR_INVALID_PARAMS");await hc(e)(t,a),i=await So(e,i.path,a)}}const d=yc(i)?i.mfsPath:i.mfsDirectory,l=await zo(e,d);if(1===s.length){const t=s.pop();if(!t)throw _(new Error("could not find source"),"ERR_INVALID_PARAMS");const r=c?t.name:i.name;return fc(`Only one source, copying to destination ${c?"directory":"file"} ${r}`),mc(e,t,r,l,a)}return fc("Multiple sources, wrapping in a directory"),bc(e,s,i,l,a)}))}const yc=e=>e.unixfs&&e.unixfs.type&&e.unixfs.type.includes("directory"),mc=async(e,t,r,n,a)=>{let s=n.pop();if(!s)throw _(new Error("destination had no parent"),"ERR_INVALID_PARAMS");s=await _c(e,t,r,s,a),n.push(s);const i=await sc(e,n,a);await oc(e,i,a)},bc=async(e,t,r,n,a)=>{for(let n=0;n<t.length;n++){const s=t[n];r=await _c(e,s,s.name,r,a)}n[n.length-1]=r;const s=await sc(e,n,a);await oc(e,s,a)},_c=async(e,t,r,n,a)=>{const s=await e.repo.blocks.get(t.cid),{node:i,cid:o,size:c}=await Xo(e,{parentCid:n.cid,size:s.length,cid:t.cid,name:r,hashAlg:a.hashAlg,cidVersion:a.cidVersion,flush:a.flush,shardSplitThreshold:a.shardSplitThreshold});return n.node=i,n.cid=o,n.size=c,n},vc=(0,b.kg)("ipfs:mfs:core:utils:remove-link");const Ec=async(e,t)=>{t.parent.Links=t.parent.Links.filter((e=>e.Name!==t.name));const r=await E.encode(t.parent),n=await e.hashers.getHasher(t.hashAlg),a=await n.digest(r),s=We.create(t.cidVersion,E.code,a);return await e.repo.blocks.put(s,r),vc(`Updated regular directory ${s}`),{node:t.parent,cid:s}},kc=async(e,t)=>{const{rootBucket:r,path:n}=await(async(e,t,r)=>{const n=await Go(r.Links),a=await n._findNewBucketAndPos(t),s=[{bucket:a.bucket,prefix:qo(a.pos)}];let i=a.bucket;for(;i!==n;)s.push({bucket:i,prefix:qo(i._posAtParent)}),i=i._parent;s.reverse(),s[0].node=r;for(let r=0;r<s.length;r++){const a=s[r];if(!a.node)throw new Error("Could not generate HAMT path");const i=a.node.Links.filter((e=>(e.Name||"").substring(0,2)===a.prefix)).pop();if(!i){Ho(`Link ${a.prefix}${t} will be added`);continue}if(i.Name===`${a.prefix}${t}`){Ho(`Link ${a.prefix}${t} will be replaced`);continue}Ho(`Found subshard ${a.prefix}`);const o=await e.repo.blocks.get(i.Hash),c=E.decode(o);if(!s[r+1]){Ho(`Loaded new subshard ${a.prefix}`),await Ko(e,c.Links,n,a.bucket,parseInt(a.prefix,16));const r=await n._findNewBucketAndPos(t);s.push({bucket:r.bucket,prefix:qo(r.pos),node:c});continue}const d=s[r+1];await Wo(e,c.Links,d.bucket,n),d.node=c}return await n.put(t,!0),s.reverse(),{rootBucket:n,path:s}})(e,t.name,t.parent);await r.del(t.name);const{node:a}=await Rc(e,n,t.name,t);return Fo(e,a.Links,r,t)},Rc=async(e,t,r,n)=>{const a=t.pop();if(!a)throw _(new Error("Could not find parent"),"EINVALIDPARENT");const{bucket:s,prefix:i,node:o}=a;if(!o)throw _(new Error("Could not find parent"),"EINVALIDPARENT");const c=o.Links.find((e=>(e.Name||"").substring(0,2)===i));if(!c)throw _(new Error(`No link found with prefix ${i} for file ${r}`),"ERR_NOT_FOUND");if(c.Name===`${i}${r}`){vc(`Removing existing link ${c.Name}`);const t=o.Links.filter((e=>e.Name!==c.Name));return await s.del(r),Fo(e,t,s,n)}vc(`Descending into sub-shard ${c.Name} for ${i}${r}`);const d=await Rc(e,t,r,n);let l=d.cid,h=d.size,u=i;if(1===d.node.Links.length){vc(`Removing subshard for ${i}`);const e=d.node.Links[0];u=`${i}${(e.Name||"").substring(2)}`,l=e.Hash,h=e.Tsize||0}return vc(`Updating shard ${i} with name ${u}`),Ac(e,s,o,i,u,h,l,n)},Ac=(e,t,r,n,a,s,i,o)=>{const c=r.Links.filter((e=>e.Name!==n));return c.push({Name:a,Tsize:s,Hash:i}),Fo(e,c,t,o)},Ic=y.Z.bind({ignoreUndefined:!0}),xc={recursive:!1,cidVersion:0,hashAlg:"sha2-256",flush:!0,shardSplitThreshold:1e3};function Sc(e){return(0,Ot.a)((async function(t,r={}){const n=Ic(xc,r);Array.isArray(t)||(t=[t]);const a=await Promise.all(t.map((t=>So(e,t,n))));if(!a.length)throw _(new Error("Please supply at least one path to remove"),"ERR_INVALID_PARAMS");a.forEach((e=>{if("/"===e.path)throw _(new Error("Cannot delete root"),"ERR_INVALID_PARAMS")}));for(const t of a)await Nc(e,t.path,n)}))}const Nc=async(e,t,r)=>{const n=await So(e,t,r),a=await zo(e,n.mfsPath),s=a[a.length-1];a.pop();const i=a[a.length-1];if(!i)throw _(new Error(`${t} does not exist`),"ERR_NOT_FOUND");if("directory"===s.type&&!r.recursive)throw _(new Error(`${t} is a directory, use -r to remove directories`),"ERR_WAS_DIR");const{cid:o}=await async function(e,t){let r=t.parent;if(t.parentCid){const n=We.asCID(t.parentCid);if(null===n)throw _(new Error("Invalid CID passed to removeLink"),"EINVALIDPARENTCID");vc(`Loading parent node ${n}`);const a=await e.repo.blocks.get(n);r=E.decode(a)}if(!r)throw _(new Error("No parent node or CID passed to removeLink"),"EINVALIDPARENT");if(!t.name)throw _(new Error("No child name passed to removeLink"),"EINVALIDCHILDNAME");if(!r.Data)throw _(new Error("Parent node had no data"),"ERR_INVALID_NODE");return"hamt-sharded-directory"===v.fL.unmarshal(r.Data).type?(vc(`Removing ${t.name} from sharded directory`),kc(e,{...t,parent:r})):(vc(`Removing link ${t.name} regular directory`),Ec(e,{...t,parent:r}))}(e,{parentCid:i.cid,name:s.name,hashAlg:r.hashAlg,cidVersion:r.cidVersion,flush:r.flush,shardSplitThreshold:r.shardSplitThreshold});i.cid=o;const c=await sc(e,a,r);await oc(e,c,r)},Pc=y.Z.bind({ignoreUndefined:!0}),Dc=(0,b.kg)("ipfs:mfs:touch"),Tc={flush:!0,shardSplitThreshold:1e3,hashAlg:"sha2-256",cidVersion:0,recursive:!1};function Lc(e,t,r){t||(t=0);const n=e.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);if(!n)throw new Error(`Invalid file mode: ${e}`);let[,a,s,i]=n;"a"!==a&&a||(a="ugo");let o=function(e,t,r){let n=0;return(e.includes("x")||e.includes("X")&&(r||1&t||8&t||64&t))&&(n+=1),e.includes("w")&&(n+=2),e.includes("r")&&(n+=4),n}(i,t,r);return o=function(e,t){let r=0;return e.includes("u")&&(r+=t<<6),e.includes("g")&&(r+=t<<3),e.includes("o")&&(r+=t),r}(a,o),o=function(e,t,r){return t.includes("t")&&(r+=parseInt("1000",8)),t.includes("s")&&(e.includes("u")&&(r+=parseInt("4000",8)),e.includes("g")&&(r+=parseInt("2000",8))),r}(a,i,o),"="===s?(a.includes("u")&&(t&=parseInt("7077",8),t|=o),a.includes("g")&&(t&=parseInt("7707",8),t|=o),a.includes("o")&&(t&=parseInt("7770",8),t|=o),t):"+"===s?o|t:"-"===s?o^t:t}function Cc(e,t){if(e instanceof String||"string"==typeof e){const r=`${e}`;e=r.match(/^\d+$/g)?parseInt(r,8):0+r.split(",").reduce(((e,r)=>Lc(r,e,t.isDirectory())),t.mode||0)}return e}const zc=y.Z.bind({ignoreUndefined:!0}),Oc={};const Uc=y.Z.bind({ignoreUndefined:!0}),$c={parents:!1,flush:!0,cidVersion:0,hashAlg:"sha2-256",shardSplitThreshold:1e3};const jc=y.Z.bind({ignoreUndefined:!0}),Mc=(0,b.kg)("ipfs:mfs:touch"),Bc={flush:!0,shardSplitThreshold:1e3,cidVersion:0,hashAlg:"sha2-256"};const Zc=y.Z.bind({ignoreUndefined:!0}),Vc={offset:0,length:1/0};const Hc=(0,b.kg)("ipfs:mfs:utils:to-async-iterator");const Fc=y.Z.bind({ignoreUndefined:!0}),Kc=(0,b.kg)("ipfs:mfs:write"),Gc={offset:0,length:1/0,create:!1,truncate:!1,rawLeaves:!1,reduceSingleLeafToSelf:!1,cidVersion:0,hashAlg:"sha2-256",parents:!1,progress:(e,t)=>{},strategy:"trickle",flush:!0,leafType:"raw",shardSplitThreshold:1e3};const Wc=async(e,t,r,n,a)=>{const s=await qc(e,r,n,a);await ko().writeLock((async()=>{const r=Io(t),n=r.pop();if(null==n)throw _(new Error("source does not exist"),"ERR_NO_EXIST");let i=!1;try{await To(e)(`/${r.join("/")}`,a),i=!0}catch(e){if("ERR_NOT_FOUND"!==e.code)throw e}i||await hc(e)(`/${r.join("/")}`,a);const o=await So(e,t,a),c=await zo(e,o.mfsDirectory),d=c[c.length-1];if(!d)throw _(new Error("directory does not exist"),"ERR_NO_EXIST");if(!d.type||!d.type.includes("directory"))throw _(new Error(`cannot write to ${d.name}: Not a directory`),"ERR_NOT_A_DIRECTORY");const l=await e.repo.blocks.get(d.cid),h=(0,E.decode)(l),u=await Xo(e,{parent:h,name:n,cid:s.cid,size:s.size,flush:a.flush,shardSplitThreshold:a.shardSplitThreshold,hashAlg:a.hashAlg,cidVersion:a.cidVersion});d.cid=u.cid;const p=await sc(e,c,a);await oc(e,p,a)}))()},qc=async(e,t,r,n)=>{r.exists?Kc(`Overwriting file ${r.cid} offset ${n.offset} length ${n.length}`):Kc(`Writing file offset ${n.offset} length ${n.length}`);const a=[];if(n.offset>0)if(r.unixfs){if(Kc(`Writing first ${n.offset} bytes of original file`),a.push((()=>r.content({offset:0,length:n.offset}))),r.unixfs.fileSize()<n.offset){const e=n.offset-r.unixfs.fileSize();Kc(`Writing zeros for extra ${e} bytes`),a.push(Xc(e))}}else Kc(`Writing zeros for first ${n.offset} bytes`),a.push(Xc(n.offset));a.push(Yc(t,n.length));const s=Qc(Jc(a),(e=>{if(r.unixfs&&!n.truncate){const t=r.unixfs.fileSize();if(t>e)return Kc(`Writing last ${t-e} of ${t} bytes from original file starting at offset ${e}`),r.content({offset:e});Kc("Not writing last bytes from original file")}return{[Symbol.asyncIterator]:async function*(){}}}));let i,o;void 0!==n.mode&&null!==n.mode?i=(0,v.tK)(n.mode):r&&r.unixfs&&(i=r.unixfs.mode),null!=n.mtime?o=(0,v.Xu)(n.mtime):r&&r.unixfs&&(o=r.unixfs.mtime);const c=await e.hashers.getHasher(n.hashAlg),d=await(0,Yt.Z)((0,pn.Z)([{content:s,mode:i,mtime:o}],e.repo.blocks,{progress:n.progress,hasher:c,cidVersion:n.cidVersion,strategy:n.strategy,rawLeaves:n.rawLeaves,reduceSingleLeafToSelf:n.reduceSingleLeafToSelf,leafType:n.leafType}));if(!d)throw _(new Error(`cannot write to ${parent.name}`),"ERR_COULD_NOT_WRITE");return Kc(`Wrote ${d.cid}`),{cid:d.cid,size:d.size}},Yc=(e,t)=>async function*(){let r=0;for await(const n of e){if(r+=n.length,r>t)return void(yield n.subarray(0,t-r));yield n}},Xc=(e,t=262144)=>{const r=new Uint8Array(t);return Yc(async function*(){for(;;)yield r}(),e)},Jc=async function*(e){for(let t=0;t<e.length;t++)yield*e[t]()},Qc=async function*(e,t){let r=0;for await(const t of e)r+=t.length,yield t;for await(const e of t(r))r+=e.length,yield e},ed=e=>{const t={cid:e.cid,name:e.name,type:"directory"===e.type?"directory":"file",size:e.size};return"file"!==e.type&&"directory"!==e.type||(t.mode=e.unixfs.mode,t.mtime=e.unixfs.mtime),t};const td={stat:To},rd={chmod:function(e){return(0,Ot.a)((async function(t,r,n={}){const a=Pc(Tc,n);Dc(`Fetching stats for ${t}`);const{cid:s,mfsDirectory:i,name:o}=await So(e,t,a);if(s.code!==E.code)throw _(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");if(a.recursive){const n=await(0,dn.zG)((async function*(){for await(const n of(0,bn.BE)(s,e.repo.blocks)){if("file"!==n.type&&"directory"!==n.type)throw _(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");n.unixfs.mode=Cc(r,n.unixfs);const e=E.prepare({Data:n.unixfs.marshal(),Links:n.node.Links});yield{path:n.path,content:e}}}),(t=>(0,pn.Z)(t,e.repo.blocks,{...a,pin:!1,dagBuilder:async function*(e,t,r){for await(const n of e)yield async function(){const e=n.content,a=E.encode(e),s=await Oo(a,t,r);if(!e.Data)throw _(new Error(`${s} had no data`),"ERR_INVALID_NODE");const i=v.fL.unmarshal(e.Data);return{cid:s,size:a.length,path:n.path,unixfs:i}}}})),(e=>(0,Yt.Z)(e)));if(!n)throw _(new Error(`Could not chmod ${t}`),"ERR_COULD_NOT_CHMOD");return await Sc(e)(t,a),void await gc(e)(`/ipfs/${n.cid}`,t,a)}const c=await e.repo.blocks.get(s),d=E.decode(c);if(!d.Data)throw _(new Error(`${s} had no data`),"ERR_INVALID_NODE");const l=v.fL.unmarshal(d.Data);l.mode=Cc(r,l);const h=E.encode({Data:l.marshal(),Links:d.Links}),u=a.hashAlg||Tc.hashAlg,p=await e.hashers.getHasher(u),f=await p.digest(h),w=We.create(a.cidVersion,E.code,f);a.flush&&await e.repo.blocks.put(w,h);const g=await zo(e,i),y=g[g.length-1],m=We.decode(y.cid.bytes),b=await e.repo.blocks.get(m),k=E.decode(b),R=await Xo(e,{parent:k,name:o,cid:w,size:h.length,flush:a.flush,hashAlg:u,cidVersion:s.version,shardSplitThreshold:1/0});y.cid=R.cid;const A=await sc(e,g,a);await oc(e,A,a)}))},cp:gc,flush:function(e){return(0,Ot.a)((async function(t,r={}){r=zc(Oc,r);const{cid:n}=await To(e)(t,r);return n}))},mkdir:hc,mv:function(e){return(0,Ot.a)((async function(t,r,n={}){const a=Uc($c,n);await gc(e)(t,r,a),await Sc(e)(t,{...a,recursive:!0})}))},rm:Sc,touch:function(e){return(0,Ot.a)((async function(t,r={}){const n=jc(Bc,r);n.mtime=n.mtime||new Date,Mc(`Touching ${t} mtime: ${n.mtime}`);const{cid:a,mfsDirectory:s,name:i,exists:o}=await So(e,t,n),c=r.hashAlg||Bc.hashAlg,d=await e.hashers.getHasher(c);let l,h,u=n.cidVersion;if(o){if(a.code!==E.code)throw _(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");u=a.version;const r=await e.repo.blocks.get(a),s=E.decode(r);if(!s.Data)throw _(new Error(`${t} had no data`),"ERR_INVALID_NODE");const i=v.fL.unmarshal(s.Data);i.mtime=n.mtime,l=E.encode({Data:i.marshal(),Links:s.Links});const o=await d.digest(l);h=We.create(n.cidVersion,E.code,o),n.flush&&await e.repo.blocks.put(h,l)}else{const t=new v.fL({type:"file",mtime:n.mtime});l=E.encode({Data:t.marshal(),Links:[]});const r=await d.digest(l);h=We.create(n.cidVersion,E.code,r),n.flush&&await e.repo.blocks.put(h,l)}const p=await zo(e,s),f=p[p.length-1],w=f.cid,g=await e.repo.blocks.get(w),y=E.decode(g),m=await Xo(e,{parent:y,name:i,cid:h,size:l.length,flush:n.flush,shardSplitThreshold:n.shardSplitThreshold,hashAlg:n.hashAlg,cidVersion:u});f.cid=m.cid;const b=await sc(e,p,n);await oc(e,b,n)}))}},nd={write:function(e){return(0,Ot.a)((async function(t,r,n={}){const a=Fc(Gc,n);let s,i,o;if(Kc("Reading source, destination and parent"),await ko().readLock((async()=>{s=await function(e){if(!e)throw _(new Error("paths must start with a leading slash"),"ERR_INVALID_PATH");if(("string"==typeof e||e instanceof String)&&(Hc("Content was a string"),e=bt(e.toString())),e.length)return Hc("Content was array-like"),{[Symbol.asyncIterator]:function*(){yield e}};if(e[Symbol.asyncIterator])return Hc("Content was an async iterator"),e;if(e[Symbol.iterator])return Hc("Content was an iterator"),e;if(window.Blob&&e instanceof window.Blob){Hc("Content was an HTML5 Blob");let t=0;const r={next:()=>t>e.size?{done:!0}:new Promise(((r,n)=>{const a=e.slice(t,Mt);t+=Mt;const s=new window.FileReader,i=e=>{if(s.removeEventListener("loadend",i,!1),e.error)return n(e.error);r({done:!1,value:new Uint8Array(s.result)})};s.addEventListener("loadend",i),s.readAsArrayBuffer(a)}))};return{[Symbol.asyncIterator]:()=>r}}throw _(new Error(`Don't know how to convert ${e} into an async iterator`),"ERR_INVALID_PARAMS")}(r),i=await So(e,t,a),o=await So(e,i.mfsDirectory,a)}))(),Kc("Read source, destination and parent"),!a.parents&&!o.exists)throw _(new Error("directory does not exist"),"ERR_NO_EXIST");if(null==s)throw _(new Error("could not create source"),"ERR_NO_SOURCE");if(null==i)throw _(new Error("could not create destination"),"ERR_NO_DESTINATION");if(!a.create&&!i.exists)throw _(new Error("file does not exist"),"ERR_NO_EXIST");if("file"!==i.entryType)throw _(new Error("not a file"),"ERR_NOT_A_FILE");return Wc(e,t,s,i,a)}))},read:function(e){return(0,Ot.a)((function(t,r={}){return r=Zc(Vc,r),{[Symbol.asyncIterator]:async function*(){const n=await So(e,t,r),a=await(0,bn.OY)(n.mfsPath,e.repo.blocks);if("file"!==a.type)throw _(new Error(`${t} was not a file`),"ERR_NOT_FILE");if(!a.content)throw _(new Error(`Could not load content stream from ${t}`),"ERR_NO_CONTENT");for await(const e of a.content({offset:r.offset,length:r.length}))yield e}}}))},ls:function(e){return(0,Ot.a)((async function*(t,r={}){const n=await So(e,t,r),a=await(0,bn.OY)(n.mfsPath,e.repo.blocks);"directory"!==a.type?yield ed(a):yield*(0,on.Z)(a.content(r),ed)}))}},ad=({options:e,mfs:t,operations:r,lock:n})=>{Object.keys(r).forEach((a=>{t[a]=n(r[a](e))}))},sd={repoOwner:!0,repo:null};function id({repo:e,preload:t,hashers:r,options:n}){const a=function(e){const{repoOwner:t}=Object.assign({},sd||{},e),r=ko(t),n={};return ad({options:e,mfs:n,operations:td,lock:e=>r.readLock(e)}),ad({options:e,mfs:n,operations:rd,lock:e=>r.writeLock(e)}),Object.keys(nd).forEach((t=>{n[t]=nd[t](e)})),n}({repo:e,repoOwner:!1!==n.repoOwner,hashers:r}),s=e=>(...r)=>{const n=r.filter((e=>Nt(e,At)||St(e)));if(n.length){const e=r[r.length-1];e&&!1!==e.preload&&n.forEach((e=>t(e)))}return e(...r)};return{...a,chmod:a.chmod,cp:s(a.cp),mkdir:a.mkdir,stat:s(a.stat),rm:a.rm,read:s(a.read),touch:a.touch,write:a.write,mv:s(a.mv),flush:a.flush,ls:s((async function*(...e){for await(const t of a.ls(...e))yield{...t,size:t.size||0}}))}}const od="Ed25519";class cd{constructor({keychain:e}){this.gen=function({keychain:e}){return(0,Ot.a)(((t,r={type:od,size:2048})=>e.createKey(t,r.type||od,r.size||2048)))}({keychain:e}),this.list=function({keychain:e}){return(0,Ot.a)((()=>e.listKeys()))}({keychain:e}),this.rm=function({keychain:e}){return(0,Ot.a)((t=>e.removeKey(t)))}({keychain:e}),this.rename=function({keychain:e}){return(0,Ot.a)((async(t,r)=>{const n=await e.renameKey(t,r);return{was:t,now:n.name,id:n.id,overwrite:!1}}))}({keychain:e}),this.export=function({keychain:e}){return(0,Ot.a)(((t,r)=>e.exportKey(t,r)))}({keychain:e}),this.import=function({keychain:e}){return(0,Ot.a)(((t,r,n)=>e.importKey(t,r,n)))}({keychain:e}),this.info=function({keychain:e}){return(0,Ot.a)((t=>e.findKeyByName(t)))}({keychain:e})}}function dd({repo:e,preload:t}){return(0,Ot.a)((async function(r,n={}){!1!==n.preload&&t(r);const a=await e.blocks.get(r,n);return E.decode(a)}))}function ld(e,t=[]){for(const r in e){const n=e[r];if("/"===r&&1===Object.keys(e).length)try{t.push({Name:"",Tsize:0,Hash:We.parse(n)});continue}catch(e){}const a=We.asCID(n);a?t.push({Name:"",Tsize:0,Hash:a}):(Array.isArray(n)&&ld(n,t),n&&"object"==typeof n&&ld(n,t))}return t}function hd({repo:e,codecs:t}){return(0,Ot.a)((async function(r,n={}){const a=await t.getCodec(r.code),s=await e.blocks.get(r,n),i=a.decode(s);switch(r.code){case Ue:return[];case E.code:return i.Links;case k.code:case R.code:return ld(i);default:throw new Error(`Cannot resolve links from codec ${r.code}`)}}))}function ud({repo:e,preload:t}){return(0,Ot.a)((async function(r,n={}){const a=await e.gcLock.readLock();try{const s=E.encode(r),i=await Ce.digest(s),o=We.createV1(E.code,i);return await e.blocks.put(o,s,{signal:n.signal}),!1!==n.preload&&t(o),n.pin&&await e.pins.pinRecursively(o,{signal:n.signal}),o}finally{a()}}))}class pd{constructor({repo:e,preload:t}){this.addLink=function({repo:e,preload:t}){const r=dd({repo:e,preload:t}),n=ud({repo:e,preload:t});return(0,Ot.a)((async function(e,t,a={}){const s=await r(e,a);return n({...s,Links:s.Links.concat([t])},a)}))}({repo:e,preload:t}),this.appendData=function({repo:e,preload:t}){const r=dd({repo:e,preload:t}),n=ud({repo:e,preload:t});return(0,Ot.a)((async function(e,t,a={}){const s=await r(e,a),i=hr([s.Data||[],t]);return n({...s,Data:i},a)}))}({repo:e,preload:t}),this.rmLink=function({repo:e,preload:t}){const r=dd({repo:e,preload:t}),n=ud({repo:e,preload:t});return(0,Ot.a)((async function(e,t,a={}){const s=await r(e,a),i=("string"==typeof t?t:t.Name)||"";return s.Links=s.Links.filter((e=>e.Name!==i)),n(s,a)}))}({repo:e,preload:t}),this.setData=function({repo:e,preload:t}){const r=dd({repo:e,preload:t}),n=ud({repo:e,preload:t});return(0,Ot.a)((async function(e,t,a={}){const s=await r(e,a);return n({...s,Data:t},a)}))}({repo:e,preload:t})}}class fd{constructor({repo:e,codecs:t,preload:r}){this.data=function({repo:e,preload:t}){const r=dd({repo:e,preload:t});return(0,Ot.a)((async function(e,t={}){return(await r(e,t)).Data||new Uint8Array(0)}))}({repo:e,preload:r}),this.get=dd({repo:e,preload:r}),this.links=hd({repo:e,codecs:t}),this.new=function({repo:e,preload:t}){return(0,Ot.a)((async function(r={}){let n;if(r.template){if("unixfs-dir"!==r.template)throw new Error("unknown template");n=new v.fL({type:"directory"}).marshal()}const a=E.encode({Data:n,Links:[]}),s=await Ce.digest(a),i=We.createV0(s);return await e.blocks.put(i,a,{signal:r.signal}),!1!==r.preload&&t(i),i}))}({repo:e,preload:r}),this.put=ud({repo:e,preload:r}),this.stat=function({repo:e,preload:t}){const r=dd({repo:e,preload:t});return(0,Ot.a)((async function(e,t={}){const n=await r(e,t),a=E.encode(n).length,s=n.Links.reduce(((e,t)=>e+(t.Tsize||0)),0);return{Hash:e,NumLinks:n.Links.length,BlockSize:a,LinksSize:a-(n.Data||[]).length,DataSize:(n.Data||[]).length,CumulativeSize:a+s}}))}({repo:e,preload:r}),this.patch=new pd({repo:e,preload:r})}}const wd=(0,b.kg)("ipfs:repo:gc");function gd({repo:e}){return(0,Ot.a)((async function(t={}){const r=await e.stat();return{numObjects:BigInt(r.numObjects.toString()),repoSize:BigInt(r.repoSize.toString()),repoPath:r.repoPath,version:`${r.version}`,storageMax:BigInt(r.storageMax.toString())}}))}var yd=r(45895);class md{constructor({repo:e,hashers:t}){this.gc=function({repo:e,hashers:t}){return(0,Ot.a)((async function*(r={}){const n=Date.now();let a;try{a=await Ao({repo:e,hashers:t},r),await e.pins.pinRecursively(a),yield*e.gc()}finally{a&&await e.pins.unpin(a)}wd(`Complete (${Date.now()-n}ms)`)}))}({repo:e,hashers:t}),this.stat=gd({repo:e}),this.version=function({repo:e}){return(0,Ot.a)((async function(t={}){try{await e._checkInitialized(t)}catch(e){if([/Key not found in database \[\/version\]/,/ENOENT/,/repo is not initialized yet/].some((t=>t.test(e.message))))return yd._;throw e}return e.version.get()}))}({repo:e}),this.setApiAddr=t=>e.apiAddr.set(t)}}function bd(e,t){let r;if(r=e.metrics?t.peer?e.metrics.forPeer(t.peer):t.proto?e.metrics.forProtocol(t.proto):e.metrics.getGlobal():void 0,!r)return{totalIn:BigInt(0),totalOut:BigInt(0),rateIn:0,rateOut:0};const n=r.getMovingAverages(),a=r.getSnapshot();return{totalIn:a.dataReceived,totalOut:a.dataSent,rateIn:n.dataReceived[6e4].movingAverage/60,rateOut:n.dataSent[6e4].movingAverage/60}}class _d{constructor({repo:e,network:t}){this.repo=gd({repo:e}),this.bw=function({network:e}){return(0,Ot.a)((async function*(t={}){const{libp2p:r}=await e.use(t);if(!t.poll)return void(yield bd(r,t));const n=t.interval||1e3;let a,s=-1;try{if(s="string"==typeof n?(0,Cr.Z)(n)||-1:n,!s||s<0)throw new Error("invalid duration")}catch(e){throw _(e,"ERR_INVALID_POLL_INTERVAL")}try{for(;;)yield bd(r,t),await new Promise((e=>{a=setTimeout(e,s)}))}finally{clearTimeout(a)}}))}({network:t}),this.bitswap=en({network:t})}}var vd=r(37730),Ed=r(35719),kd=r(77395),Rd=r(35505),Ad=r(77474),Id=r(43980),xd=r(15029),Sd=r(66756),Nd=r(43323),Pd=r(61979),Dd=r(48310),Td=r(92912);const Ld=y.Z.bind({ignoreUndefined:!0,concatArrays:!0});function Cd({options:e={},peerId:t,multiaddrs:r=[],repo:n,keychainConfig:a={},config:s={}}){const{datastore:i}=n,o=function({options:e,config:t,datastore:r,keychainConfig:n,peerId:a,multiaddrs:s}){const i=()=>{const e=vr(t,"Pubsub.Router")||"gossipsub",r=(0,Ed.M)();if(!r[e])throw _(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${e} router.`),"ERR_NOT_SUPPORTED");return r[e]},o={datastore:r,peerId:a},c={addresses:{listen:s.map((e=>e.toString())),announce:vr(e,"addresses.announce",vr(t,"Addresses.Announce",[])),noAnnounce:vr(e,"addresses.noAnnounce",vr(t,"Addresses.NoAnnounce",[]))},connectionManager:vr(e,"connectionManager",{maxConnections:vr(e,"config.Swarm.ConnMgr.HighWater",vr(t,"Swarm.ConnMgr.HighWater")),minConnections:vr(e,"config.Swarm.ConnMgr.LowWater",vr(t,"Swarm.ConnMgr.LowWater"))}),keychain:n,identify:{host:{agentVersion:"js-ipfs/0.17.0"}},contentRouters:[],peerRouters:[],peerDiscovery:[],transports:[],streamMuxers:[(0,Dd.R)({maxInboundStreams:256,maxOutboundStreams:1024})],connectionEncryption:[(0,Td.t)()],relay:{enabled:vr(e,"relay.enabled",vr(t,"relay.enabled",!0)),hop:{enabled:vr(e,"relay.hop.enabled",vr(t,"relay.hop.enabled",!1)),active:vr(e,"relay.hop.active",vr(t,"relay.hop.active",!1))}},nat:{enabled:!vr(t,"Swarm.DisableNatPortMap",!1)}};vr(e,"config.Pubsub.Enabled",vr(t,"Pubsub.Enabled",!0))&&(c.pubsub=i());"none"!==vr(t,"Routing.Type","dhtclient")&&(c.dht=(0,Sd.p)({clientMode:"dhtserver"!==vr(t,"Routing.Type","dht"),kBucketSize:vr(e,"dht.kBucketSize",20),validators:{ipns:ur.A},selectors:{ipns:Er.e}}));const d=vr(e,"config.Bootstrap",vr(t,"Bootstrap",[]));d.length>0&&c.peerDiscovery?.push((0,Nd.U)({list:d}));let l=vr(e,"libp2p",void 0);"function"==typeof l&&(l=void 0);const h=Ld(o,(0,Id.s)(),c,l),u=vr(e,"config.Addresses.Delegates",vr(t,"Addresses.Delegates",[]));if(u.length>0){const e=u[Math.floor(Math.random()*u.length)],t=(0,vt.HM)(e).toOptions(),r={host:t.host,protocol:443===parseInt(t.port)?"https":"http",port:t.port},n=(0,Ad.Ue)(r);h.contentRouters?.push((0,Rd.OP)(n)),h.peerRouters?.push((0,kd.e8)(n))}vr(e,"config.Discovery.MDNS.Enabled",vr(t,"Discovery.MDNS.Enabled",!0))||(h.peerDiscovery=h.peerDiscovery?.filter((e=>{try{if("function"==typeof e)return"@libp2p/mdns"!==e({})[Symbol.toStringTag]}catch{}return!0})));null==h.transports&&(h.transports=[]);null==h.transports.find((e=>{try{if("function"==typeof e)return"@libp2p/websockets"===e({})[Symbol.toStringTag]}catch{}return!1}))&&h.transports.push((0,Pd.E)());return h}({options:e,config:s,datastore:i,keychainConfig:a,peerId:t,multiaddrs:r});return"function"==typeof e.libp2p?e.libp2p({libp2pOptions:o,options:e,config:s,datastore:i,peerId:t}):(0,xd.N)(o)}var zd=r(68919),Od=r(34361);const Ud=y.Z.bind({ignoreUndefined:!0}),$d=(0,b.kg)("ipfs:components:peer:storage");class jd{constructor(e,t,r,n,a){this.print=n,this.peerId=e,this.keychain=t,this.repo=r,this.print=n,this.isNew=a}static async start(e,t,r){const{repoAutoMigrate:n,repo:a,onMigrationProgress:s}=r,i="string"==typeof a||null==a?(0,vd.x)(e,t,{path:a,autoMigrate:n,onMigrationProgress:s}):a,{peerId:o,keychain:c,isNew:d}=await Md(e,i,r);return new jd(o,c,i,e,d)}}const Md=async(e,t,r)=>{if(!t.closed)return{...await Fd(t,r),isNew:!1};try{return await t.open(),{...await Fd(t,r),isNew:!1}}catch(n){if(n.code!==zd.uF)throw n;if(r.init&&!1===r.init.allowNew)throw new ut("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");return{...await Bd(e,t,r),isNew:!0}}},Bd=async(e,t,r)=>{const n=r.init||{},a=await t.exists();if($d("repo exists?",a),!0===a)throw new Error("repo already exists");const s=n.privateKey?await Zd(n.privateKey):await Vd(e,n),i=Hd(s);$d("peer identity: %s",i.PeerID);const o={...Ud(Gd((0,nn.Z)(),n.profiles),r.config),Identity:i};await t.init(o),await t.open(),$d("repo opened");const c={pass:r.pass};try{c.dek=await t.config.get("Keychain.DEK")}catch(e){if("ERR_NOT_FOUND"!==e.code)throw e}const d=await Cd({options:void 0,multiaddrs:void 0,peerId:s,repo:t,config:o,keychainConfig:c});return await t.datastore.has(new zt.s("/info/self"))||await d.keychain.importPeer("self",s),await t.config.set("Keychain",{DEK:d.keychain.init.dek}),{peerId:s,keychain:d.keychain}},Zd=async e=>{if($d("using user-supplied private-key"),(0,tr.I)(e))return e;const t=bt(e,"base64pad"),r=await(0,cr.unmarshalPrivateKey)(t);return await(0,Wt.y5)(r.public.bytes,r.bytes)},Vd=(e,{algorithm:t="Ed25519",bits:r=2048})=>{if(e("generating %s keypair...",t),"Ed25519"===t)return(0,Od.n9)();if("RSA"===t)return(0,Od.W$)({bits:r});throw _(new Error("Unknown PeerId algorithm"),"ERR_UNKNOWN_PEER_ID_ALGORITHM")},Hd=e=>{if(null==e.privateKey)throw _(new Error("Private key missing"),"ERR_MISSING_PRIVATE_KEY");return{PeerID:e.toString(),PrivKey:Rt(e.privateKey,"base64pad")}},Fd=async(e,t)=>{const r=t.config,n=t.init&&t.init.profiles||[],a=t.pass,s=await e.config.getAll(),i=Kd(Gd(s,n),r);if(s!==i&&await e.config.replace(i),!i.Identity||!i.Identity.PrivKey)throw new it("No private key was found in the config, please intialize the repo");const o=bt(i.Identity.PrivKey,"base64pad"),c=await(0,cr.unmarshalPrivateKey)(o),d=await(0,Wt.y5)(c.public.bytes,c.bytes);return{peerId:d,keychain:(await Cd({options:void 0,multiaddrs:void 0,peerId:d,repo:e,config:i,keychainConfig:{pass:a,...i.Keychain}})).keychain}},Kd=(e,t)=>t?Ud(e,t):e,Gd=(e,t)=>(t||[]).reduce(((e,t)=>{const r=Wi[t];if(!r)throw new Error(`Could not find profile with name '${t}'`);return $d("applying profile %s",t),r.transform(e)}),e);var Wd=r(99806),qd=r(6908),Yd=r(52019),Xd=r(37430);class Jd extends qd.Ed{constructor(e,t){super(),this.child=e,this.bitswap=t}open(){return this.child.open()}close(){return this.child.close()}unwrap(){return this.child}async put(e,t,r={}){await this.has(e)||(this.bitswap.isStarted()?await this.bitswap.put(e,t,r):await this.child.put(e,t,r))}async*putMany(e,t={}){const r=(0,cn.Z)(e,(async({key:e})=>!await this.has(e)));this.bitswap.isStarted()?yield*this.bitswap.putMany(r,t):yield*this.child.putMany(r,t)}async get(e,t={}){return!await this.has(e)&&this.bitswap.isStarted()?this.bitswap.get(e,t):this.child.get(e,t)}async*getMany(e,t={}){const r=(0,Xd.d)({objectMode:!0}),n=(0,Xd.d)({objectMode:!0});Promise.resolve().then((async()=>{for await(const t of e)!await this.has(t)&&this.bitswap.isStarted()?r.push(t):n.push(t);r.end(),n.end()})),yield*(0,Yd.Z)(this.bitswap.getMany(r,t),this.child.getMany(n,t))}async delete(e,t){await this.child.delete(e,t)}async*deleteMany(e,t){yield*this.child.deleteMany(e,t)}async has(e,t={}){return this.child.has(e,t)}async*query(e,t={}){yield*this.child.query(e,t)}async*queryKeys(e,t={}){yield*this.child.queryKeys(e,t)}}class Qd{constructor(e,t,r,n,a){this.peerId=e,this.libp2p=t,this.bitswap=r,this.repo=n,this.blockstore=a}static async start({peerId:e,repo:t,print:r,hashers:n,options:a}){t.closed&&await t.open();const s=await t.config.getAll(),i=await Cd({options:a,repo:t,peerId:e,multiaddrs:el(e,s),config:s,keychainConfig:void 0});await i.start();for(const e of i.getMultiaddrs())r(`Swarm listening on ${e.toString()}`);const o=(0,Wd.n)(i,t.blocks,{statsEnabled:!0,hashLoader:n,maxInboundStreams:1024,maxOutboundStreams:1024});await o.start();const c=new Jd(t.blocks,o);return t.blocks=c,t.pins.blockstore=c,new Qd(e,i,o,t,c)}static async stop(e){e.repo.blocks=e.blockstore.unwrap(),e.repo.pins.blockstore=e.blockstore.unwrap(),await e.bitswap.stop(),await e.libp2p.stop()}}const el=(e,t)=>{const r=e.toString(),n=[],a=t.Addresses&&t.Addresses.Swarm||[];for(const e of a){let t=(0,vt.HM)(e);if(t.protoCodes().includes(tl))throw _(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"),"ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");const a=t.getPeerId();a&&a!==r&&(t=t.encapsulate(`/p2p/${r}`)),n.push(t)}return n},tl=479;class rl{constructor({network:e}){this.addrs=function({network:e}){return(0,Ot.a)((async function(t={}){const r=[],{libp2p:n}=await e.use(t);return await n.peerStore.forEach((e=>{r.push({id:e.id,addrs:e.addresses.map((e=>e.multiaddr))})})),r}))}({network:e}),this.connect=function({network:e}){return(0,Ot.a)((async function(t,r={}){const{libp2p:n}=await e.use(r);await n.dial(t,r)}))}({network:e}),this.disconnect=function({network:e}){return(0,Ot.a)((async function(t,r={}){const{libp2p:n}=await e.use(r);await n.hangUp(t)}))}({network:e}),this.localAddrs=function({network:e}){return(0,Ot.a)((async function(t={}){const{libp2p:r}=await e.use(t);return r.getMultiaddrs()}))}({network:e}),this.peers=function({network:e}){return(0,Ot.a)((async function(t={}){const{libp2p:r}=await e.use(t);if(t.verbose){const e=[];for(const n of r.getConnections()){const r={addr:n.remoteAddr,peer:n.remotePeer};(t.verbose||t.direction)&&(r.direction=n.stat.direction),t.verbose&&(r.muxer=n.stat.multiplexer,r.latency="n/a",r.streams=[]),e.push(r)}return e}const n=new Map;for(const e of r.getConnections()){const t={addr:e.remoteAddr,peer:e.remotePeer};n.set(e.remotePeer.toString(),t)}return Array.from(n.values())}))}({network:e})}}const nl={success:!0,time:0,text:""};const al="/ipns/";function sl(e){let t;if(e.startsWith(al)&&(e=e.substring(al.length)),"1"!==e[0]&&"Q"!==e[0]||(e=`z${e}`),"z"===e[0]&&(t=ve.decode(e)),"k"===e[0]&&(t=be.decode(e)),!t)throw new Error("Could not parse string");if(1!==t[0]&&114!==t[1]&&(t=hr([[1,114],t])),40!==t.length)throw new Error("Incorrect length "+t.length);return hr([bt(al),t.subarray(2)])}const il=async(e,t,r)=>{const n=await e.use(r);if(null!=n.libp2p.dht)return n;{const e=async function*(){yield{from:t,name:"QUERY_ERROR",type:3,error:new ut("dht not enabled")}};return{libp2p:{dht:{get:e,put:e,findProviders:e,findPeer:e,provide:e,getClosestPeers:e}}}}};const ol=async()=>{throw new ut("pubsub not enabled")};var cl=r(52890),dl=r(55101),ll=r(51392);const hl=y.Z.bind({ignoreUndefined:!0}),ul=(0,b.kg)("ipfs");class pl{constructor({print:e,storage:t,codecs:r,options:n}){const{peerId:a,repo:s,keychain:i}=t,o=Kt.create(Qd),c=function(e={}){if(e.enabled=Boolean(e.enabled),e.addresses=e.addresses||[],e.cache=e.cache||1e3,!e.enabled||!e.addresses.length){bo("preload disabled");const e=()=>{};return Object.assign(e,{start:()=>{},stop:()=>{}})}let t=!0,r=[];const n=e.addresses.map((e=>(0,go.k)(e))),a=gr(e.cache),s=async e=>{try{if(t)throw new Error(`preload ${e} but preloader is not started`);const s=e.toString();if(a.has(s))return;a.set(s,!0);const i=(0,yo.Z)(n);let o=!1;const c=Date.now();for(const e of i){if(t)throw new Error(`preload aborted for ${s}`);let n;try{n=new AbortController,r=r.concat(n),await(0,mo.M)(`${e}/api/v0/refs?r=true&arg=${encodeURIComponent(s)}`,{signal:n.signal}),o=!0}catch(e){"aborted"!==e.type&&bo.error(e)}finally{r=r.filter((e=>e!==n))}if(o)break}bo(`${o?"":"un"}successfully preloaded ${s} in ${Date.now()-c}ms`)}catch(e){bo.error(e)}};return s.start=()=>{t=!1},s.stop=()=>{t=!0,bo(`aborting ${r.length} pending preload request(s)`),r.forEach((e=>e.abort())),r=[]},s}(n.preload),d=(0,Ot.a)((async(e,t={recursive:!0})=>{if("string"!=typeof e)throw new Error("Invalid arguments, domain must be a string");return e=function(e){return e.endsWith(".eth")&&(e=e.replace(/.eth$/,".eth.link")),e}(e),(0,Gt.D)(e,t)})),l=function({network:e}){return()=>{const t=e.try();return null!=t&&Boolean(t.libp2p.isStarted())}}({network:o}),h=new Lr(n),u=Object.values(nt);(n.ipld&&n.ipld.hashers?n.ipld.hashers:[]).forEach((e=>u.push(e))),this.hashers=new dl.d({hashers:u,loadHasher:n.ipld&&n.ipld.loadHasher});const p=Object.values(rt);(n.ipld&&n.ipld.bases?n.ipld.bases:[]).forEach((e=>p.push(e))),this.bases=new ll.x({bases:p,loadBase:n.ipld&&n.ipld.loadBase});const f=new er({repo:s,codecs:r}),w=new hn({codecs:r,hashers:this.hashers,preload:c,repo:s}),g=new Hr({dns:d,ipns:h,repo:s,codecs:r,peerId:a,isOnline:l,keychain:i,options:n}),y=qt({repo:s,codecs:r,bases:this.bases,name:g}),m=new wo({repo:s,codecs:r,hashers:this.hashers,preload:c}),b=Object.assign(qr({repo:s,codecs:r,resolve:y,preload:c}),{local:Qr({repo:t.repo})}),{add:v,addAll:E,cat:k,get:R,ls:A}=new Vi({preload:c,repo:s,options:n.EXPERIMENTAL,hashers:this.hashers}),I=id({repo:s,preload:c,hashers:this.hashers,options:n}),x=function({preload:e,files:t,options:r={}}){if(r.interval=r.interval||3e4,!r.enabled){_o("MFS preload disabled");const e=async()=>{};return{start:e,stop:e}}let n,a="";const s=async()=>{try{const i=await t.stat("/"),o=i.cid.toString();a!==o&&(_o(`preloading updated MFS root ${a} -> ${i.cid}`),await e(i.cid),a=o)}catch(e){_o.error("failed to preload MFS root",e)}finally{n=setTimeout(s,r.interval)}};return{async start(){const e=await t.stat("/");a=e.cid.toString(),_o(`monitoring MFS root ${e.cid}`),n=setTimeout(s,r.interval)},stop(){clearTimeout(n)}}}({files:I,preload:c,options:n.preload});this.preload=c,this.name=g,this.ipns=h,this.pin=f,this.resolve=y,this.block=w,this.refs=b,this.start=function({network:e,preload:t,peerId:r,keychain:n,repo:a,ipns:s,mfsPreload:i,print:o,hashers:c,options:d}){return async()=>{const{libp2p:l}=await Kt.start(e,{peerId:r,repo:a,print:o,hashers:c,options:d});await Promise.all([s.startOnline({keychain:n,libp2p:l,peerId:r,repo:a}),t.start(),i.start()])}}({network:o,peerId:a,repo:s,preload:c,ipns:h,mfsPreload:x,print:e,keychain:i,hashers:this.hashers,options:n}),this.stop=function({network:e,preload:t,ipns:r,repo:n,mfsPreload:a}){return async()=>{await Promise.all([t.stop(),r.stop(),a.stop()]),await Kt.stop(e),await n.close()}}({network:o,preload:c,mfsPreload:x,ipns:h,repo:s}),this.dht=function({network:e,repo:t,peerId:r}){const{get:n,put:a,findProvs:s,findPeer:i,provide:o,query:c}={async*get(t,n={}){const{libp2p:a}=await il(e,r,n),s=t instanceof Uint8Array?t:sl(t);if(null==a.dht)throw _(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*a.dht.get(s,n)},async*put(t,n,a){const{libp2p:s}=await il(e,r,a),i=t instanceof Uint8Array?t:sl(t);if(null==s.dht)throw _(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*s.dht.put(i,n,a)},async*findProvs(t,n={}){const{libp2p:a}=await il(e,r,n);if(null==a.dht)throw _(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*a.dht.findProviders(t,{signal:n.signal})},async*findPeer(t,n={}){const{libp2p:a}=await il(e,r,n);if(null==a.dht)throw _(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*a.dht.findPeer(t,{signal:n.signal})},async*provide(n,a={recursive:!1}){const{libp2p:s}=await il(e,r,a);if(!await t.blocks.has(n))throw _(new Error("block(s) not found locally, cannot provide"),"ERR_BLOCK_NOT_FOUND");if(a.recursive)throw _(new Error("not implemented yet"),"ERR_NOT_IMPLEMENTED_YET");if(null==s.dht)throw _(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*s.dht.provide(n)},async*query(t,n={}){const{libp2p:a}=await il(e,r,n);let s;const i=We.asCID(t);if(s=null!=i?i.multihash.bytes:(0,Wt.jE)(t.toString()).toBytes(),null==a.dht)throw _(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*a.dht.getClosestPeers(s,n)}};return{get:(0,Ot.a)(n),put:(0,Ot.a)(a),findProvs:(0,Ot.a)(s),findPeer:(0,Ot.a)(i),provide:(0,Ot.a)(o),query:(0,Ot.a)(c)}}({network:o,repo:s,peerId:a}),this.pubsub=function({network:e,config:t}){const r=vr(t||{},"Pubsub.Enabled",!0),n={};let a;return{subscribe:r?(0,Ot.a)((async function(t,r,s={}){const{libp2p:i}=await e.use(s);i.pubsub.subscribe(t),null==a&&(a=e=>{const t=e.detail;n[t.topic]&&n[t.topic].forEach((e=>{"function"!=typeof e?null!=e&&null!=e.handleEvent&&e.handleEvent(t):e(t)}))},i.pubsub.addEventListener("message",a)),null!=r&&(null==n[t]&&(n[t]=[]),n[t].push(r))})):ol,unsubscribe:r?(0,Ot.a)((async function(t,r,s={}){const{libp2p:i}=await e.use(s);null!=r&&null!=n[t]&&(n[t]=n[t].filter((e=>e!==r)),0===n[t].length&&delete n[t]),"function"!=typeof r&&delete n[t],null==n[t]&&i.pubsub.unsubscribe(t),0===Object.keys(n).length&&(i.pubsub.removeEventListener("message",a),a=void 0)})):ol,publish:r?(0,Ot.a)((async function(t,r,n={}){const{libp2p:a}=await e.use(n);if(!r)throw _(new Error('argument "data" is required'),"ERR_ARG_REQUIRED");await a.pubsub.publish(t,r)})):ol,ls:r?(0,Ot.a)((async function(t={}){const{libp2p:r}=await e.use(t);return r.pubsub.getTopics()})):ol,peers:r?(0,Ot.a)((async function(t,r={}){const{libp2p:n}=await e.use(r);return n.pubsub.getSubscribers(t)})):ol}}({network:o,config:n.config}),this.dns=d,this.isOnline=l,this.id=Ki({network:o,peerId:a}),this.version=function({repo:e}){return(0,Ot.a)((async function(t={}){const r=await e.version.get();return{version:Hi,commit:"e8b7b66bfa98c2a1c0d0bfc19f698d7d00b6c888",repo:`${r}`,"ipfs-core":Hi,"interface-ipfs-core":"^0.157.0"}}))}({repo:s}),this.bitswap=new tn({network:o}),this.bootstrap=new an({repo:s}),this.config=function({repo:e}){return{getAll:(0,Ot.a)((async function(t={}){return e.config.getAll(t)})),get:(0,Ot.a)((async function(t,r){return t?e.config.get(t,r):Promise.reject(new Error("key argument is required"))})),set:(0,Ot.a)((async function(t,r,n){return e.config.set(t,r,n)})),replace:(0,Ot.a)((async function(t,r){return e.config.replace(t,r)})),profiles:{apply:(0,Ot.a)((async function(t,r={dryRun:!1}){const{dryRun:n}=r,a=Wi[t];if(!a)throw new Error(`No profile with name '${t}' exists`);try{const t=await e.config.getAll(r);let s=JSON.parse(JSON.stringify(t));return s=a.transform(s),n||await e.config.replace(s,r),delete t.Identity.PrivKey,delete s.Identity.PrivKey,{original:t,updated:s}}catch(e){throw qi(e),new Error(`Could not apply profile '${t}' to config: ${e.message}`)}})),list:(0,Ot.a)(Yi)}}}({repo:s}),this.ping=function({network:e}){return(0,Ot.a)((async function*(t,r={}){const{libp2p:n}=await e.use();r.count=r.count||10;const a=await n.peerStore.get(t);let s=a&&a.id;if(!s){yield{...nl,text:`Looking up peer ${t}`};const e=await n.peerRouting.findPeer(t);s=e&&e.id}if(!s)throw new Error("Peer was not found");yield{...nl,text:`PING ${s.toString()}`};let i=0,o=0;for(let e=0;e<r.count;e++)try{const e=await n.ping(s);o+=e,i++,yield{...nl,time:e}}catch(e){yield{...nl,success:!1,text:e.toString()}}if(i){const e=o/i;yield{...nl,text:`Average latency: ${e}ms`}}}))}({network:o}),this.add=v,this.addAll=E,this.cat=k,this.get=R,this.ls=A,this.dag=m,this.files=I,this.key=new cd({keychain:i}),this.object=new fd({preload:c,codecs:r,repo:s}),this.repo=new md({repo:s,hashers:this.hashers}),this.stats=new _d({repo:s,network:o}),this.swarm=new rl({network:o}),Object.defineProperty(this,"libp2p",{get(){const e=o.try();return e?e.libp2p:void 0}});const S=()=>Promise.reject(_(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED"));this.commands=S,this.diag={cmds:S,net:S,sys:S},this.log={level:S,ls:S,tail:async function*(){throw _(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")}},this.mount=S,this.codecs=r}async init(){throw new ct}}r(52596),r(46953);const fl=async function(e={}){const t=(e=hl({start:!0,EXPERIMENTAL:{},preload:{enabled:!m.isTest,addresses:["/dns4/node0.preload.ipfs.io/https","/dns4/node1.preload.ipfs.io/https","/dns4/node2.preload.ipfs.io/https","/dns4/node3.preload.ipfs.io/https"]}},e)).init||{},r={name:G.name,code:G.code,encode:e=>e,decode:e=>e},n=Object.values(at);[E,k,R,A,r].concat(e.ipld&&e.ipld.codecs||[]).forEach((e=>n.push(e)));const a=new cl.w({codecs:n,loadCodec:e.ipld&&e.ipld.loadCodec}),s=e.silent?ul:console.log;ul("creating repo");const i=await jd.start(s,a,e);ul("getting repo config");const o=await i.repo.config.getAll(),c=new pl({storage:i,print:s,codecs:a,options:{...e,config:o}});if(ul("starting preload"),await c.preload.start(),ul("starting storage"),c.ipns.startOffline(i),i.isNew&&!t.emptyRepo){const e=await(async e=>{const t=E.encode({Data:new v.fL({type:"directory"}).marshal(),Links:[]}),r=await e.block.put(t,{mhtype:"sha2-256",format:"dag-pb"});return await e.pin.add(r),r})(c);if(ul("adding default assets"),await(0,st.L)({addAll:c.addAll,print:s}),ul("initializing IPNS keyspace"),null==i.peerId.publicKey)throw _(new Error("Public key missing"),"ERR_MISSING_PUBLIC_KEY");const t=new _t.TimeoutController(3e4);try{await c.ipns.initializeKeyspace(i.peerId,bt(`/ipfs/${e}`),{signal:t.signal})}finally{t.clear()}}return!1!==e.start&&(ul("starting node"),await c.start()),c}},32507:(e,t,r)=>{r.d(t,{Ue:()=>za});var n={};r.r(n),r.d(n,{identity:()=>H});var a={};r.r(a),r.d(a,{identity:()=>te});var s={};r.r(s),r.d(s,{base2:()=>re});var i={};r.r(i),r.d(i,{base8:()=>ne});var o={};r.r(o),r.d(o,{base10:()=>ae});var c={};r.r(c),r.d(c,{base16:()=>se,base16upper:()=>ie});var d={};r.r(d),r.d(d,{base32:()=>oe,base32hex:()=>he,base32hexpad:()=>pe,base32hexpadupper:()=>fe,base32hexupper:()=>ue,base32pad:()=>de,base32padupper:()=>le,base32upper:()=>ce,base32z:()=>we});var l={};r.r(l),r.d(l,{base36:()=>ge,base36upper:()=>ye});var h={};r.r(h),r.d(h,{base58btc:()=>me,base58flickr:()=>be});var u={};r.r(u),r.d(u,{base64:()=>_e,base64pad:()=>ve,base64url:()=>Ee,base64urlpad:()=>ke});var p={};r.r(p),r.d(p,{base256emoji:()=>xe});var f={};r.r(f),r.d(f,{sha256:()=>De,sha512:()=>Te});var w={};r.r(w),r.d(w,{code:()=>Ce,decode:()=>Oe,encode:()=>ze,name:()=>Le});var g={};r.r(g),r.d(g,{code:()=>Me,decode:()=>Ze,encode:()=>Be,name:()=>je});var y=r(51392),m=r(52890),b=r(55101),_=r(10539),v=r(34219),E=r(66258),k=r(46392);new Uint8Array(0);const R=e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")};var A=function e(t,r,n){r=r||[];var a=n=n||0;for(;t>=I;)r[n++]=255&t|128,t/=128;for(;-128&t;)r[n++]=255&t|128,t>>>=7;return r[n]=0|t,e.bytes=n-a+1,r},I=Math.pow(2,31);var x=function e(t,r){var n,a=0,s=0,i=r=r||0,o=t.length;do{if(i>=o)throw e.bytes=0,new RangeError("Could not decode varint");n=t[i++],a+=s<28?(127&n)<<s:(127&n)*Math.pow(2,s),s+=7}while(n>=128);return e.bytes=i-r,a};var S=Math.pow(2,7),N=Math.pow(2,14),P=Math.pow(2,21),D=Math.pow(2,28),T=Math.pow(2,35),L=Math.pow(2,42),C=Math.pow(2,49),z=Math.pow(2,56),O=Math.pow(2,63);const U={encode:A,decode:x,encodingLength:function(e){return e<S?1:e<N?2:e<P?3:e<D?4:e<T?5:e<L?6:e<C?7:e<z?8:e<O?9:10}},$=(e,t=0)=>[U.decode(e,t),U.decode.bytes],j=(e,t,r=0)=>(U.encode(e,t,r),t),M=e=>U.encodingLength(e),B=(e,t)=>{const r=t.byteLength,n=M(e),a=n+M(r),s=new Uint8Array(a+r);return j(e,s,0),j(r,s,n),s.set(t,a),new Z(e,r,t,s)};class Z{constructor(e,t,r,n){this.code=e,this.size=t,this.digest=r,this.bytes=n}}const V=R,H={code:0,name:"identity",encode:V,digest:e=>B(0,V(e))};var F=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var a=0;a<e.length;a++){var s=e.charAt(a),i=s.charCodeAt(0);if(255!==r[i])throw new TypeError(s+" is ambiguous");r[i]=a}var o=e.length,c=e.charAt(0),d=Math.log(o)/Math.log(256),l=Math.log(256)/Math.log(o);function h(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var n=0,a=0;e[t]===c;)n++,t++;for(var s=(e.length-t)*d+1>>>0,i=new Uint8Array(s);e[t];){var l=r[e.charCodeAt(t)];if(255===l)return;for(var h=0,u=s-1;(0!==l||h<a)&&-1!==u;u--,h++)l+=o*i[u]>>>0,i[u]=l%256>>>0,l=l/256>>>0;if(0!==l)throw new Error("Non-zero carry");a=h,t++}if(" "!==e[t]){for(var p=s-a;p!==s&&0===i[p];)p++;for(var f=new Uint8Array(n+(s-p)),w=n;p!==s;)f[w++]=i[p++];return f}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,a=0,s=t.length;a!==s&&0===t[a];)a++,r++;for(var i=(s-a)*l+1>>>0,d=new Uint8Array(i);a!==s;){for(var h=t[a],u=0,p=i-1;(0!==h||u<n)&&-1!==p;p--,u++)h+=256*d[p]>>>0,d[p]=h%o>>>0,h=h/o>>>0;if(0!==h)throw new Error("Non-zero carry");n=u,a++}for(var f=i-n;f!==i&&0===d[f];)f++;for(var w=c.repeat(r);f<i;++f)w+=e.charAt(d[f]);return w},decodeUnsafe:h,decode:function(e){var r=h(e);if(r)return r;throw new Error(`Non-${t} character`)}}};const K=F;class G{constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class W{constructor(e,t,r){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=r}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return Y(this,e)}}class q{constructor(e){this.decoders=e}or(e){return Y(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Y=(e,t)=>new q({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class X{constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new G(e,t,r),this.decoder=new W(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const J=({name:e,prefix:t,encode:r,decode:n})=>new X(e,t,r,n),Q=({prefix:e,name:t,alphabet:r})=>{const{encode:n,decode:a}=K(r,t);return J({prefix:e,name:t,encode:n,decode:e=>R(a(e))})},ee=({name:e,prefix:t,bitsPerChar:r,alphabet:n})=>J({prefix:t,name:e,encode:e=>((e,t,r)=>{const n="="===t[t.length-1],a=(1<<r)-1;let s="",i=0,o=0;for(let n=0;n<e.length;++n)for(o=o<<8|e[n],i+=8;i>r;)i-=r,s+=t[a&o>>i];if(i&&(s+=t[a&o<<r-i]),n)for(;s.length*r&7;)s+="=";return s})(e,n,r),decode:t=>((e,t,r,n)=>{const a={};for(let e=0;e<t.length;++e)a[t[e]]=e;let s=e.length;for(;"="===e[s-1];)--s;const i=new Uint8Array(s*r/8|0);let o=0,c=0,d=0;for(let t=0;t<s;++t){const s=a[e[t]];if(void 0===s)throw new SyntaxError(`Non-${n} character`);c=c<<r|s,o+=r,o>=8&&(o-=8,i[d++]=255&c>>o)}if(o>=r||255&c<<8-o)throw new SyntaxError("Unexpected end of data");return i})(t,n,r,e)}),te=J({prefix:"\0",name:"identity",encode:e=>{return t=e,(new TextDecoder).decode(t);var t},decode:e=>(e=>(new TextEncoder).encode(e))(e)}),re=ee({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),ne=ee({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),ae=Q({prefix:"9",name:"base10",alphabet:"0123456789"}),se=ee({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),ie=ee({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),oe=ee({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),ce=ee({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),de=ee({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),le=ee({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),he=ee({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),ue=ee({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),pe=ee({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),fe=ee({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),we=ee({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),ge=Q({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),ye=Q({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),me=Q({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),be=Q({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),_e=ee({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),ve=ee({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Ee=ee({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ke=ee({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Re=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Ae=Re.reduce(((e,t,r)=>(e[r]=t,e)),[]),Ie=Re.reduce(((e,t,r)=>(e[t.codePointAt(0)]=r,e)),[]);const xe=J({prefix:"ðŸš€",name:"base256emoji",encode:function(e){return e.reduce(((e,t)=>e+=Ae[t]),"")},decode:function(e){const t=[];for(const r of e){const e=Ie[r.codePointAt(0)];if(void 0===e)throw new Error(`Non-base256emoji character: ${r}`);t.push(e)}return new Uint8Array(t)}}),Se=({name:e,code:t,encode:r})=>new Ne(e,t,r);class Ne{constructor(e,t,r){this.name=e,this.code=t,this.encode=r}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?B(this.code,t):t.then((e=>B(this.code,e)))}throw Error("Unknown type, must be binary type")}}const Pe=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),De=Se({name:"sha2-256",code:18,encode:Pe("SHA-256")}),Te=Se({name:"sha2-512",code:19,encode:Pe("SHA-512")}),Le="raw",Ce=85,ze=e=>R(e),Oe=e=>R(e),Ue=new TextEncoder,$e=new TextDecoder,je="json",Me=512,Be=e=>Ue.encode(JSON.stringify(e)),Ze=e=>JSON.parse($e.decode(e)),Ve=new WeakMap,He=e=>{const t=Ve.get(e);if(null==t){const t=new Map;return Ve.set(e,t),t}return t};class Fe{constructor(e,t,r,n){this.code=t,this.version=e,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==qe)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Ye)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return Fe.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=B(e,t);return Fe.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return Fe.equals(this,e)}static equals(e,t){const r=t;return r&&e.code===r.code&&e.version===r.version&&((e,t)=>{if(e===t)return!0;{const r=t;return e.code===r.code&&e.size===r.size&&r.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0})(e.bytes,r.bytes)}})(e.multihash,r.multihash)}toString(e){return((e,t)=>{const{bytes:r,version:n}=e;return 0===n?Ge(r,He(e),t||me.encoder):We(r,He(e),t||oe.encoder)})(this,e)}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof Fe)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:r,multihash:n,bytes:a}=t;return new Fe(e,r,n,a||Xe(e,r,n.bytes))}if(!0===t[Je]){const{version:e,multihash:r,code:n}=t,a=(e=>{const t=R(e),[r,n]=$(t),[a,s]=$(t.subarray(n)),i=t.subarray(n+s);if(i.byteLength!==a)throw new Error("Incorrect length");return new Z(r,a,i,t)})(r);return Fe.create(e,n,a)}return null}static create(e,t,r){if("number"!=typeof t)throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==qe)throw new Error(`Version 0 CID must use dag-pb (code: ${qe}) block encoding`);return new Fe(e,t,r,r.bytes);case 1:{const n=Xe(e,t,r.bytes);return new Fe(e,t,r,n)}default:throw new Error("Invalid version")}}static createV0(e){return Fe.create(0,qe,e)}static createV1(e,t){return Fe.create(1,e,t)}static decode(e){const[t,r]=Fe.decodeFirst(e);if(r.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=Fe.inspectBytes(e),r=t.size-t.multihashSize,n=R(e.subarray(r,r+t.multihashSize));if(n.byteLength!==t.multihashSize)throw new Error("Incorrect length");const a=n.subarray(t.multihashSize-t.digestSize),s=new Z(t.multihashCode,t.digestSize,a,n);return[0===t.version?Fe.createV0(s):Fe.createV1(t.codec,s),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[r,n]=$(e.subarray(t));return t+=n,r};let n=r(),a=qe;if(18===n?(n=0,t=0):a=r(),0!==n&&1!==n)throw new RangeError(`Invalid CID version ${n}`);const s=t,i=r(),o=r(),c=t+o;return{version:n,codec:a,multihashCode:i,digestSize:o,multihashSize:c-s,size:c}}static parse(e,t){const[r,n]=Ke(e,t),a=Fe.decode(n);return He(a).set(r,e),a}}const Ke=(e,t)=>{switch(e[0]){case"Q":{const r=t||me;return[me.prefix,r.decode(`${me.prefix}${e}`)]}case me.prefix:{const r=t||me;return[me.prefix,r.decode(e)]}case oe.prefix:{const r=t||oe;return[oe.prefix,r.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},Ge=(e,t,r)=>{const{prefix:n}=r;if(n!==me.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const a=t.get(n);if(null==a){const a=r.encode(e).slice(1);return t.set(n,a),a}return a},We=(e,t,r)=>{const{prefix:n}=r,a=t.get(n);if(null==a){const a=r.encode(e);return t.set(n,a),a}return a},qe=112,Ye=18,Xe=(e,t,r)=>{const n=M(e),a=n+M(t),s=new Uint8Array(a+r.byteLength);return j(e,s,0),j(t,s,n),s.set(r,a),s},Je=Symbol.for("@ipld/js-cid/CID"),Qe={...a,...s,...i,...o,...c,...d,...l,...h,...u,...p},et={...f,...n},tt={raw:w,json:g};var rt=r(94306),nt=r(106),at=r(92816),st=r(38461),it=r(67137),ot=r(40726),ct=r(63181),dt=r(97295);const lt=(0,st.kg)("js-kubo-rpc-client:lib:error-handler"),ht=ot.Z.bind({ignoreUndefined:!0}),ut=nt.isBrowser||nt.isWebWorker?location.protocol:"http",pt=nt.isBrowser||nt.isWebWorker?location.hostname:"localhost",ft=nt.isBrowser||nt.isWebWorker?location.port:"5001",wt=async e=>{let t;try{if((e.headers.get("Content-Type")||"").startsWith("application/json")){const r=await e.json();lt(r),t=r.Message||r.message}else t=await e.text()}catch(e){lt("Failed to parse error response",e),t=e.message}let r=new it.HTTPError(e);throw t&&(t.includes("deadline has elapsed")&&(r=new it.TimeoutError),t&&t.includes("context deadline exceeded")&&(r=new it.TimeoutError)),t&&t.includes("request timed out")&&(r=new it.TimeoutError),t&&(r.message=t),r},gt=/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g,yt=e=>e.replace(gt,(function(e){return"-"+e.toLowerCase()}));class mt extends it{constructor(e={}){const t=((e={})=>{let t,r,n={};if("string"==typeof e||(0,rt.h2)(e))t=new URL((0,ct.d)(e));else if(e instanceof URL)t=e;else if("string"==typeof e.url||(0,rt.h2)(e.url))t=new URL((0,ct.d)(e.url)),n=e;else if(e.url instanceof URL)t=e.url,n=e;else{n=e||{};const r=(n.protocol||ut).replace(":",""),a=(n.host||pt).split(":")[0],s=n.port||ft;t=new URL(`${r}://${a}:${s}`)}if(n.apiPath?t.pathname=n.apiPath:"/"!==t.pathname&&void 0!==t.pathname||(t.pathname="api/v0"),nt.isNode){const e=(0,dt.Z)(t);r=n.agent||new e({keepAlive:!0,maxSockets:6})}return{...n,host:t.host,protocol:t.protocol.replace(":",""),port:Number(t.port),apiPath:t.pathname,url:t,agent:r}})(e);var r;super({timeout:(r=t.timeout||0,("string"==typeof r?(0,at.Z)(r):r)||void 0),headers:t.headers,base:`${t.url}`,handleError:wt,transformSearchParams:e=>{const t=new URLSearchParams;for(const[r,n]of e)"undefined"!==n&&"null"!==n&&"signal"!==r&&t.append(yt(r),n),"timeout"!==r||isNaN(n)||t.append(yt(r),n);return t},agent:t.agent}),delete this.get,delete this.put,delete this.delete,delete this.options;const n=this.fetch;this.fetch=(e,r={})=>("string"!=typeof e||e.startsWith("/")||(e=`${t.url}/${e}`),n.call(this,e,ht(r,{method:"POST"})))}}it.HTTPError;const bt=e=>t=>e(new mt(t),t);function _t(e){if(null!=e)return"string"==typeof e?e:e.toString(8).padStart(4,"0")}var vt=r(32114);function Et(e){if(null==e)return;let t;if(null!=e.secs&&(t={secs:e.secs,nsecs:e.nsecs}),null!=e.Seconds&&(t={secs:e.Seconds,nsecs:e.FractionalNanoseconds}),Array.isArray(e)&&(t={secs:e[0],nsecs:e[1]}),e instanceof Date){const r=e.getTime(),n=Math.floor(r/1e3);t={secs:n,nsecs:1e3*(r-1e3*n)}}if(Object.prototype.hasOwnProperty.call(t,"secs")){if(null!=t&&null!=t.nsecs&&(t.nsecs<0||t.nsecs>999999999))throw vt(new Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return t}}function kt({arg:e,searchParams:t,hashAlg:r,mtime:n,mode:a,...s}={}){t&&(s={...s,...t}),r&&(s.hash=r),null!=n&&(n=Et(n),s.mtime=n.secs,s.mtimeNsecs=n.nsecs),null!=a&&(s.mode=_t(a)),s.timeout&&!isNaN(s.timeout)&&(s.timeout=`${s.timeout}ms`),null==e?e=[]:Array.isArray(e)||(e=[e]);const i=new URLSearchParams(s);return e.forEach((e=>i.append("arg",e))),i}const Rt=bt((e=>async function(t={}){return((await(await e.post("bitswap/wantlist",{signal:t.signal,searchParams:kt(t),headers:t.headers})).json()).Keys||[]).map((e=>Fe.parse(e["/"])))})),At=bt((e=>async function(t,r={}){return((await(await e.post("bitswap/wantlist",{signal:r.signal,searchParams:kt({...r,peer:t.toString()}),headers:r.headers})).json()).Keys||[]).map((e=>Fe.parse(e["/"])))}));var It=r(93203);const xt=bt((e=>async function(t={}){const r=await e.post("bitswap/stat",{searchParams:kt(t),signal:t.signal,headers:t.headers});return function(e){return{provideBufLen:e.ProvideBufLen,wantlist:(e.Wantlist||[]).map((e=>Fe.parse(e["/"]))),peers:(e.Peers||[]).map((e=>(0,It.jE)(e))),blocksReceived:BigInt(e.BlocksReceived),dataReceived:BigInt(e.DataReceived),blocksSent:BigInt(e.BlocksSent),dataSent:BigInt(e.DataSent),dupBlksReceived:BigInt(e.DupBlksReceived),dupDataReceived:BigInt(e.DupDataReceived)}}(await r.json())}));const St=bt((e=>async function(t,r={}){const n=await e.post("block/get",{signal:r.signal,searchParams:kt({arg:t.toString(),...r}),headers:r.headers});return new Uint8Array(await n.arrayBuffer())}));var Nt=r(47498),Pt=r(32044);function Dt(...e){return(0,Pt.anySignal)(function(e){return e.filter(Boolean)}(e))}const Tt=bt(((e,t)=>async function t(r,n={}){const a=new AbortController,s=Dt(a.signal,n.signal);let i;try{const t=await e.post("block/put",{signal:s,searchParams:kt(n),...await(0,Nt.x)([r],a,n.headers)});i=await t.json()}catch(e){if("dag-pb"===n.format)return t(r,{...n,format:"protobuf"});if("dag-cbor"===n.format)return t(r,{...n,format:"cbor"});throw e}return Fe.parse(i.Key)})),Lt=bt((e=>async function*(t,r={}){Array.isArray(t)||(t=[t]);const n=await e.post("block/rm",{signal:r.signal,searchParams:kt({arg:t.map((e=>e.toString())),"stream-channels":!0,...r}),headers:r.headers});for await(const e of n.ndjson())yield Ct(e)}));function Ct(e){const t={cid:Fe.parse(e.Hash)};return e.Error&&(t.error=new Error(e.Error)),t}const zt=bt((e=>async function(t,r={}){const n=await e.post("block/stat",{signal:r.signal,searchParams:kt({arg:t.toString(),...r}),headers:r.headers}),a=await n.json();return{cid:Fe.parse(a.Key),size:a.Size}}));function Ot(e){return{get:St(e),put:Tt(e),rm:Lt(e),stat:zt(e)}}const Ut=bt((e=>async function(t,r={}){const n=await e.post("bootstrap/add",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers}),{Peers:a}=await n.json();return{Peers:a.map((e=>(0,rt.HM)(e)))}})),$t=bt((e=>async function(t={}){const r=await e.post("bootstrap/rm",{signal:t.signal,searchParams:kt({...t,all:!0}),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map((e=>(0,rt.HM)(e)))}})),jt=bt((e=>async function(t={}){const r=await e.post("bootstrap/list",{signal:t.signal,searchParams:kt(t),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map((e=>(0,rt.HM)(e)))}})),Mt=bt((e=>async function(t={}){const r=await e.post("bootstrap/add",{signal:t.signal,searchParams:kt({...t,default:!0}),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map((e=>(0,rt.HM)(e)))}})),Bt=bt((e=>async function(t,r={}){const n=await e.post("bootstrap/rm",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers}),{Peers:a}=await n.json();return{Peers:a.map((e=>(0,rt.HM)(e)))}}));function Zt(e){return{add:Ut(e),clear:$t(e),list:jt(e),reset:Mt(e),rm:Bt(e)}}const Vt=bt((e=>async function(t,r={}){const n=await e.post("config/profile/apply",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers}),a=await n.json();return{original:a.OldCfg,updated:a.NewCfg}}));function Ht(e){return{apply:Vt(e)}}const Ft=bt((e=>async(t,r={})=>{if(!t)throw new Error("key argument is required");const n=await e.post("config",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers});return(await n.json()).Value})),Kt=bt((e=>async(t={})=>{const r=await e.post("config/show",{signal:t.signal,searchParams:kt({...t}),headers:t.headers});return await r.json()}));function Gt(e){return null!=globalThis.Buffer?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e}function Wt(e,t,r,n){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:r},decoder:{decode:n}}}const qt=Wt("utf8","u",(e=>"u"+new TextDecoder("utf8").decode(e)),(e=>(new TextEncoder).encode(e.substring(1)))),Yt=Wt("ascii","a",(e=>{let t="a";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t}),(e=>{const t=function(e=0){return null!=globalThis.Buffer?.allocUnsafe?Gt(globalThis.Buffer.allocUnsafe(e)):new Uint8Array(e)}((e=e.substring(1)).length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t})),Xt={utf8:qt,"utf-8":qt,hex:Qe.base16,latin1:Yt,ascii:Yt,binary:Yt,...Qe};function Jt(e,t="utf8"){const r=Xt[t];if(null==r)throw new Error(`Unsupported encoding "${t}"`);return"utf8"!==t&&"utf-8"!==t||null==globalThis.Buffer||null==globalThis.Buffer.from?r.decoder.decode(`${r.prefix}${e}`):Gt(globalThis.Buffer.from(e,"utf-8"))}const Qt=bt((e=>async(t,r={})=>{const n=new AbortController,a=Dt(n.signal,r.signal),s=await e.post("config/replace",{signal:a,searchParams:kt(r),...await(0,Nt.x)([Jt(JSON.stringify(t))],n,r.headers)});await s.text()})),er=bt((e=>async(t,r,n={})=>{if("string"!=typeof t)throw new Error("Invalid key type");const a={...n,...tr(t,r)},s=await e.post("config",{signal:n.signal,searchParams:kt(a),headers:n.headers});await s.text()})),tr=(e,t)=>{switch(typeof t){case"boolean":return{arg:[e,t.toString()],bool:!0};case"string":return{arg:[e,t]};default:return{arg:[e,JSON.stringify(t)],json:!0}}};function rr(e){return{getAll:Kt(e),get:Ft(e),set:er(e),replace:Qt(e),profiles:Ht(e)}}const nr=bt((e=>async function*(t,r={}){const n=await e.post("dag/export",{signal:r.signal,searchParams:kt({arg:t.toString()}),headers:r.headers});yield*n.iterator()}));async function*ar(e,t,r,n,a){const s=async e=>{const t=await r.getCodec(e.code),s=await n(e,a);return t.decode(s)},i=t.split("/").filter(Boolean);let o=await s(e),c=e;for(;i.length;){const e=i.shift();if(!e)throw vt(new Error(`Could not resolve path "${t}"`),"ERR_INVALID_PATH");if(!Object.prototype.hasOwnProperty.call(o,e))throw vt(new Error(`no link named "${e}" under ${c}`),"ERR_NO_LINK");o=o[e],yield{value:o,remainderPath:i.join("/")};const r=Fe.asCID(o);r&&(c=r,o=await s(o))}yield{value:o,remainderPath:""}}var sr=r(91486),ir=r(68883);const or=(e,t)=>{const r=bt(((t,r)=>{const n=St(r);return async(t,r={})=>{if(r.path){const a=r.localResolve?await(0,sr.Z)(ar(t,r.path,e,n,r)):await(0,ir.Z)(ar(t,r.path,e,n,r));if(!a)throw vt(new Error("Not found"),"ERR_NOT_FOUND");return a}const a=await e.getCodec(t.code),s=await n(t,r);return{value:a.decode(s),remainderPath:""}}}));return r(t)},cr=bt((e=>async function*(t,r={}){const n=new AbortController,a=Dt(n.signal,r.signal),{headers:s,body:i}=await(0,Nt.x)(t,n,r.headers),o=await e.post("dag/import",{signal:a,headers:s,body:i,searchParams:kt({"pin-roots":r.pinRoots})});for await(const{Root:e}of o.ndjson())if(void 0!==e){const{Cid:{"/":t},PinErrorMsg:r}=e;yield{root:{cid:Fe.parse(t),pinErrorMsg:r}}}})),dr=(e,t)=>{const r=bt((t=>async(r,n={})=>{const a={storeCodec:"dag-cbor",hashAlg:"sha2-256",...n};let s;if(a.inputCodec){if(!(r instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");s=r}else{s=(await e.getCodec(a.storeCodec)).encode(r),a.inputCodec=a.storeCodec}const i=new AbortController,o=Dt(i.signal,a.signal),c=await t.post("dag/put",{timeout:a.timeout,signal:o,searchParams:kt(a),...await(0,Nt.x)([s],i,a.headers)}),d=await c.json();return Fe.parse(d.Cid["/"])}));return r(t)},lr=bt((e=>async(t,r={})=>{const n=await e.post("dag/resolve",{signal:r.signal,searchParams:kt({arg:`${t}${r.path?`/${r.path}`.replace(/\/[/]+/g,"/"):""}`,...r}),headers:r.headers}),a=await n.json();return{cid:Fe.parse(a.Cid["/"]),remainderPath:a.RemPath}}));function hr(e,t){return{export:nr(t),get:or(e,t),import:cr(t),put:dr(e,t),resolve:lr(t)}}const ur=e=>{if(0===e.Type)return{name:"SENDING_QUERY",type:e.Type};if(1===e.Type)return{from:(0,It.jE)(e.ID),name:"PEER_RESPONSE",type:e.Type,messageType:0,messageName:"PUT_VALUE",closer:(e.Responses||[]).map((({ID:e,Addrs:t})=>({id:(0,It.jE)(e),multiaddrs:t.map((e=>(0,rt.HM)(e))),protocols:[]}))),providers:(e.Responses||[]).map((({ID:e,Addrs:t})=>({id:(0,It.jE)(e),multiaddrs:t.map((e=>(0,rt.HM)(e))),protocols:[]})))};if(2===e.Type){let t={id:e.ID??(0,It.jE)(e.ID),multiaddrs:[],protocols:[]};return e.Responses&&e.Responses.length&&(t={id:(0,It.jE)(e.Responses[0].ID),multiaddrs:e.Responses[0].Addrs.map((e=>(0,rt.HM)(e))),protocols:[]}),{name:"FINAL_PEER",type:e.Type,peer:t}}if(3===e.Type)return{name:"QUERY_ERROR",type:e.Type,error:new Error(e.Extra)};if(4===e.Type)return{name:"PROVIDER",type:e.Type,providers:e.Responses.map((({ID:e,Addrs:t})=>({id:(0,It.jE)(e),multiaddrs:t.map((e=>(0,rt.HM)(e))),protocols:[]})))};if(5===e.Type)return{name:"VALUE",type:e.Type,value:Jt(e.Extra,"base64pad")};if(6===e.Type){const t=e.Responses.map((({ID:e})=>(0,It.jE)(e)));if(!t.length)throw new Error("No peer found");return{name:"ADDING_PEER",type:e.Type,peer:t[0]}}if(7===e.Type)return{name:"DIALING_PEER",type:e.Type,peer:(0,It.jE)(e.ID)};throw new Error("Unknown DHT event type")},pr=bt((e=>async function*(t,r={}){const n=await e.post("dht/findpeer",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers});for await(const e of n.ndjson())yield ur(e)})),fr=bt((e=>async function*(t,r={}){const n=await e.post("dht/findprovs",{signal:r.signal,searchParams:kt({arg:t.toString(),...r}),headers:r.headers});for await(const e of n.ndjson())yield ur(e)}));function wr(e,t="utf8"){const r=Xt[t];if(null==r)throw new Error(`Unsupported encoding "${t}"`);return"utf8"!==t&&"utf-8"!==t||null==globalThis.Buffer||null==globalThis.Buffer.from?r.encoder.encode(e).substring(1):globalThis.Buffer.from(e.buffer,e.byteOffset,e.byteLength).toString("utf8")}const gr=bt((e=>async function*(t,r={}){const n=await e.post("dht/get",{signal:r.signal,searchParams:kt({arg:t instanceof Uint8Array?wr(t):t.toString(),...r}),headers:r.headers});for await(const e of n.ndjson())yield ur(e)})),yr=bt((e=>async function*(t,r={recursive:!1}){const n=Array.isArray(t)?t:[t],a=await e.post("dht/provide",{signal:r.signal,searchParams:kt({arg:n.map((e=>e.toString())),...r}),headers:r.headers});for await(const e of a.ndjson())yield ur(e)})),mr=bt((e=>async function*(t,r,n={}){const a=new AbortController,s=Dt(a.signal,n.signal),i=await e.post("dht/put",{signal:s,searchParams:kt({arg:t instanceof Uint8Array?wr(t):t.toString(),...n}),...await(0,Nt.x)([r],a,n.headers)});for await(const e of i.ndjson())yield ur(e)})),br=bt((e=>async function*(t,r={}){const n=await e.post("dht/query",{signal:r.signal,searchParams:kt({arg:t.toString(),...r}),headers:r.headers});for await(const e of n.ndjson())yield ur(e)}));function _r(e){return{findPeer:pr(e),findProvs:fr(e),get:gr(e),provide:yr(e),put:mr(e),query:br(e)}}const vr=bt((e=>async function(t={}){return(await e.post("diag/cmds",{signal:t.signal,searchParams:kt(t),headers:t.headers})).json()})),Er=bt((e=>async function(t={}){return(await e.post("diag/net",{signal:t.signal,searchParams:kt(t),headers:t.headers})).json()})),kr=bt((e=>async function(t={}){return(await e.post("diag/sys",{signal:t.signal,searchParams:kt(t),headers:t.headers})).json()}));function Rr(e){return{cmds:vr(e),net:Er(e),sys:kr(e)}}const Ar=bt((e=>async function(t,r,n={}){const a=Array.isArray(t)?t:[t],s=await e.post("files/cp",{signal:n.signal,searchParams:kt({arg:a.concat(r).map((e=>Fe.asCID(e)?`/ipfs/${e}`:e)),...n}),headers:n.headers});await s.text()})),Ir=bt((e=>async function(t,r={}){if(!t||"string"!=typeof t)throw new Error("ipfs.files.flush requires a path");const n=await e.post("files/flush",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers}),a=await n.json();return Fe.parse(a.Cid)}));function xr(e){if(null==e)return e;const t=/^[A-Z]+$/;return Object.keys(e).reduce(((r,n)=>(t.test(n)?r[n.toLowerCase()]=e[n]:t.test(n[0])?r[n[0].toLowerCase()+n.slice(1)]=e[n]:r[n]=e[n],r)),{})}function Sr(e){const t=xr(e);return Object.prototype.hasOwnProperty.call(t,"mode")&&(t.mode=parseInt(t.mode,8)),Object.prototype.hasOwnProperty.call(t,"mtime")&&(t.mtime={secs:t.mtime,nsecs:t.mtimeNsecs||0},delete t.mtimeNsecs),t}const Nr=bt((e=>async function*(t,r={}){if(!t)throw new Error("ipfs.files.ls requires a path");const n=await e.post("files/ls",{signal:r.signal,searchParams:kt({arg:Fe.asCID(t)?`/ipfs/${t}`:t,long:!0,...r,stream:!0}),headers:r.headers});for await(const e of n.ndjson())if("Entries"in e)for(const t of e.Entries||[])yield Pr(Sr(t));else yield Pr(Sr(e))}));function Pr(e){return e.hash&&(e.cid=Fe.parse(e.hash)),delete e.hash,e.type=1===e.type?"directory":"file",e}const Dr=bt((e=>async function(t,r={}){const n=await e.post("files/mkdir",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers});await n.text()})),Tr=bt((e=>async function(t,r,n={}){Array.isArray(t)||(t=[t]);const a=await e.post("files/mv",{signal:n.signal,searchParams:kt({arg:t.concat(r),...n}),headers:n.headers});await a.text()}));var Lr=r(50590);const Cr=bt((e=>async function*(t,r={}){const n=await e.post("files/read",{signal:r.signal,searchParams:kt({arg:t,count:r.length,...r}),headers:r.headers});yield*Lr(n.body)})),zr=bt((e=>async function(t,r={}){const n=await e.post("files/rm",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers}),a=await n.text();if(""!==a){const e=new it.HTTPError(n);throw e.message=a,e}})),Or=bt((e=>async function(t,r={}){const n=await e.post("files/stat",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers}),a=await n.json();return a.WithLocality=a.WithLocality||!1,(s=Sr(a)).cid=Fe.parse(s.hash),delete s.hash,s;var s}));const Ur=bt((e=>async function(t,r,n={}){const a=new AbortController,s=Dt(a.signal,n.signal),i=await e.post("files/write",{signal:s,searchParams:kt({arg:t,streamChannels:!0,count:n.length,...n}),...await(0,Nt.x)([{content:r,path:"arg",mode:_t(n.mode),mtime:Et(n.mtime)}],a,n.headers)});await i.text()}));function $r(e){return{cp:Ar(e),flush:Ir(e),ls:Nr(e),mkdir:Dr(e),mv:Tr(e),read:Cr(e),rm:zr(e),stat:Or(e),write:Ur(e)}}const jr=bt((e=>async(e,t,r={})=>{throw vt(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")})),Mr=bt((e=>async function(t,r={type:"Ed25519"}){const n=await e.post("key/gen",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers});return xr(await n.json())})),Br=bt((e=>async function(t,r,n,a={}){const s=await e.post("key/import",{signal:a.signal,searchParams:kt({arg:t,pem:r,password:n,...a}),headers:a.headers});return xr(await s.json())})),Zr=bt((e=>async(e,t={})=>{throw vt(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")})),Vr=bt((e=>async function(t={}){const r=await e.post("key/list",{signal:t.signal,searchParams:kt(t),headers:t.headers});return((await r.json()).Keys||[]).map((e=>xr(e)))})),Hr=bt((e=>async function(t,r,n={}){const a=await e.post("key/rename",{signal:n.signal,searchParams:kt({arg:[t,r],...n}),headers:n.headers});return xr(await a.json())})),Fr=bt((e=>async function(t,r={}){const n=await e.post("key/rm",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers});return xr((await n.json()).Keys[0])}));function Kr(e){return{export:jr(e),gen:Mr(e),import:Br(e),info:Zr(e),list:Vr(e),rename:Hr(e),rm:Fr(e)}}const Gr=bt((e=>async function(t,r,n={}){const a=await e.post("log/level",{signal:n.signal,searchParams:kt({arg:[t,r],...n}),headers:n.headers});return xr(await a.json())})),Wr=bt((e=>async function(t={}){const r=await e.post("log/ls",{signal:t.signal,searchParams:kt(t),headers:t.headers});return(await r.json()).Strings})),qr=bt((e=>async function*(t={}){const r=await e.post("log/tail",{signal:t.signal,searchParams:kt(t),headers:t.headers});yield*r.ndjson()}));function Yr(e){return{level:Gr(e),ls:Wr(e),tail:qr(e)}}const Xr=bt((e=>async function(t,r={}){const n=await e.post("name/publish",{signal:r.signal,searchParams:kt({arg:`${t}`,...r}),headers:r.headers});return xr(await n.json())})),Jr=bt((e=>async function*(t,r={}){const n=await e.post("name/resolve",{signal:r.signal,searchParams:kt({arg:t,stream:!0,...r}),headers:r.headers});for await(const e of n.ndjson())yield e.Path})),Qr=bt((e=>async function(t,r={}){const n=await e.post("name/pubsub/cancel",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers});return xr(await n.json())})),en=bt((e=>async function(t={}){const r=await e.post("name/pubsub/state",{signal:t.signal,searchParams:kt(t),headers:t.headers});return xr(await r.json())})),tn=bt((e=>async function(t={}){const r=await e.post("name/pubsub/subs",{signal:t.signal,searchParams:kt(t),headers:t.headers});return(await r.json()).Strings||[]}));function rn(e){return{cancel:Qr(e),state:en(e),subs:tn(e)}}function nn(e){return{publish:Xr(e),resolve:Jr(e),pubsub:rn(e)}}const an=bt((e=>async function(t,r={}){const n=await e.post("object/data",{signal:r.signal,searchParams:kt({arg:`${t instanceof Uint8Array?Fe.decode(t):t}`,...r}),headers:r.headers}),a=await n.arrayBuffer();return new Uint8Array(a,0,a.byteLength)})),sn=bt((e=>async function(t,r={}){const n=await e.post("object/get",{signal:r.signal,searchParams:kt({arg:`${t instanceof Uint8Array?Fe.decode(t):t}`,dataEncoding:"base64",...r}),headers:r.headers}),a=await n.json();return{Data:Jt(a.Data,"base64pad"),Links:(a.Links||[]).map((e=>({Name:e.Name,Hash:Fe.parse(e.Hash),Tsize:e.Size})))}})),on=bt((e=>async function(t,r={}){const n=await e.post("object/links",{signal:r.signal,searchParams:kt({arg:`${t instanceof Uint8Array?Fe.decode(t):t}`,...r}),headers:r.headers});return((await n.json()).Links||[]).map((e=>({Name:e.Name,Tsize:e.Size,Hash:Fe.parse(e.Hash)})))})),cn=bt((e=>async function(t={}){const r=await e.post("object/new",{signal:t.signal,searchParams:kt({arg:t.template,...t}),headers:t.headers}),{Hash:n}=await r.json();return Fe.parse(n)})),dn=(e,t)=>{const r=bt((r=>{const n=dr(e,t);return async function(e,t={}){return n(e,{...t,storeCodec:"dag-pb",hashAlg:"sha2-256",version:1})}}));return r(t)},ln=bt((e=>async function(t,r={}){const n=await e.post("object/stat",{signal:r.signal,searchParams:kt({arg:`${t}`,...r}),headers:r.headers}),a=await n.json();return{...a,Hash:Fe.parse(a.Hash)}})),hn=bt((e=>async function(t,r,n={}){const a=await e.post("object/patch/add-link",{signal:n.signal,searchParams:kt({arg:[`${t}`,r.Name||r.name||"",(r.Hash||r.cid||"").toString()||null],...n}),headers:n.headers}),{Hash:s}=await a.json();return Fe.parse(s)})),un=bt((e=>async function(t,r,n={}){const a=new AbortController,s=Dt(a.signal,n.signal),i=await e.post("object/patch/append-data",{signal:s,searchParams:kt({arg:`${t}`,...n}),...await(0,Nt.x)([r],a,n.headers)}),{Hash:o}=await i.json();return Fe.parse(o)})),pn=bt((e=>async function(t,r,n={}){const a=await e.post("object/patch/rm-link",{signal:n.signal,searchParams:kt({arg:[`${t}`,r.Name||r.name||null],...n}),headers:n.headers}),{Hash:s}=await a.json();return Fe.parse(s)})),fn=bt((e=>async function(t,r,n={}){const a=new AbortController,s=Dt(a.signal,n.signal),i=await e.post("object/patch/set-data",{signal:s,searchParams:kt({arg:[`${t}`],...n}),...await(0,Nt.x)([r],a,n.headers)}),{Hash:o}=await i.json();return Fe.parse(o)}));function wn(e){return{addLink:hn(e),appendData:un(e),rmLink:pn(e),setData:fn(e)}}function gn(e,t){return{data:an(t),get:sn(t),links:on(t),new:cn(t),put:dn(e,t),stat:ln(t),patch:wn(t)}}var yn=r(73297);const mn=bt((e=>async function*(t,r={}){for await(const{path:n,recursive:a,metadata:s}of(0,yn.f)(t)){const t=await e.post("pin/add",{signal:r.signal,searchParams:kt({...r,arg:n,recursive:a,metadata:s?JSON.stringify(s):void 0,stream:!0}),headers:r.headers});for await(const e of t.ndjson())if(e.Pins)for(const t of e.Pins)yield Fe.parse(t);else yield Fe.parse(e)}}));function bn(e){const t=mn(e);return bt((()=>async function(e,r={}){return(0,ir.Z)(t([{path:e,...r}],r))}))(e)}function _n(e,t,r){const n={type:e,cid:Fe.parse(t)};return r&&(n.metadata=r),n}const vn=bt((e=>async function*(t={}){let r=[];t.paths&&(r=Array.isArray(t.paths)?t.paths:[t.paths]);const n=await e.post("pin/ls",{signal:t.signal,searchParams:kt({...t,arg:r.map((e=>`${e}`)),stream:!0}),headers:t.headers});for await(const e of n.ndjson()){if(e.Keys){for(const t of Object.keys(e.Keys))yield _n(e.Keys[t].Type,t,e.Keys[t].Metadata);return}yield _n(e.Type,e.Cid,e.Metadata)}})),En=bt((e=>async function*(t,r={}){for await(const{path:n,recursive:a}of(0,yn.f)(t)){const t=new URLSearchParams(r.searchParams);t.append("arg",`${n}`),null!=a&&t.set("recursive",String(a));const s=await e.post("pin/rm",{signal:r.signal,headers:r.headers,searchParams:kt({...r,arg:`${n}`,recursive:a})});for await(const e of s.ndjson())e.Pins?yield*e.Pins.map((e=>Fe.parse(e))):yield Fe.parse(e)}})),kn=e=>{const t=En(e);return bt((()=>async function(e,r={}){return(0,ir.Z)(t([{path:e,...r}],r))}))(e)},Rn=({Name:e,Status:t,Cid:r})=>({cid:Fe.parse(r),name:e,status:t}),An=e=>{if("string"==typeof e&&""!==e)return e;throw new TypeError("service name must be passed")},In=e=>{if(Fe.asCID(e))return e.toString();throw new TypeError("CID instance expected instead of "+typeof e)},xn=({service:e,cid:t,name:r,status:n,all:a})=>{const s=kt({service:An(e),name:r,force:!!a||void 0});if(t)for(const e of t)s.append("cid",In(e));if(n)for(const e of n)s.append("status",e);return s},Sn=({cid:e,service:t,background:r,name:n,origins:a})=>{const s=kt({arg:In(e),service:An(t),name:n,background:!!r||void 0});if(a)for(const e of a)s.append("origin",e.toString());return s};function Nn(e){return async function(t,{timeout:r,signal:n,headers:a,...s}){const i=await e.post("pin/remote/add",{timeout:r,signal:n,headers:a,searchParams:Sn({cid:t,...s})});return Rn(await i.json())}}function Pn(e){return async function*({timeout:t,signal:r,headers:n,...a}){const s=await e.post("pin/remote/ls",{timeout:t,signal:r,headers:n,searchParams:xn(a)});for await(const e of s.ndjson())yield Rn(e)}}function Dn(e){return async function({timeout:t,signal:r,headers:n,...a}){await e.post("pin/remote/rm",{timeout:t,signal:r,headers:n,searchParams:xn({...a,all:!1})})}}function Tn(e){return async function({timeout:t,signal:r,headers:n,...a}){await e.post("pin/remote/rm",{timeout:t,signal:r,headers:n,searchParams:xn({...a,all:!0})})}}function Ln(e){const t=String(e);if("undefined"===t)throw Error("endpoint is required");return"/"===t[t.length-1]?t.slice(0,-1):t}function Cn(e){return{service:e.Service,endpoint:new URL(e.ApiEndpoint),...e.Stat&&{stat:zn(e.Stat)}}}function zn(e){switch(e.Status){case"valid":{const{Pinning:t,Pinned:r,Queued:n,Failed:a}=e.PinCount;return{status:"valid",pinCount:{queued:n,pinning:t,pinned:r,failed:a}}}case"invalid":return{status:"invalid"};default:return{status:e.Status}}}function On(e){return async function(t,r){const{endpoint:n,key:a,headers:s,timeout:i,signal:o}=r;await e.post("pin/remote/service/add",{timeout:i,signal:o,searchParams:kt({arg:[t,Ln(n),a]}),headers:s})}}function Un(e){return async function(t={}){const{stat:r,headers:n,timeout:a,signal:s}=t,i=await e.post("pin/remote/service/ls",{timeout:a,signal:s,headers:n,searchParams:!0===r?kt({stat:r}):void 0}),{RemoteServices:o}=await i.json();return o.map(Cn)}}function $n(e){return async function(t,r={}){await e.post("pin/remote/service/rm",{signal:r.signal,headers:r.headers,searchParams:kt({arg:t})})}}function jn(e){const t=new mt(e);return{add:On(t),ls:Un(t),rm:$n(t)}}function Mn(e){const t=new mt(e);return{add:Nn(t),ls:Pn(t),rm:Dn(t),rmAll:Tn(t),service:jn(e)}}function Bn(e){return{addAll:mn(e),add:bn(e),ls:vn(e),rmAll:En(e),rm:kn(e),remote:Mn(e)}}const Zn=e=>wr(Vn(e)),Vn=e=>Ee.decode(e),Hn=e=>BigInt(`0x${wr(Ee.decode(e),"base16")}`),Fn=e=>Ee.encode(Jt(e)),Kn=bt((e=>async function(t={}){const{Strings:r}=await(await e.post("pubsub/ls",{signal:t.signal,searchParams:kt(t),headers:t.headers})).json();return n=r,(Array.isArray(n)?n.map(Zn):n)||[];var n})),Gn=bt((e=>async function(t,r={}){const n=await e.post("pubsub/peers",{signal:r.signal,searchParams:kt({arg:Fn(t),...r}),headers:r.headers}),{Strings:a}=await n.json();return a||[]})),Wn=bt((e=>async function(t,r,n={}){const a=kt({arg:Fn(t),...n}),s=new AbortController,i=Dt(s.signal,n.signal),o=await e.post("pubsub/pub",{signal:i,searchParams:a,...await(0,Nt.x)([r],s,n.headers)});await o.text()})),qn=(0,st.kg)("js-kubo-rpc-client:pubsub:subscribe"),Yn=(e,t)=>bt((e=>async function(r,n,a={}){let s,i;a.signal=t.subscribe(r,n,a.signal);const o=new Promise(((e,t)=>{s=e,i=t})),c=setTimeout((()=>s()),1e3);return e.post("pubsub/sub",{signal:a.signal,searchParams:kt({arg:Fn(r),...a}),headers:a.headers}).catch((e=>{t.unsubscribe(r,n),i(e)})).then((e=>{clearTimeout(c),e&&(!async function(e,{onMessage:t,onEnd:r,onError:n}){n=n||qn;try{for await(const r of e.ndjson())try{if(!r.from)continue;null!=r.from&&null!=r.seqno?t({type:"signed",from:(0,It.jE)(r.from),data:Vn(r.data),sequenceNumber:Hn(r.seqno),topic:Zn(r.topicIDs[0]),key:Vn(r.key??"u"),signature:Vn(r.signature??"u")}):t({type:"unsigned",data:Vn(r.data),topic:Zn(r.topicIDs[0])})}catch(e){e.message=`Failed to parse pubsub message: ${e.message}`,n(e,!1,r)}}catch(e){Xn(e)||n(e,!0)}finally{r()}}(e,{onMessage:e=>{n&&("function"!=typeof n?"function"==typeof n.handleEvent&&n.handleEvent(e):n(e))},onEnd:()=>t.unsubscribe(r,n),onError:a.onError}),s())})),o}))(e);const Xn=e=>{switch(e.type){case"aborted":case"abort":return!0;default:return"AbortError"===e.name}};class Jn{constructor(){this._subs=new Map}subscribe(e,t,r){const n=this._subs.get(e)||[];if(n.find((e=>e.handler===t)))throw new Error(`Already subscribed to ${e} with this handler`);const a=new AbortController;return this._subs.set(e,[{handler:t,controller:a}].concat(n)),r&&r.addEventListener("abort",(()=>this.unsubscribe(e,t))),a.signal}unsubscribe(e,t){const r=this._subs.get(e)||[];let n;t?(this._subs.set(e,r.filter((e=>e.handler!==t))),n=r.filter((e=>e.handler===t))):(this._subs.set(e,[]),n=r),(this._subs.get(e)||[]).length||this._subs.delete(e),n.forEach((e=>e.controller.abort()))}}function Qn(e){const t=new Jn;return{ls:Kn(e),peers:Gn(e),publish:Wn(e),subscribe:Yn(e,t),unsubscribe:(r=t,async function(e,t){r.unsubscribe(e,t)})};var r}const ea=bt((e=>async function*(t={}){const r=await e.post("refs/local",{signal:t.signal,transform:xr,searchParams:kt(t),headers:t.headers});yield*r.ndjson()})),ta=bt(((e,t)=>Object.assign((async function*(t,r={}){const n=Array.isArray(t)?t:[t],a=await e.post("refs",{signal:r.signal,searchParams:kt({arg:n.map((e=>`${e instanceof Uint8Array?Fe.decode(e):e}`)),...r}),headers:r.headers,transform:xr});yield*a.ndjson()}),{local:ea(t)}))),ra=bt((e=>async function*(t={}){const r=await e.post("repo/gc",{signal:t.signal,searchParams:kt(t),headers:t.headers,transform:e=>({err:e.Error?new Error(e.Error):null,cid:(e.Key||{})["/"]?Fe.parse(e.Key["/"]):null})});yield*r.ndjson()})),na=bt((e=>async function(t={}){const r=await e.post("repo/stat",{signal:t.signal,searchParams:kt(t),headers:t.headers}),n=await r.json();return{numObjects:BigInt(n.NumObjects),repoSize:BigInt(n.RepoSize),repoPath:n.RepoPath,version:n.Version,storageMax:BigInt(n.StorageMax)}})),aa=bt((e=>async function(t={}){return(await(await e.post("repo/version",{signal:t.signal,searchParams:kt(t),headers:t.headers})).json()).Version}));function sa(e){return{gc:ra(e),stat:na(e),version:aa(e)}}const ia=bt((e=>async function*(t={}){const r=await e.post("stats/bw",{signal:t.signal,searchParams:kt(t),headers:t.headers,transform:e=>({totalIn:BigInt(e.TotalIn),totalOut:BigInt(e.TotalOut),rateIn:parseFloat(e.RateIn),rateOut:parseFloat(e.RateOut)})});yield*r.ndjson()}));function oa(e){return{bitswap:xt(e),repo:na(e),bw:ia(e)}}const ca=bt((e=>async function(t={}){const r=await e.post("swarm/addrs",{signal:t.signal,searchParams:kt(t),headers:t.headers}),{Addrs:n}=await r.json();return Object.keys(n).map((e=>({id:(0,It.jE)(e),addrs:(n[e]||[]).map((e=>(0,rt.HM)(e)))})))})),da=bt((e=>async function(t,r={}){const n=await e.post("swarm/connect",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers}),{Strings:a}=await n.json();return a||[]})),la=bt((e=>async function(t,r={}){const n=await e.post("swarm/disconnect",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers}),{Strings:a}=await n.json();return a||[]})),ha=bt((e=>async function(t={}){const r=await e.post("swarm/addrs/local",{signal:t.signal,searchParams:kt(t),headers:t.headers}),{Strings:n}=await r.json();return(n||[]).map((e=>(0,rt.HM)(e)))})),ua=bt((e=>async function(t={}){const r=await e.post("swarm/peers",{signal:t.signal,searchParams:kt(t),headers:t.headers}),{Peers:n}=await r.json();return(n||[]).map((e=>({addr:(0,rt.HM)(e.Addr),peer:(0,It.jE)(e.Peer),muxer:e.Muxer,latency:e.Latency,streams:e.Streams,direction:null==e.Direction?void 0:0===e.Direction?"inbound":"outbound"})))}));function pa(e){return{addrs:ca(e),connect:da(e),disconnect:la(e),localAddrs:ha(e),peers:ua(e)}}const fa=bt((e=>async function*(t,r={}){const n=new AbortController,a=Dt(n.signal,r.signal),{headers:s,body:i,total:o,parts:c}=await(0,Nt.x)(t,n,r.headers),[d,l]="function"==typeof r.progress?wa(o,c,r.progress):[void 0,void 0],h=await e.post("add",{searchParams:kt({"stream-channels":!0,...r,progress:Boolean(d)}),onUploadProgress:l,signal:a,headers:s,body:i});for await(let e of h.ndjson())e=xr(e),void 0!==e.hash?yield ya(e):d&&d(e.bytes||0,e.name)})),wa=(e,t,r)=>t?[void 0,ga(e,t,r)]:[r,void 0],ga=(e,t,r)=>{let n=0;const a=t.length;return({loaded:s,total:i})=>{const o=Math.floor(s/i*e);for(;n<a;){const{start:e,end:a,name:s}=t[n];if(o<a){r(o-e,s);break}r(a-e,s),n+=1}}};function ya({name:e,hash:t,size:r,mode:n,mtime:a,mtimeNsecs:s}){const i={path:e,cid:Fe.parse(t),size:parseInt(r)};return null!=n&&(i.mode=parseInt(n,8)),null!=a&&(i.mtime={secs:a,nsecs:s||0}),i}var ma=r(56740);function ba(e){const t=fa(e);return bt((()=>async function(e,r={}){const n=(0,ma.f)(e),a=t(n,r);return await(0,ir.Z)(a)}))(e)}const _a=bt((e=>async function*(t,r={}){const n=await e.post("cat",{signal:r.signal,searchParams:kt({arg:t.toString(),...r}),headers:r.headers});yield*n.iterator()})),va=bt((e=>async(t={})=>(await e.post("commands",{signal:t.signal,searchParams:kt(t),headers:t.headers})).json())),Ea=bt((e=>async(t,r={})=>{const n=await e.post("dns",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers});return(await n.json()).Path})),ka=bt((e=>()=>{const t=new URL(e.opts.base||"");return{host:t.hostname,port:t.port,protocol:t.protocol,pathname:t.pathname,"api-path":t.pathname}})),Ra=bt((e=>async function*(t,r={}){const n={arg:`${t instanceof Uint8Array?Fe.decode(t):t}`,...r};n.compressionLevel&&(n["compression-level"]=n.compressionLevel,delete n.compressionLevel);const a=await e.post("get",{signal:r.signal,searchParams:kt(n),headers:r.headers});yield*a.iterator()})),Aa=bt((e=>async function(t={}){const r=await e.post("id",{signal:t.signal,searchParams:kt({arg:t.peerId?t.peerId.toString():void 0,...t}),headers:t.headers}),n={...xr(await r.json())};return n.id=(0,It.jE)(n.id),n.addresses&&(n.addresses=n.addresses.map((e=>(0,rt.HM)(e)))),n})),Ia=e=>{const t=Aa(e);return async function(e={}){const r=await t(e);return Boolean(r&&r.addresses&&r.addresses.length)}},xa=bt(((e,t)=>async function*(r,n={}){const a=`${r instanceof Uint8Array?Fe.decode(r):r}`;async function s(e){let r=e.Hash;if(r.includes("/")){const e=r.startsWith("/ipfs/")?r:`/ipfs/${r}`;r=(await Or(t)(e)).cid}else r=Fe.parse(r);const n={name:e.Name,path:a+(e.Name?`/${e.Name}`:""),size:e.Size,cid:r,type:Sa(e)};return e.Mode&&(n.mode=parseInt(e.Mode,8)),void 0!==e.Mtime&&null!==e.Mtime&&(n.mtime={secs:e.Mtime},void 0!==e.MtimeNsecs&&null!==e.MtimeNsecs&&(n.mtime.nsecs=e.MtimeNsecs)),n}const i=await e.post("ls",{signal:n.signal,searchParams:kt({arg:a,...n}),headers:n.headers});for await(let e of i.ndjson()){if(e=e.Objects,!e)throw new Error("expected .Objects in results");if(e=e[0],!e)throw new Error("expected one array in results.Objects");const t=e.Links;if(!Array.isArray(t))throw new Error("expected one array in results.Objects[0].Links");if(!t.length)return void(yield s(e));yield*t.map(s)}}));function Sa(e){switch(e.Type){case 1:case 5:return"dir";default:return"file"}}const Na=bt((e=>async function(t={}){const r=await e.post("dns",{signal:t.signal,searchParams:kt(t),headers:t.headers});return xr(await r.json())})),Pa=bt((e=>async function*(t,r={}){const n=await e.post("ping",{signal:r.signal,searchParams:kt({arg:`${t}`,...r}),headers:r.headers,transform:xr});yield*n.ndjson()})),Da=bt((e=>async function(t,r={}){const n=await e.post("resolve",{signal:r.signal,searchParams:kt({arg:t,...r}),headers:r.headers}),{Path:a}=await n.json();return a})),Ta=bt((e=>async(e={})=>{throw vt(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")})),La=bt((e=>async function(t={}){const r=await e.post("shutdown",{signal:t.signal,searchParams:kt(t),headers:t.headers});await r.text()})),Ca=bt((e=>async function(t={}){const r=await e.post("version",{signal:t.signal,searchParams:kt(t),headers:t.headers});return{...xr(await r.json()),"ipfs-http-client":"1.0.0"}}));r(85104),r(46953);function za(e={}){const t={name:H.name,code:H.code,encode:e=>e,decode:e=>e},r=Object.values(Qe);(e.ipld&&e.ipld.bases?e.ipld.bases:[]).forEach((e=>r.push(e)));const n=new y.x({bases:r,loadBase:e.ipld&&e.ipld.loadBase}),a=Object.values(tt);[_,v,E,k,t].concat(e.ipld&&e.ipld.codecs||[]).forEach((e=>a.push(e)));const s=new m.w({codecs:a,loadCodec:e.ipld&&e.ipld.loadCodec}),i=Object.values(et);(e.ipld&&e.ipld.hashers?e.ipld.hashers:[]).forEach((e=>i.push(e)));const o=new b.d({hashers:i,loadHasher:e.ipld&&e.ipld.loadHasher});var c;return{add:ba(e),addAll:fa(e),bitswap:(c=e,{wantlist:Rt(c),wantlistForPeer:At(c),stat:xt(c)}),block:Ot(e),bootstrap:Zt(e),cat:_a(e),commands:va(e),config:rr(e),dag:hr(s,e),dht:_r(e),diag:Rr(e),dns:Ea(e),files:$r(e),get:Ra(e),getEndpointConfig:ka(e),id:Aa(e),isOnline:Ia(e),key:Kr(e),log:Yr(e),ls:xa(e),mount:Na(e),name:nn(e),object:gn(s,e),pin:Bn(e),ping:Pa(e),pubsub:Qn(e),refs:ta(e),repo:sa(e),resolve:Da(e),start:Ta(e),stats:oa(e),stop:La(e),swarm:pa(e),version:Ca(e),bases:n,codecs:s,hashers:o}}}}]);